<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
  <title></title>
  <meta name="Author" content="">
  <meta name="GENERATOR"
 content="User-Agent: Mozilla/3.04Gold (Macintosh; I; PPC)">
</head>
<body>
<h1 align="center"><a
 href="http://www.nouspikel.com/ti99/titechpages.htm"><img
 src="logo.jpg" style="border: 0px solid ; height: 33px; width: 95px;"
 title="Back to main index" alt=""></a></h1>
<h1>The keyboard</h1>
<p>The keyboard is internally organised as 6 columns of 8 keys. Note
that
both shift keys are connected together and that the alpha-lock key has
its own "column" connection. Presing a key closes the connection
between a column and a row, thus the CPU can detect a key by energizing
columns one at a time and reading the status of the rows.</p>
<p><b>Hardware<br>
</b><a href="#hardware">Internal connector<br>
</a><a href="#circuit">Circuitery<br>
</a><a href="#CRU%20map">CRU map<br>
</a><a href="#phantom">Phantom keys</a></p>
<p><b>Software<br>
</b><a href="#Built-in">Built-in routines<br>
</a><a href="#quick%20scan">Quick scanning routines<br>
</a><a href="#auto-repeat">Auto-repeat keys<br>
</a><a href="#int%20driven">Interrupt-activating keys</a><br>
</p>
<p><a href="tutor1.htm">Keyboard tutorial and challenge</a><br>
</p>
<h2><a name="hardware"></a>Hardware</h2>
<h3>Connector</h3>
<p>The keyboard in connected to the console mother board by a 16-pin
connector
that is only appearent when opening the console. Pin number 1 should be
labelled as such on the motherboard. Wire number 15 on the keyboard
cable
is generally red, whereas other wires are green.</p>
<pre> 1 Keyboard row 2 (enter O I&nbsp;U&nbsp;Y&nbsp;P joystick_right)<br> 2 Keyboard row 3 ( &lt;nc&gt; 9 8 7 6 0 joystick_down)<br> 3 Keyboard row 5 (shift S D F G A)<br> 4 Keyboard row 1 (space L K J H ; joystick_left)<br> 5 Keyboard row 0 ( =    . , m n / joystick_fire)<br> 6 Keyboard alpha-lock key <br> 7 Keyboard row 4 (fctn  2 3 4 5 1 joystick_up alpha_lock)<br> 8 Keyboard column 5 ( / ; P 0 1 A Q Z)<br> 9 Keyboard column 4 ( N H Y 6 5 G T B)<br>10 Keyboard row 6 (ctrl W E R T Q)<br>11 Keyboard row 7 (&lt;nc&gt; X C V B Z) <br>12 Keyboard column 0 (= space enter &lt;nc&gt; fctn shift ctrl &lt;nc&gt;)<br>13 Keyboard column 1 (. L O 9 2 S W X)<br>14 Keyboard column 2 (, K I 8 3 D E C)<br><b><font
 color="#ff0000">15 </font></b>Keyboard column 3 (M J U 7 4 F R V)<br>16</pre>
<h3><a name="circuit"></a>Internal circuitery</h3>
<p>The keyboard is organised as 6 columns of 8 keys. The columns are
connected
to six of the open collector outputs of a 74LS156 and pulled up to +5V
via 1K resistors (the remaining two outputs are used for joysticks).
The
keyboard rows (and joystick inputs) are connected to the inputs of the
TMS9901 programmable system interface and pulled up at +5V via 10K
resistors.
The TMS9901 also controls the decoder in charge of the row selection.
Pressing
a key results in physically connecting the wires connected to this
column
and that row. </p>
<table cellspacing="2" cellpadding="2" bgcolor="#cccce6">
  <tbody>
    <tr>
      <td>
      <pre>9901                                   1K       10 pF<br>------+              74LS156     +5V---WWW---+---||---Gnd<br>      |           +-----------+              | <br>   P2 |-----------| S0    1Y0*|--------------+---UUU------&gt; Keyboard connector<br>   P3 |-----------| S1    1Y1*|--- Ditto        6.8 uH<br>   P4 |-------+---| 1GA*  2Y0*|--- Ditto         1K<br>      |       '---| 2GA*  2Y1*|--- Ditto    ,---WWW---+----+5V<br>      |           |       2Y2*|--- Ditto    |    ,----'<br>      |       ,---| 1GB*  2Y3*|--- Ditto    |  |/<br>      |       +---| 2GB*  1Y2*|-------------+--| <br>      |       |   |       1Y3*|--- Ditto       |\      270 Ohm   10 Ohm<br>      |      Gnd  |           |          1.5K    V-+---WWW---+---WWW---&gt; Joystick  <br>      |           |           |     -5V---WWW------'         '---||---Gnd <br>      |           +-----------+                                 10 pF<br>      |<br>      |                              10K      10 pF<br>      |                        +5V---WWW---+---||---Gnd<br>      |                                    |<br>INT3* |------------------------------------+---WWW-----+---&lt; Keyboard connector<br>INT4* |--- Ditto                             470 Ohms  |<br>INT5* |--- Ditto                                       '---&lt; Joystick connector<br>INT6* |--- Ditto<br>INT7* |--- Ditto<br>INT8* |--- Ditto<br>INT9* |--- Ditto<br>INT10*|--- Ditto<br>   P5 |--- Ditto (output to alpha-lock key)<br>------+</pre>
      </td>
    </tr>
  </tbody>
</table>
<p>To scan the keyboard, we must first activate a column by sending its
number to CRU bit 18-20 at R12-address &gt;0024. The bits are fed to
the
74LS156 decoder that brings the corresponding keyboard column low. Then
we must read the status of each keyboard row in CRU bits 3-10 at
R12-address
&gt;0006. If a key is pressed the row will read as 0, otherwise it
reads
as 1 (non-intuituve!).</p>
<h3><br>
<a name="CRU map"></a>CRU map</h3>
<p>Here is the keyboard layout in terms of CRU:</p>
<table border="1">
  <tbody>
    <tr>
      <td>.</td>
      <th>Column</th>
      <td>0</td>
      <td>1</td>
      <td>2</td>
      <td>3</td>
      <td>4</td>
      <td>5</td>
      <td>6</td>
      <td>7</td>
      <td>A-lock</td>
    </tr>
    <tr>
      <th>R12 address</th>
      <th>Pin # </th>
      <td>12 </td>
      <td>13</td>
      <td>14</td>
      <td>15</td>
      <td>9</td>
      <td>8</td>
      <td>J7</td>
      <td>J2</td>
      <td>6</td>
    </tr>
    <tr>
      <td>&gt;0006</td>
      <td>5/J4</td>
      <td>=</td>
      <td>.</td>
      <td>,</td>
      <td>M</td>
      <td>N</td>
      <td>/</td>
      <td>Fire</td>
      <td>Fire</td>
    </tr>
    <tr>
      <td>&gt;0008</td>
      <td>4/J5</td>
      <td>Space</td>
      <td>L</td>
      <td>K</td>
      <td>J</td>
      <td>H</td>
      <td>;</td>
      <td>Left</td>
      <td>Left</td>
    </tr>
    <tr>
      <td>&gt;000A</td>
      <td>1/J9</td>
      <td>Enter</td>
      <td>O</td>
      <td>I</td>
      <td>U</td>
      <td>Y</td>
      <td>P</td>
      <td>Right</td>
      <td>Right</td>
    </tr>
    <tr>
      <td>&gt;000C</td>
      <td>2/J8</td>
      <td><br>
      </td>
      <td>9</td>
      <td>8</td>
      <td>7</td>
      <td>6</td>
      <td>0</td>
      <td>Down</td>
      <td>Down</td>
    </tr>
    <tr>
      <td>&gt;000E</td>
      <td>7/J3</td>
      <td>Fctn</td>
      <td>2</td>
      <td>3</td>
      <td>4</td>
      <td>5</td>
      <td>1</td>
      <td>Up</td>
      <td>Up</td>
      <td>A-lock</td>
    </tr>
    <tr>
      <td>&gt;0010</td>
      <td>3</td>
      <td>Shift</td>
      <td>S</td>
      <td>D</td>
      <td>F</td>
      <td>G</td>
      <td>A</td>
      <td><br>
      </td>
      <td><br>
      </td>
    </tr>
    <tr>
      <td>&gt;0012</td>
      <td>10</td>
      <td>Ctrl</td>
      <td>W</td>
      <td>E</td>
      <td>R</td>
      <td>T</td>
      <td>Q</td>
      <td><br>
      </td>
      <td><br>
      </td>
    </tr>
    <tr>
      <td>&gt;0014</td>
      <td>11</td>
      <td><br>
      </td>
      <td>X</td>
      <td>C</td>
      <td>V</td>
      <td>B</td>
      <td>Z</td>
      <td><br>
      </td>
      <td><br>
      </td>
    </tr>
  </tbody>
</table>
<p>The alpha-lock key is activated by the TMS9901 output P5 (R12
address
&gt;002A) and reads together with keyboard row 4. This has the very
unfortunate
effect of messing up the joystick "up" signal when the alpha-lock
key is engaged. Why the TI engineers did not pick row 7 (pin #11)
instead,
is a mystery to me.</p>
<h3><br>
<a name="phantom"></a>Phantom keys </h3>
<p>We can now explain the phenomenon known as "phantom key":
when you press three keys together, the console may detect a fourth
key,
even if it isn't pressed. This occurs when the keys you pressed occupy
the three corners of a square in the above table: the phantom key is
the
one on the fourth corner. </p>
<p>For instance, suppose you pressed Ctrl-Shift-S. When the processor
tests
column 0, it brings pin 12 low. Since both &lt;Shift&gt; and
&lt;Ctrl&gt;
are pressed, both pin 3 and pin 10 will be low and CRU bits 8 and 9
read
as 0. So far, so good. But let's see what happens when testing column
1.
Pin 13 goes low and, since &lt;S&gt; is pressed, so does pin 3 thus bit
8 reads as 0. BUT, since the &lt;Shift&gt; key is placed on the same
row,
column 0 will also go low, and since &lt;Ctrl&gt; is down, pin 10 goes
low and bit 9 reads as 0. Which creates the illusion that &lt;W&gt; was
pressed. See what I mean?</p>
<p>All this is due to the fact that electrons can flow back from a row
to a column. To prevent this from happening we would need to install a
diode at each key. That's something you should consider if you ever
wanted
to create a piano keyboard for the TI-99/4A. On a piano it is very
common
that 3 or more keys are pressed. On a computer on the other hand, it is
rare to press more than two keys, so we can live with the phantom key
problem.
Also note that some multiple key combinations are ok, if the three keys
are aligned on the same column (Ctrl-Shift-=), on the same row (1-2-3),
or do not form a square (Ctrl-Shift-1).</p>
<h2><br>
<br>
Software</h2>
<h3><a name="Built-in"></a>Built-in keyboard scanning routines</h3>
<p>This is the standard way to call the built-in keyboard scanning
routine
in the console ROM. Note that we must change the workspace to &gt;83E0
using a <tt>LWPI </tt>instruction, and not a <tt>BLWP</tt>. This is
because
R13 to R15 in the &gt;83E0 workspace are used to hold special values
that
should not be erased (GROM base, various flags, VDP write-address
port).
To save space, I have placed my WREGS workspace in such a way that
R0-R12
are overwritten by the program, you don't have to do that if you don't
want to.</p>
<p>On the other hand, the test for Fctn-4 can be called with any
workspace,
as it only uses R12.</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre>*--------------------------------------------<br>* Calls the built-in keyboard scanning in console ROM<br>*--------------------------------------------<br>WREGS<br>KSCAN  DATA WREGS,KSCAN1<br> <br>KSCAN1 LWPI &gt;83E0           can't change WS with BLWP as R13-R15 are in use<br>       MOV  R11,@OLDR11     save GPL R11<br>       BL   @&gt;000E          call keyboard scanning routine<br>       MOV  @OLDR11,R11     restore GPL R11<br>       LWPI WREGS<br>       RTWP</pre>
      <pre>       BSS  6               R13-R15<br>OLDR11 DATA 0</pre>
      <pre>* Caller routine</pre>
      <pre>       BLWP @KSCAN<br>       MOVB @&gt;837C,R1       Check flag for key pressed<br>       SLA  R1,3            Flag value is &gt;20<br>       JNC  NOKEY           No key was pressed<br>       MOVB @&gt;8375,R1       Get key code<br>       ...<br></pre>
      <pre>*---------------------------------------------<br>* Calling the built-in Fctn-4 test in console ROM<br>*---------------------------------------------<br>TESTF4 BL   @&gt;0020          R12 will be modified<br>       JEQ  CLEAR           Fctn-4 was pressed<br>       JNE  NOCLR           It wasn't                  </pre>
      </td>
    </tr>
  </tbody>
</table>
<h3><br>
<a name="quick scan"></a>Quick keyboard scanning routines</h3>
<p>Now, some home-made routine. The first one checks whether a key is
down.
If yes, it calls the standard KSCAN routine to get the ASCII code,
otherwise
it just returns. This speeds up programs that needs to perform a lot of
operations while still watching the keyboard: no need to call the slow
KSCAN routine if no key is pressed. A similar routine could be used to
wait until the key has been released.</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre>*--------------------------------------------<br>* Quick-and-dirty check to see if a key is pressed. <br>* If not return in a hurry, <br>* else call the standard scanning routine.<br>* Uses R1, R2 and R12.<br>*--------------------------------------------<br>KCHECK CLR  R1                 Start with column 0<br>LP1    LI   R12,&gt;0024          R12-address for column selection<br>       LDCR R1,3               Select a column<br>       LI   R12,&gt;0006          R12-address to read rows<br>       SETO R2                 Make sure all bits are 1<br>       STCR R2,8               Get 8 row values<br>       INV  R2                 Since pressed keys read as 0<br>       JNE  KPR                A key was pressed<br>       AI   R1,&gt;0100           Next column<br>       CI   R1,&gt;0600           Are we done<br>       JNE  LP1                Not yet<br>       B    *R11               No key pressed: return (with EQ bit set)<br> <br>KPR    BLWP @KSCAN             Call KSCAN routine<br>       INCT R11               (either) signal key by skipping a jump<br>*      MOV  R2,R2             (or) signal key by clearing the EQ bit<br>       B    *R11               Return<br> </pre>
      </td>
    </tr>
  </tbody>
</table>
<p>Depending on the signaling technique chosen, the main program calls
the routine either like this:</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre>* Caller routine<br>       BL   @KCHECK           Assuming the INCT R11 solution <br>       JMP  GOON              Keep going <br>       ...                    Process key</pre>
      </td>
    </tr>
  </tbody>
</table>
<p>or like that (slightly faster since JNE is not taken when no key is
detected). </p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre>* Caller routine<br>       BL @KCHECK            Assuming the MOV R2,R2 solution <br>       JNE KEY               Process key <br>       JEQ NOKEY             Keep going</pre>
      </td>
    </tr>
  </tbody>
</table>
<p><br>
Of course things are even easier if we only want to check for one key
or
for a combination of keys located on the same column (and now you know
why &lt;QUIT&gt; is Fctn-=). No need for a loop, just test the
appropriate
column:</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre>*--------------------------------------------<br>* Routine to detect a key combination (in this case Fctn-=),<br>* returns with Eq bit set if this is the case.<br>* This routine alters R12 and R1<br>*--------------------------------------------<br>ISQUIT CLR  R1                  Test column 0<br>       LI   R12,&gt;0024           Address for column selection<br>       LDCR R1,3                Select column<br>       LI   R12,&gt;0006           Address to read rows<br>       STCR R1,8<br>       ANDI R1,&gt;1100            Mask all irrelevant bits<br>       B    *R11                Else return<br> <br>*--------------------------------------------<br>* Routine to detect a specific key (in this case &lt;enter&gt;),<br>* it returns with Eq bit set if &lt;enter&gt; was NOT pressed.<br>* Alters R12 only<br>*--------------------------------------------<br>ISENTR CLR  R1                  Test column 0<br>       LI   R12,&gt;0024           Address for column selection<br>       LDCR R12,3               Select column<br>       TB   -13                 Test R12-address &gt;000A, i.e &lt;enter&gt;<br>       B    *R11                &lt;enter&gt; was not pressed: return<br> </pre>
      <pre>* Caller routine<br>       BL   @ISQUIT<br>       JNE  NOQUIT<br>       JEQ  QUIT<br>       BL   @ISENTR<br>       JNE  ENTER<br>       JEQ  NOENTR</pre>
      </td>
    </tr>
  </tbody>
</table>
<p><a name="question"></a>Note that the "negative TB" trick would
also have worked for &lt;QUIT&gt; (using two tests of course).</p>
<h3><br>
<a name="auto-repeat"></a>Auto-repeat keys </h3>
<p>In TI-Basic, if you hold a key down for a moment, it begins
repeating
itself at high speed. This feature is not included in the console KSCAN
routine. Rather, KSCAN only detect changes, which requires a key to be
released (or another key pressed) before it can be repeated. Let's see
if we can get around that.</p>
<p>We all know the canonic addresses to be used with KSCAN: <br>
&gt;8374 contains the keyboard argument.<br>
&gt;8375 returns the key code, or &gt;FF if no key was pressed. <br>
&gt;8376 returns the X-value for a joystick (0,4, or &gt;FC).<br>
&gt;8377 returns the X-value for a joystick. <br>
&gt;837C bit 2 (value &gt;20) is set if a key was pressed. <br>
&gt;83E0 Workspace used by KSCAN. <br>
&gt;000E Branch vector for the KSCAN routine</p>
<p>Now, how does KSCAN know that the key was pressed before? Well, it
just
stores a key scan code (not the standard ascii code) in a given
address.
In fact, there are three such addresses, one for each keyboard argument
0, 4 and 5. Another address is used to remember the current keyboard
argument,
to be used when KSCAN is called with &gt;00 in byte &gt;8374.</p>
<p>&gt;83C6 Contains the default keyboard argument minus 3 (i.e. 0-2).
<br>
&gt;83C7 Contains keyboard column 0 (special keys). <br>
&gt;83C8 Scan code of current key, whatever keyboard type.<br>
&gt;83C9 Ditto for keyboard type 4 (Pascal). <br>
&gt;83CA Ditto for keyboard type 5 (Standard).</p>
<p>So, by clearing the relevant byte, we ensure that KSCAN always
returns
with the &gt;20 bit set in &gt;837C, even if the same key was held
down.
Of course, we must now include a delay loop to avoid the key being
repeated
at ultra-fast speed. In fact, we probably want two types of delay: how
long before the repeat operation begins and how long between each
repetition.
The second delay is typically much smaller that the first. </p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre>*--------------------------------------------<br>* Keyboard scanning with auto-repeat.<br>* Put even values in R0 and R1 either at assembly or at run time.<br>* Put an odd value in R0 to disable auto-repeat.<br>*--------------------------------------------<br>MYSCAN DATA WREGS1,MSK1<br> <br>MSK1   C    R2,R1             Are we repeating?<br>       JEQ  MSK2              Yes<br>       MOVB R4,@&gt;8374         Set keyboard argument<br>       MOV  R0,R2             Initially, use long delay<br> <br>MSK2   MOV  R2,R6             Reload delay<br>MSL1   SETO @&gt;83C8            Erase previous key's scan code<br>       MOVB @&gt;83C8,@&gt;83CA     Ditto for keyboard 5<br>       LWPI &gt;83E0<br>       BL   @&gt;000E            Call scanning routine<br>       LWPI WREGS1<br>       MOVB @&gt;8375,R11        Get key's ascii code<br>       CB   R11,R3            Same as before?<br>       JNE  NEWKEY            No<br>       DECT R6                Yes: wait. Never zero if odd delay<br>       JNE  MSL1              Keep scanning (as key could change)<br>       MOV  R1,R2             Done with waiting: load repeat delay<br>       JMP  USEKEY            Do first repetition<br> <br>NEWKEY MOVB @&gt;8375,R3         Memorize current key (will be &gt;FF if no key)<br>       MOV  R0,R2             Load initial delay<br>USEKEY MOVB R3,*R13           Pass key to caller, in R0<br>       MOVB @&gt;837C,11         Signal key pressed, if any<br>       ANDI 11,&gt;2000          Keep only "key pressed" flag<br>       SOCB 11,15             Transfer it into Eq bit of caller<br>       RTWP                   Return to caller<br>*<br>WREGS1 DATA &gt;0080             R0: Time before auto-repeat kicks in<br>       DATA &gt;0020             R1: Delay between repeats<br>       DATA &gt;0080             R2: Current delay<br>       DATA &gt;FF00             R3: Key buffer<br>       DATA &gt;0500             R4: Keyboard argument<br>       BSS  24                R4-R15</pre>
      </td>
    </tr>
  </tbody>
</table>
<h3><br>
<a name="int driven"></a>An interrupt-driven keyboard?</h3>
<p>Given the way the keyboard is wired, it is not possible to set it in
such a way that pressing any key would generate an interrupt. On the
other
hand, it is possible to set it so that a subset of keys (a column)
trigger
an interrupt when pressed. This provides us with an alternative to the
quick-scan routines described above.</p>
<p>For a description of this feature, check the page dealing with the <a
 href="tms9901.htm#Fun">TMS9901</a>.</p>
<address>Revision 1. 2/13/99 OK to release</address>
<address>Revision 2. 3/31/99 Polishing<br>
Revision 3. 5/30/99 Tested &amp; debugged examples</address>
<center>
<p><br>
<a href="titechpages.htm">Back to the TI-99/4A Tech Pages</a></p>
</center>
</body>
</html>
