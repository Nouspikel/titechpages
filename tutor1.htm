<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
  <title></title>
  <meta name="Author" content="">
  <meta name="GENERATOR"
 content="Mozilla/3.04Gold (Win95; U) [Netscape]">
</head>
<body>
<h1 align="center"><a
 href="http://www.nouspikel.com/ti99/titechpages.htm"><img
 src="logo.jpg" style="border: 0px solid ; height: 33px; width: 95px;"
 title="Back to main index" alt=""></a></h1>
<h1>Keyboard challenge and tutorial</h1>
<p>The following was posted on the online user group <a
 href="http://groups.yahoo.com/group/swpb">http://groups.yahoo.com/groups/swpb</a>
in the form of a challenge for assembly programmers: 10 tasks to
achieve,
all dealing with the keyboard.</p>
<p><b>Beginner level:<br>
</b>1) Scan the keyboard with the KSCAN routine. Exit the program if a
key is pressed.<br>
2) Ditto, but only exit if this key is the spacebar.</p>
<p><b>Intermediary level<br>
</b>3) Ditto, but do not use KSCAN.<br>
4) Ditto but detect the &lt;enter&gt; key. Make sure it also works if
&lt;enter&gt;
was held down since the last time it was detected.<br>
5) Detect the &lt;clear&gt; key (fctn-4) using a routine faster than
KSCAN.</p>
<p><b>Advanced level<br>
</b>6) Assume the console ROM is unavailable. Detect the spacebar by
accessing
the keyboard directly.<br>
7) Ditto, but react if any key is pressed, not just the spacebar.<br>
8) Also check the joystick fire buttons<br>
9) Also check the alpha-lock key.</p>
<p><b>Expert challenge<br>
</b>10) Disable VDP interrupts and peripheral interrupts. Then enter a
forever loop: <tt>HERE JMP HERE</tt> Now exit the loop when the
spacebar
is pressed.</p>
<p><br>
When I posted the answers, I interspersed them with a lot of comments
and
explanations, which together make a small tutorial on how to access the
keyboard. This tutorial is reproduced below.</p>
<p>If you have some notions of assembly, I encourage you to try your
hand
at the above challenge. The tasks are arranged in increasing order of
difficulty.
Try and see which ones you can solve without having to look up the
answers.</p>
<p>If you don't know much assembly, read on: I'm introducing several
basic
instructions and subroutines. If you feel lost, have a look at my <a
 href="assembly.htm">assembly
primer</a>.</p>
<p>Solutions <a href="#A1">1</a> <a href="#A2">2</a> <a href="#A3">3</a>
<a href="#A4">4</a> <a href="#A5">5</a> <a href="#A6">6</a> <a
 href="#A7">7</a>
<a href="#A8">8</a> <a href="#A9">9</a> <a href="#A10">10</a></p>
<p><b>Tutorials<br>
</b><a href="#KSCAN">The KSCAN routine<br>
</a><a href="#Bit%20test">Testing bits<br>
</a><a href="#Bit%20shift">Bit shifts<br>
</a><a href="#ANDI">The ANDI instruction<br>
</a><a href="#ORI">The ORI instruction<br>
</a><a href="#Bit%20compare">Bitwise comparisons<br>
</a><b><a href="#Test1">Self-test #1</a></b></p>
<p><a href="#Branch%20tables">Branch tables<br>
</a><a href="#Change%20WS">Changing workspace</a></p>
<p><a href="#CRU">What is the CRU?<br>
</a><a href="#CRU%20addresses">CRU addresses<br>
</a><a href="#CRU%20keyboard">Decoding the keyboard<br>
</a><b><a href="#test2">Self-test #2</a></b></p>
<p>
</p>
<hr width="100%">
<p></p>
<h3><a name="A1"></a>1. Scan the keyboard with the KSCAN routine. Exit
the program if a key is pressed</h3>
<p>One possible answer:</p>
<pre>       LI   R0,&gt;0500       Keyboard argument<br>       MOVB R0,@&gt;8374      Place it where needed<br>NOKEY  BLWP @<a
 href="#KSCAN">KSCAN</a>         Call keyboard scanning routine<br>       MOVB @&gt;837C,R0      Get GPL status byte<br>       <a
 href="#Bit%20shift">SLA</a>  R0,3           <a href="#Bit%20test">Test the Cnd bit</a> (&gt;20)<br>       JNC  NOKEY          No key pressed or same key held<br>       B    *R11           Return to caller if a key was pressed</pre>
<p><br>
Here are two other ways to test the Cnd bit:</p>
<pre>       MOVB @&gt;837C,R0      Get GPL status byte<br>       <a
 href="#ANDI">ANDI</a> R0,&gt;2000       Keep only Cnd bit   <br>       JEQ  NOKEY          It was 0<br>or<br>       MOVB @&gt;837C,R0      Get GPL status byte<br>       <a
 href="#Bit%20compare">COC</a>  @H2000,R0      where H2000 is: DATA &gt;2000<br>       JNE  NOKEY          Cnd bit was not set<br></pre>
<h3><a name="A2"></a>2. Ditto, but only exit if this key is the spacebar</h3>
<p>Building on the above code (only new code is commented)</p>
<pre>       LI   R0,&gt;0500       <br>       MOVB R0,@&gt;8374      <br>NOKEY  BLWP @KSCAN         <br>       MOVB @&gt;837C,R0      <br>       SLA  R0,3           <br>       JNC  NOKEY          <br>       CB   @&gt;8375,@H2000  Ascii code 32? (&gt;20 in hex notation)<br>       JNE  NOKEY          No: try again<br>       B    *R11           <br>*<br>H2000  DATA &gt;2000<br><br>or<br>       MOVB @&gt;8375,R0      Transfer ascii code to a register<br>       CI   R0,&gt;2000       because CI only works on registers<br>       JNE  NOKEY          (NB We know R0 2nd byte is zero)<br></pre>
<h4><a name="KSCAN"></a>The KSCAN subroutine</h4>
<p>The KSCAN subroutine calls the keyboard scanning routine in the
console
ROMs. It should be entered with a BLWP. But before you call it, you
must
place the desired keyboard layout code in byte &gt;8374. The layout
codes
are the same than in Basic, with &gt;00 meaning "same as before".
Note that KSCAN will place &gt;00 in &gt;8374 upon return.</p>
<p>If a new key was pressed, the Cnd bit (value &gt;20) will be set in
the GPL status byte at &gt;837C. It will not be set if the same key was
held down since last time KSCAN was called.</p>
<p>Byte &gt;8375 will contain the ascii code for the key that's down,
according
to the keyboard layout you selected. This code is valid whether the key
was freshly pressed or held down. If no key is down, &gt;8375 contains
&gt;FF.</p>
<p>KSCAN can also be used to test the joysticks, by specifying keyboard
layout 1 or 2. Byte &gt;8376 contains the vertical deflection: either
&gt;00
or &gt;04 or &gt;FC (which corresponds to -4). Byte &gt;8377 contains
the
horizontal deflection. The fire buttons are reported in &gt;8375, as if
they were keys.</p>
<p>Note that, if you do not test byte &gt;837C in the second example,
you
will exit the program even if the spacebar was pressed and held since
the
last time the keyboard was scanned:</p>
<pre>       LI   R0,&gt;0500       <br>       MOVB R0,@&gt;8374      <br>NOSPAC BLWP @KSCAN         <br>       CB   @&gt;8375,@H2000  Check if ascii code is 32<br>       JNE  NOSPAC         If not, try again<br>       B    *R11           </pre>
<h4><br>
<a name="Bit test"></a>Testing a bit</h4>
<p>There are several ways to test the Cnd bit. All involve making a
copy
of the GPL status byte &gt;837C, so as not to disturb it. In the above
example, I'm using a shift instruction to transfer the bit I want into
the "carry" flag.</p>
<p>Shift instructions moves the bits to the left or to the right,
inside
a given register. They are not available for general memory addresses,
only for registers.</p>
<p>Assume R0 contains &gt;2541, which corresponds to the following
bits:
</p>
<pre>  8421 8421 8421 8421     Bit values<br>  0010 0101 0100 0001     R0 in binary notation: &gt;2541</pre>
<p>Here is how we could rotate it:</p>
<pre><font color="#0000ff">c</font> 8421 8421 8421 8421 <br><font
 color="#0000ff">0</font> 0100 1010 1000 0010     SLA R0,1<br>                    <font
 color="#ff0000">&lt;</font>   <br><font color="#0000ff">c</font> 8421 8421 8421 8421<br><font
 color="#0000ff">0</font> 1001 0101 0000 0100     SLA R0,2<br>                   <font
 color="#ff0000">&lt;-<br></font><font color="#0000ff">c</font> 8421 8421 8421 8421<br><font
 color="#0000ff">1</font> 0010 1010 0000 1000     SLA R0,3<br>                  <font
 color="#ff0000">&lt;--<br></font>etc, upto<br><font color="#0000ff">c</font> 8421 8421 8421 8421<br><font
 color="#0000ff">0</font> 1000 0000 0000 0000     SLA R0,15<br>   <font
 color="#ff0000">&lt;-----------------</font></pre>
<p>As you see, this instruction moves bits leftwards by the specified
number
of steps, filling the right with 0 bits. </p>
<p>The LAST bit that was shifted out from the left ends up in the
"carry"
bit of the microprocessor status register (marked '<font color="#0000ff">c</font>'
above). Which means that it can be tested with the following
instructions:
</p>
<pre>       JOC  KEY       jump if the bit was 1 (Jump On Carry)<br>       JNC  NOKEY     jump if the bit was 0 (Jump if No Carry)</pre>
<h4><br>
<a name="Bit shift"></a>Bit shifting instructions</h4>
<p>There are four shifting instructions: SLA, SRL, SRA and SRC. We just
saw that SLA fills the register with '0' bits on the right, but when
shifting
to the right you have the choice to fill the left with zeros of with
copies
of the first bit. The latter preserves the sign of the word (the
leftmost
bit is the sign bit for arithmetic values).</p>
<p><b>SLA</b> shifts bits to the left, filling the right with zeros
(Shift
Left Arithmetic). <br>
<b>SRL</b> shifts bits to the right, filling the left with zeros (Shift
Right Logical). <br>
<b>SRA</b> shifts bits to the right, filling the left with copies of
the
sign bit (Shift Right Arithmetic).<br>
<b>SRC </b>shifts bits to the right, feeding them back to the left
(Shift
Right Circular).</p>
<p>There is no SLL because the sign bit is on the left and will be
shifted
out anyhow. So SLL would be the same as SLA.</p>
<p>There is no SLC, because all possible circular shifts can be
achieved
with SRC. For instance SRC R1,15 is the same as SLC R1,1 since
registers
have16 bits. </p>
<p>One last trick. What if you were to write: </p>
<pre>       SRL R1,0</pre>
<p>A shift by 0 positions is obviously meaningless. By convention, the
above means: "get the number of positions from R0". So if R0
contains 5, this will be the same as <tt>SRL R1,5</tt> </p>
<p>Now what if R0 contains 0? It is understood as "shift by 16".
</p>
<p>Finally any value greater than 15 is just rounded up to a number
between
0 and 15. For instance <tt>SRC R5,0</tt> with R0 containing 17 is the
same
as if R0 contained 1, i.e. the same as <tt>SRC R5,1</tt></p>
<h4><br>
<a name="ANDI"></a>The ANDI instruction</h4>
<p>There are other ways to test bits: </p>
<pre>      ANDI R0,&gt;2000<br>      JEQ  NOKEY</pre>
<p>Here I'm using the ANDI instruction, which performs a bitwise
logical
<b>AND</b> between R0 and the <b>I</b>mmediate argument &gt;2000 (it's
called immediate, because the value &gt;2000 immediately follows the
instruction
in memory). The result of an AND operation is 1 only if both operands
were
1: </p>
<pre>0 AND 0 = 0<br>0 AND 1 = 0<br>1 AND 0 = 0<br>1 AND 1 = 1</pre>
<p>So, if R0 contains &gt;2541 as above, "ANDing" it with &gt;2000
will result in: </p>
<pre>  00<font color="#ff0000">1</font>0 0101 0100 0001     This is R0: &gt;2541<br>  00<font
 color="#ff0000">1</font>0 0000 0000 0000     This is &gt;2000<br>  -------------------      <br>  00<font
 color="#ff0000">1</font>0 0000 0000 0000     This is R0 AND &gt;2000</pre>
<p>all other bits were wipped out by the ANDI instruction. </p>
<p>Like many assembly instructions, ANDI automatically compares its
result
to zero and sets the corresponding bits in the microprocessor status
register.
Which means that we can test for zero with a simple JEQ (<b>J</b>ump if
<b>EQ</b>ual zero) or JNE (<b>J</b>ump if <b>N</b>ot <b>E</b>qual
zero)
without the need for a special comparison instruction.</p>
<p>Note that ANDI can test for more than one bit: </p>
<pre>       ANDI R0,&gt;2040<br>       JEQ  THERE</pre>
<p>The jump will only be taken if both bit &gt;2000 and bit &gt;0040
are
zero in R0.</p>
<h4><br>
<a name="ORI"></a>The ORI instruction </h4>
<p>An instruction similar to ANDI is ORI. It performs a bitwise <b>OR</b>
between a register and an <b>I</b>mmediate value. The result of an OR
is
1 if either one of the operands was 1: <br>
</p>
<pre>0 OR 0 = 0<br>0 OR 1 = 1<br>1 OR 0 = 1<br>1 OR 1 = 1<br><br>So if R0 contains &gt;2541, ORI R0,&gt;2212 will result in:</pre>
<pre>  00<font color="#ff0000">1</font>0 0<font color="#ff0000">1</font>0<font
 color="#ff0000">1</font> 0<font color="#ff0000">1</font>00 000<font
 color="#ff0000">1</font>     This is R0: &gt;2541<br>  00<font
 color="#ff0000">1</font>0 00<font color="#ff0000">1</font>0 000<font
 color="#ff0000">1</font> 0010     This is &gt;2212<br>  -------------------     <br>  00<font
 color="#ff0000">1</font>0 0<font color="#ff0000">111</font> 0<font
 color="#ff0000">1</font>0<font color="#ff0000">1</font> 00<font
 color="#ff0000">11</font>     This is the result: &gt;2753</pre>
<p>Note that this is NOT the same as an addition, because bit &gt;20 is
set in both operands. An addition would thus cause a carry to bit
&gt;40
and the result would be &gt;4753. Logical instructions like AND and OR
are purely bitwise and do not carry to the next bit.</p>
<h4><br>
<a name="Bit compare"></a>Bitwise comparisons </h4>
<p>Yet another way to test bits is: </p>
<pre>       COC  @H2000,R0<br>       JEQ  NOKEY </pre>
<p>Where H2000 is defined elsewhere in your program as</p>
<pre>H2000  DATA &gt;2000</pre>
<p>COC stands for <b>C</b>ompare <b>O</b>nes <b>C</b>orresponding.
It tests
some bits in a register, according a mask specified in the first
argument.
Note that the second argument (the testee) must be a register, while
the
other (the mask) can be either a register or a general memory addres</p>
<p>Here we are saying: "test those bits in R0 that are 1 in H2000.
See if they are all one". If all these bits are '1', the equal flag
will be set, so we can test the result with JEQ or JNE. </p>
<pre>       LI   R1,&gt;1204    Our mask<br>       COC  R1,R0       Assume R0 contains &gt;3695<br>       JEQ  THERE <br><br> 000<font
 color="#ff0000">1</font> 00<font color="#ff0000">1</font>0 0000 0<font
 color="#ff0000">1</font>00    This is R1. It specifies the bits to test.<br> 0011 0110 1001 0101    This is R0 (&gt;3695)<br>    ^   ^        ^      Bits tested: all are '1' so the JEQ will be taken.</pre>
<p>There is also a CZC instruction: <b>C</b>ompare <b>Z</b>eros <b>C</b>orresponding.
It tests bits just like COC, except that now it checks whether all the
specified bits are zero. </p>
<pre>       LI   R1,&gt;4130    Our mask<br>       CZC  R1,R0       Assume R0 contains &gt;3695<br>       JEQ  THERE <br><br> 0<font
 color="#ff0000">1</font>00 000<font color="#ff0000">1</font> 00<font
 color="#ff0000">11</font> 0000    This is R1. It now contains &gt;4130<br> 0011 0110 1001 0101    This is R0 (still &gt;3695)<br>  ^      ^   ^<font
 color="#ff0000">^</font>         Bits tested: one of them is not '0'<br>Cause of <font
 color="#ff0000">this-'</font> bit, the JEQ is not taken.</pre>
<p>In the keyboard example, I used a shift instruction because it takes
less space in memory than the other two solutions: one word versus two.
On the other hand, it only tests one bit at a time, whereas ANDI and
COC
can be used to test several bits at once. When testing a single bit,
it's
a matter of programming style: you are free to use whichever solution
you
prefer.</p>
<h3><br>
<a name="Test1"></a>Self-test</h3>
<p>A few questions for you to make sure you understood the above:</p>
<pre>       LI  R1,&gt;0204<br>       SRC R1,5<br>What does R1 contain now?<br><br>       LI   R3,&gt;1356<br>       ANDI R3,&gt;F11F<br>       ORI  R3,&gt;8041<br>What does R3 contain now?<br><br>       LI   R1,&gt;0123<br>       LI   R2,&gt;0111<br>       COC  R2,R1<br>       JEQ  YES<br>Is the jump taken or not?<br><br>       LI   R1,&gt;0123<br>       LI   R2,&gt;1818<br>       CZC  R2,R1<br>       JEQ  YES<br>What about here?</pre>
<p>I'm not giving you the answers: just assemble the above and see if
the
results match your predictions...</p>
<p>
</p>
<hr width="100%">
<p></p>
<h3><a name="A3"></a>3. Ditto, but do not use KSCAN</h3>
<p>Solution: call the keyboard scanning routine in the console ROMs
directly.
If you disassemble the KSCAN subroutine you will realize that it's
nothing
more than a thin wrapper around the keyboard scanning routine in the
console
ROMs: </p>
<pre>KSCAN  DATA KEYWR,KSC1             workspace and address for use by BLWP<br>*<br>KSC1   LWPI &gt;83E0                  <a
 href="#Change%20WS">use GPL workspace<br></a>       MOV  11,@SAVR11             save R11<br>       BL   @&gt;000E                 call keyboard scanning routine<br>       MOV  @SAVR11,R11            restore R11<br>       LWPI KEYWR                  back to our workspace <br>       RTWP                        return to caller<br>*<br>KEYWR  BSS  32                     somewhere: 32 bytes for our workspace</pre>
<p>So we could include such code directly in our program. A few notes
of
caution though.</p>
<li>We MUST change the workspace to &gt;83E0, the GPL workspace,
because
of the way the scanning routine was written.<br>
</li>
<li>This is annoying because R11 currently contains the return address
for the GPL opcode XML that called your program. If you intend to
return
to the cartridge, you must preserve R11. If you intend to exit with <tt>BLWP
@&gt;0000</tt>, i.e. to reset the TI-99/4A, then you don't care too
much
about GPL's R11. </li>
<h4><br>
<a name="Branch tables"></a>Branch tables</h4>
<p>If you look up address &gt;000E you will see that it contains a
branch
to the actual location of the keyboard scanning routine, at &gt;02B2.
You
may be tempted to do a <tt>BL @&gt;02B2</tt> directly. Don't. It's
always
possible that a different version of the ROMs would have the routine at
a different adddress and your program would crash. On the other hand,
&gt;000E
is guaranteed to be always correct.</p>
<p>This method of implementing branch tables for routines called with
BL
is very good programming practice and should be followed each time you
create routines meant to be called by other programs. For routines
called
with BLWP it's even simpler: just place the two vectors inside the
table.</p>
<pre>THIS  B    @THIS1          For routines called with BL<br>THAT  DATA MYWR,THAT1      For routines called with BLWP<br>*<br>THIS1 ...<br>      B    *R11<br>*<br>THAT1 ...<br>      RTWP</pre>
<h4><br>
<a name="Change WS"></a>Changing the workspace</h4>
<p>So why do we need to change the workspace to &gt;83E0 before we call
&gt;000E? Because the TI programmers fell to a very common temptation
and
called their registers as addresses. See, suppose you want to transfer
only one byte in R0: </p>
<pre>       MOVB R1,R0          </pre>
<p>This moves the byte into R0's Most Significant Byte (MSB). </p>
<p>But now suppose you want to move it into the least signigifant byte
(LSB) of R0. If you know that your workspace it at &gt;83E0, you could
write: </p>
<pre>      LWPI &gt;83E0           let's use this workspace<br>      MOVB R1,@&gt;83E1       since &gt;83E1 is the second byte of R0</pre>
<p>Similarly, you would use &gt;83E3 for R1's LSB, &gt;83E5 for R2's
LSB,
etc.</p>
<p>But this means that, if you change your workspace, your code will be
all wrong! To some extent you can correct for this by using a label: </p>
<pre>MYWR  EQU  &gt;83E0<br>*<br>      LWPI MYWR<br>      MOVB R1,@MYWR+1</pre>
<p>Then all you have to do to change your workspace is to modify the
EQUate
and re-assemble your program. </p>
<p>BUT... the code will only run properly with this workspace. By
contrast,
if you do: </p>
<pre>       MOVB R1,R0           move into R0's MSB<br>       SRL  R0,8            transfer to LSB</pre>
<p>you achieved the same thing, and the code will run properly with any
workspace!</p>
<p>Ah, but we lost R0's MSB in the process... If you wanted to preserve
it, you could do something like: </p>
<pre>       SWPB R0             swap MSB and LSB<br>       MOVB R1,R0          move into R0'MSB<br>       SWPB R0             swap again</pre>
<p>Now we have modified R0's LSB while leaving the MSB intact. Only, it
took us three instructions instead of one, and three words of memory
instead
of two. So our code will be bulkier and slower. </p>
<p>Yet this situation occurs rarely enough so that we can afford this
expense
and use only register-addressing so our routines can be called with any
workspace. But then again, it's a matter of taste and programming
style...</p>
<h3><br>
<a name="A4"></a>4. Ditto but detect the &lt;enter&gt; key</h3>
<p>The problem here is that your program was likely launched by
pressing
the &lt;enter&gt; key, so when it starts running, chances are that this
key is still down. So the Cnd bit in &gt;837C will not be set again,
unless
&lt;enter&gt; is released and pressed again. How could we detect if it
was held down?</p>
<p>We have touched on this earlier. The Cnd bit in &gt;837C is only set
if a new key is pressed, but the key code in &gt;8375 is updated even
if
the key was held down. So you could skip the test on &gt;837C and just
check &gt;8375: if it contains &gt;FF, no key is being pressed.</p>
<h4>Extra info</h4>
<p>How does this feature work? The keyboard scanning routines saves the
scancode (not the ascii value) for the last key that was pressed in
byte
&gt;83C8 and in &gt;83C9 or &gt;83CA for keyboard layout 1 and 2
respectively.
It also saves the keyboard layout code in &gt;83C6 and the last loop
number
in &gt;83C7. When a key is detected, it is compared with the saved
scancode.
The Cnd bit will only be set if the new code is different.</p>
<p>Take home lesson: do not use bytes &gt;83C6 through &gt;83CA for
your
data if you plan to call the keyboard scanning routine. </p>
<h3><br>
<a name="A5"></a>5. Detect the &lt;clear&gt; key (fctn-4) using a
routine
faster than KSCAN</h3>
<p>This could be done by calling the little-known routine at &gt;0020:
</p>
<pre>       BL  @&gt;0020        test &lt;clear&gt; key<br>       JEQ CLEAR         pressed<br>       JNE NOCLR         not pressed</pre>
<p>Again, &gt;0020 only contains a branch to the actual location of the
routine.</p>
<p>For this one, we can use any workspace as the routine does not
access
them by address. It only affects R12. If the &lt;clear&gt; key was
pressed,
the routine returns with the Equal flag set in the status register. So
we can use JEQ and JNE to react to it. </p>
<p>
</p>
<hr width="100%">
<p></p>
<p>The keyboard is accessed via the CRU. If you know what the CRU is,
you
may just jump ahead to the paragraph entitled 'Accessing the keyboard'.
If you know how the keyboard is laid out, you may <a href="#A6">jump
ahead</a>
to the answers section. Otherwise, keep reading...</p>
<h4><a name="CRU"></a>What is the CRU ?</h4>
<p>The Communication Register Unit (aka CRU) is used by the
microprocessor
to control hardware otherwise than through memory addresses. The CRU
can
be viewed as a bundle of 8192 wires: 4096 for input and 4096 for
output.
The TMS9900 microprocessor can set any output wire high (to about 5
volts)
or low (to about 0 volts). It can check whether any input wire is high
or low.</p>
<p>Of course, there aren't actually that many wires. In fact, there are
only three: one for input, one for output, and one to indicate output
operations.
The microcontroller places the number of the 'wire' it wants on the
memory
address bus and it's up to the peripheral hardware to check it. If the
peripheral sees the number of a wire it's suppose to react to, it will
input or output data using the two dedicated wires. But as far as
programming
is concerned, it's easier to consider the CRU as a bunch of wires.</p>
<p>To access a 'wire', you place its number in the register R12, for
the
microprocessor to put it on the address bus. There is a little problem
here: because the TMS9900 is a 16-bit microprocessor, all addresses are
even and there is no address line corresponding to bit &gt;0001.
Because
of this, the value in R12 should be shifted one position to the left,
i.e.
multiplied by two. In other words, the CRU address in R12 is TWICE the
number of the desired wire.</p>
<p>There are five assembly instruction that control the CRU, three
affect
only one wire, two affect groups of wires.</p>
<pre>       SBO  x      Set Bit to One, sets an output wire high <br>       SBZ  x      Set Bit to Zero, sets an output wire low</pre>
<pre>       TB   x      Test Bit, checks an input wire<br>       JEQ  HIGH   if the wire is high, the bit value is '1' and JEQ is taken<br>       JNE  LOW    if the line is low, the bit value is '0' and JNE is taken</pre>
<p>Where 'x' is the number of the wire, relative to the address in R12.
It can be any number between -128 and +127. This is a very nifty
feature
because it means that you can access many wires without having to
modify
R12 each time. For instance: </p>
<pre>        SBO  0        accesses the wire specified in R12<br>        SBO  1        accesses the next one, <br>        SBO  -1       accesses the previous one, etc.</pre>
<p>To manipulate several wires at a time, you can use: </p>
<pre>       LDCR  source,n   LoaD CRu, ouputs n bits from 'source' to the CRU<br>       STCR dest,n      STore CRu, inputs n bits from the CRU to 'dest'</pre>
<p>Where 'source' and 'dest' can be registers or memory addresses and
'n'
is the number of bits to be transfered.</p>
<p>An LDCR transfer begins with the least significant bit of 'source'
to
the wire specified in R12: if the bit is '1' the wire will be set high,
if it's '0' the wire will be set low. LDCR then uses the next bit on
the
left to control the next wire, and so on till 'n' bits have been
transfered.</p>
<p>Similarly, STCR checks wires via the CRU, starting with the wire
specified
in R12, and sets a bit in 'dest' to '1' if the wire is high and to '0'
if it is low. Again, the transfer starts with the least significant bit
and proceeds toward the left by testing successive wires.</p>
<p>There is one little subtility here: if n is 8 or less, the transfer
will only affect one byte. If n is more than 8, it affects one word.
(If
n is 0, it is understood at 16 and affects one word). So, for instance:
</p>
<pre>       LI   R1,&gt;0902<br>       LDCR  R1,8    transfers &gt;09  (8 bits, from the right of R1's MSB)<br>       LDCR  R1,12   transfers &gt;902 (12 bits, from the right of R1)</pre>
<h4><br>
<a name="CRU addresses"></a>CRU addresses</h4>
<p>The first 32 CRU addresses are reserved for the TMS9901 co-processor
in the console. This chip decodes the CRU address and converts it into
enough physical wires to control the keyboard, the cassettes, the
joysticks
and the interrupts.</p>
<p>N.B. Due to a design flaw, all CRU addresses from &gt;0000 to
&gt;0400
are actually answered by the TMS9901.</p>
<p>Addresses &gt;1000 and higher are meant for peripheral cards. The
convention
is that each card starts at a &gt;0100 boundary and uses upto 127 bits.
For instance: - the disk controller uses &gt;1100 trough &gt;1107 - the
RS232 card uses &gt;1300 through &gt;13BE - the second RS232 card uses
&gt;1500 through &gt;15BE - etc.</p>
<p>A further convention is that the first bit in each card (address
&gt;1x00)
turns on the card ROM and makes it appear at &gt;4000-5FFF. This is
used
by several console routines that search for DSRs, CALLs, etc.</p>
<p>Quite often, a peripheral will echo an output line to the
corresponding
input line, so you can read back what you wrote. But this is by no
means
an absolute rule: some CRU bits are write-only, others are read-only.</p>
<p>If you would like to learn more about the CRU, have a look at <a
 href="cru.htm">this
page</a>.</p>
<h4><br>
<a name="CRU keyboard"></a>Accessing the keyboard</h4>
<p>The keyboard is arranged as a matrix of 8 rows by 6 columns: </p>
<pre>    Col<u>umn: 0   1     2     3     4     5      </u>   <br><u> R12  </u>|<br>&gt;0006 |   =     .     ,     M     N     / <br>&gt;0008 | space   L     K     J     H     ; <br>&gt;000A | enter   O     I     U     Y     P <br>&gt;000C |         9     8     7     6     0 <br>&gt;000E | fctn    2     3     4     5     1   A-lock <br>&gt;0010 | shift   S     D     F     G     A <br>&gt;0012 | ctrl    W     E     R     T     Q <br>&gt;0014 |         X     C     V     B     Z</pre>
<p>Each key controls a switch that connects a row and a column. To
check
if a key is pressed, the microprocessor sends electrons into a given
column
and checks if they come out of any row. To test the whole keyboard, you
just scan all columns one by one.</p>
<p>The rows are directly connected to the input pins of the TMS9901 and
can threfore be tested as eight independent CRU bits.</p>
<p>The columns, on the other hand, are controlled by a 74LS151 decoder.
A decoder is a chip that converts a number into a bunch of lines. It
brings
low one line only, the others being held high: </p>
<pre>                         A B C | Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7<br>in +-------+ out         ------+------------------------<br>---|A    Y0|---          0 0 0 | <font
 color="#ff0000">0</font>  1  1  1  1  1  1  1<br>---|B    Y1|---          0 0 1 | 1  <font
 color="#ff0000">0</font>  1  1  1  1  1  1<br>---|C    Y2|---          0 1 0 | 1  1  <font
 color="#ff0000">0</font>  1  1  1  1  1<br>   |     Y3|---          0 1 1 | 1  1  1  <font
 color="#ff0000">0</font>  1  1  1  1<br>   |     Y4|---          1 0 0 | 1  1  1  1  <font
 color="#ff0000">0</font>  1  1  1<br>   |     Y5|---          1 0 1 | 1  1  1  1  1  <font
 color="#ff0000">0</font>  1  1<br>   |     Y6|---          1 1 0 | 1  1  1  1  1  1  <font
 color="#ff0000">0</font>  1<br>   |     Y7|---          1 1 1 | 1  1  1  1  1  1  1  <font
 color="#ff0000">0<br></font>   +-------+</pre>
<p>This allows the TMS9901 to control the six keyboard columns (plus
the
two joysticks) with only three lines. It is possible because only one
column
at a time is being tested.</p>
<p>Because of the nature of the decoder that brings columns low, when a
key is pressed the corresponding row wire will be low and the CRU bit
will
be '0'. If no key is pressed on that column, all rows will read as '1'
bits.</p>
<h3><br>
<a name="A6"></a>6. Detect the spacebar by accessing the keyboard
directly</h3>
<p>To check if the keyboard, you place a 3-bit column number at CRU
address
&gt;0024 and read 8 CRU bits at address &gt;0006. If any of these is
low,
the corresponding key was pressed.</p>
<pre>       LI   R1,&gt;0000    keyboard column 0<br>       LI   R12,&gt;0024   CRU address of the decoder<br>       LDCR R1,3        select the column<br>       LI   R12,&gt;0006   address of the first row<br>LOOP   STCR R2,8        read 8 rows<br>       ANDI R2,&gt;0200    test spacebar<br>       JNE  LOOP        not pressed</pre>
<p>Remember that bits are transfered from right to left, so '=' is bit
&gt;0100, 'space' is bit &gt;0200, 'enter' is bit &gt;0400, etc.</p>
<h3><br>
<a name="A7"></a>7. Ditto, but react if any key is pressed, not just
the
spacebar</h3>
<p>This just means that we have to test all six columns. It can easily
be done by bumping up the value in R1. We'll also need to test R2 for
any
bit set as '0'. </p>
<pre>LP2    LI   R1,&gt;0000    start with keyboard column 0<br>LP1    LI   R12,&gt;0024    <br>       LDCR R1,3         <br>       LI   R12,&gt;0006    <br>       STCR R2,8<br>       CI   R2,&gt;FF00    value if all bits are '1'<br>       JL   KEY         if a bit is '0' the value is lower than &gt;FF00<br>       AI   R1,&gt;0100    next column<br>       CI   R1,&gt;0500    did we do them all?<br>       JLE  LP1         not yet<br>       JMP  LP2         no key: restart from column 0<br><br>KEY    B    *R11        a key was pressed</pre>
<h3><br>
<a name="A8"></a>8. Also check the joystick fire buttons</h3>
<p>Joysticks are controlled by the decoder's output Y6 and Y7, so they
can be accessed as column 6 for joystick 1, and column 7 for joystick
2.
Their return wires are connected to the same lines than the first five
keyboard rows.</p>
<pre>   Colu<u>mn 6      7     <br> R12  </u>| <br>&gt;0006 | Fire    Fire<br>&gt;0008 | Left    Left<br>&gt;000A | Right   Right<br>&gt;000C | Down    Down<br>&gt;000E | Up      Up<br>&gt;0010 | <br>&gt;0012 | <br>&gt;0014 |         </pre>
<p>To test the joystick fire buttons, we could insert the following
code
after 'not yet': </p>
<pre>       JNE  LP1           not yet<br>       LI   R12,&gt;0024     address of the decoder<br>       LI   R1,&gt;0600      column 6 for joystick 1<br>       LDCR R1,&gt;0300      set it<br>       TB   -15           test bit at address &gt;0006<br>       JNE  KEY           bit is '0' = fire button pressed<br>       SBO  0             changes the 6 into a 7<br>       TB   -15           test fire button for second joystick<br>       JNE  KEY           pressed<br>       JMP  LP2</pre>
<p>In this example, I tried to show how to use TB to test single bits
without
having to change the value in R12. If you remember that R12 contains
the
wire number times two, you will see that &gt;0006 (i.e. 6, wire #3)
lies
15 bits before &gt;0024 (i.e. 36, wire #18).</p>
<p>Similarly, SBO 0 is used to modify the column number without having
to change R1 and to LDCR it again (6 is 110 in binary, and 7 is 111, so
we just have to set the least significant bit).</p>
<h3><br>
<a name="A9"></a>9. Also check the alpha-lock key</h3>
<p>The alpha-lock key is not controlled by the 74LS151 decoder. It has
its own 'column' wire controled by CRU bit &gt;002A. Its 'row' wire is
the same as the fifth keyboard row.</p>
<p>So to test that key:</p>
<pre>      LI    R12,&gt;002A    address of alpha-lock<br>      SBZ   0            send electrons to it <br>      LI    R12,&gt;000E    fifth keyboard row<br>      TB    0            read it<br>      SBO   0            finish alpha-lock test<br>      JNE   KEY          react to TB</pre>
<p>Note that SBO does not affect the status register, which is why we
can
postpone the JNE test and still have it react to the results of TB. The
alternative would be to have two <tt>SBO 0</tt>, one if the jump is
taken,
one if it's not taken.</p>
<h4><br>
Extra info</h4>
<p>The drag with the alpha-lock key is that it's connected to the same
row than the joysticks "up" return line. When the alpha-lock
key is down, and bit &gt;002A is high (i.e. when not testing the
alpha-lock
key) it sends enough current on the fifth row to mess up the joystick
return.
This could easily have been avoided, had TI picked the sixth row as a
return
line for the alpha-lock key! </p>
<h3><br>
<a name="test2"></a>Self-test</h3>
<pre>      CLR R12<br>      SB0 18<br>      SBZ 19<br>      SBZ 20<br>      TB  3<br>      JNE OK<br>What am I testing for, here?<br><br>      LI   R12,&gt;1100<br>      SBO  0<br>What did I just do?</pre>
<p>NB Don't forget to do SBZ 0 before you exit the latter program!</p>
<p>
</p>
<hr width="100%">
<p></p>
<h3><a name="A10"></a>10. Expert challenge</h3>
<p>You wish! This one you'll have to answer by yourself. But here's a
couple
of hints:</p>
<li>Yes, it's done via interrupts, although not VDP interrupts.</li>
<li>An almost complete answer is hidden somewhere in the TI-99/4A Tech
Pages...<br>
  <br>
</li>
<address>Revision 1. 8/19/02. Ok to release.</address>
<center>
<p><br>
<a href="titechpages.htm">Back to the TI-99/4A Tech Pages</a></p>
</center>
<p><br>
</p>
</body>
</html>
