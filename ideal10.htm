<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
  <title></title>
  <meta name="Author" content="">
  <meta name="GENERATOR"
 content="Mozilla/3.04Gold (Win95; U) [Netscape]">
</head>
<body>
<h1 align="center"><a
 href="http://www.nouspikel.com/ti99/titechpages.htm"><img
 src="logo.jpg" style="border: 0px solid ; height: 33px; width: 95px;"
 title="" alt=""></a></h1>
<h1>IDEAL 1.0</h1>
Click <a href="ideal.htm">here</a> for a more recent version.<br>
<br>
<h3>Introduction</h3>
<p>The <a href="ide.htm">IDE card</a> operating system loaded inside
the
SRAM is called IDEAL for "IDE Access Layer". It contains all
the routines that let you access the IDE drives, the clock, the card
SRAM
and even configure IDEAL itself.</p>
<p>Version 1.0 turns your hard disk into a huge collection of "virtual
floppies" that can either be accessed by name, or by "inserting"
them into 8 virtual drives. It is fully compatible with the TI floppy
disk
format, and therefore has the same limitations: only 1440 sectors and
127
files per disk, at most 76 clusters per file, 256 byte per sector, etc.
I'm planning a new version that will not suffer from these limitations
and will co-exist with the TI-compatible one, but this will take time...</p>
<p>You'll find some improvements on the TI format though. First of all,
I integrated most of the new features introduced in the Horizon Ramdisk
operating system (a good part of my code is shamelessly lifted from ROS
8.14 and from the TI-controller card ROMs, but why re-invent the
wheel?).
Thus, you'll find extra opcodes to delete a record, to load an
assembly,
Basic or cartridge file, an autostart feature, and the possibility to
place
a file data buffer in CPU memory instead of VDP memory.</p>
<p>IDEAL lets you create directories and subdirectories. In fact, a
directory
is nothing more than an empty file that points to another virtual
floppy.
This lets you organise your virtual floppies in a hierarchical manner,
while remaining compatible with a floppy disk controller (although of
course,
directories won't be more than empty files if you copy them to a real
floppy).</p>
<p>IDEAL provides you with the possibility to encrypt a file, or a
whole
virtual floppy, using the Blowfish algorithm. You also have a direct
access
to the encryption engine, so you can encrypt your own data.</p>
<p>Optionally, IDEAL will time-stamp each file and/or disk with a
creation
date and a date of last modification. You can also access the clock
directly
to set the time or an alarm, and to retrieve the current date and time,
either as numbers or as pre-formatted text strings.</p>
<p>The standard catalog function works just as with the TI floppy
controller,
but an extended catalog is also provided that returns extra information
on the files (such as the time stamps) and lets you perform some file
management
functions. It also lets you edit a floppy sector-wise from Basic.</p>
<p>Finally, IDEAL has the capability of configuring itself, so you can
tailor it to your needs and preferences.</p>
<p><a href="#Loading%20IDEAL">Getting started<br>
</a><a href="#Overview">Overview<br>
</a><a href="#Subdirectories">Subdirectories<br>
</a><a href="#Encryption">Encryption<br>
</a><a href="#Catalog">Extended catalog<br>
</a><a href="#Sector%20access">Sector-wise access<br>
</a><a href="#Collection">Editing the floppy collection<br>
</a><a href="#clock">Accessing the clock<br>
</a><a href="#Configuration">System configuration<br>
</a><a href="#Drive%20ID">Drive configuration<br>
</a><a href="#hard-drive%20access">Direct hard-drive access</a></p>
<p><a href="#DSRs">DSRs<br>
Subprograms<br>
</a><a href="#New%20format">Modifications to the TI format</a></p>
<h2><a name="Loading IDEAL"></a>Getting started</h2>
<p>This section discusses how to instal IDEAL in your IDE card and how
to configure it for the first time. When reading this document for the
first time you can just jump ahead to the <a href="#Overview">Overview</a>
chapter.</p>
<p>Installing IDEAL involves the following steps</p>
<ol>
  <li>Download the program: <a href="ideal.zip">IDEAL.ZIP</a> (~45 kB)
and
expand it on your PC.</li>
  <li>Follow the instructcions in the README.TXT file to transfer the
disk
file to your TI-99/4A.</li>
  <li>Load IDEAL into the SRAM. Optionally load a bootstrap into the
clock
RAM.</li>
  <li>Set the proper time and date (assuming there is a clock on the
card).</li>
  <li>Copy the IDEAL files to your hard-drive, for the bootstrap to
load
them at power-up time.</li>
  <li>Enter TI-Basic and run <tt>NEWCFG </tt>(after <tt>CALL&nbsp;FILES(1)</tt>
) to configure the system as you wish.</li>
</ol>
<h4>Files to be found in the ".dsk" file</h4>
<pre><u>File                Type       Usage                        <br></u>IDEAL/A ... IDEAL/M Program    IDEAL operating system to be loaded into the SRAM<br>IDEAL/Z             Program    Bootstrap (resides in clock RAM)<br>IDELOAD             Program    System loader (loads IDEAL + boostrap + config)<br>IDE-LD2/O           DF80       Patch for the above, for non-standard cards<br>IDE-LD2/S           DV80       Source for the patch<br>IDEAL/GK            Program    German 128K Gram-Karte access routine<br>IDEAL/PG            Program    P-Gram+ card access routine<br>IDE_GC/S            DV80       Demo: sources for IDEAL/GK and IDEAL/PG<br>NEWCFG              TI-Basic   Configures IDEAL (Do CALL FILES(1) before OLD)<br>SETIME              TI-Basic   Sets the time and date<br>NOLOAD              Program    Placeholder file for Mini-IDEAL</pre>
<pre>CONFIG              TI-Basic   Demo: Reads the system configuration<br>FLOP                TI-Basic   Demo: Embryonic virtual-floppy manager<br>TRASH               TI-Basic   Demo: Recovers deleted floppies<br>CAT                 TI-Basic   Demo: Extended disk catalog<br>BLOW                TI-Basic   Demo: Direct access to the encryption engine<br>CLOCK               TI-Basic   Demo: Access the real-time-clock DSR<br>SECTORS             TI-Basic   Demo: Direct access to hard-drive sectors<br>VAR2FIX             TI-Basic   Copy a DV80 file into a DF80 (for IDE-LD2/O)</pre>
<p>NB Don't try to run the <tt>IDEAL/x</tt> files with an EA5 loader:
they
must be loaded into the card SRAM and only <tt>IDELOAD</tt> knows how
to
do this properly.</p>
<p><b>Installing the IDE card</b></p>
<p>First pick up a CRU address for the card. There should not be any
other
card with this CRU in your system. A convenient CRU to use is &gt;1000,
so that the IDE card will be scanned before the floppy disk controller
(whose CRU is &gt;1100). If you don't know what CRU addresses are
available
in your system, you can load my <a href="download.htm#modexp">Module
Explorer</a>
program, press Ctrl-7, then Fctn-3 to enter the Header analyser. The
arrow
keys let you travel among the installed cards and their subprograms,
DSRs,
etc. </p>
<p>Once you decided on the CRU address, compose it on the DIP-switch
that's
on the card: all switches closed for &gt;1000, all open for &gt;1F00,
i.e.
you are writing the binary value for the second digit in the CRU
address.</p>
<p>The fifth DIP-switch lets you decide whether the clock RAM or the
SRAM
should appear at &gt;4000 when the power is first turned on. If you
have
a battery-backed SRAM open the switch, otherwise close it and load the
bootstrap into the clock.</p>
<p>Make sure the main switch is off, so any garbage in the SRAM (or
clock
RAM) won't prevent the system from booting.</p>
<p>Connect your hard drive(s) to the card via a standard IDE cable.
Then
carefully insert the card in the PE-box. </p>
<p>Power-up the system: first the PE-box (and hard-drive), then the
console.
If your drive takes a few seconds to spin up, it's a good practice to
wait
till it's ready before you turn the console on. Now flip the main
switch
on the card, so that it becomes active.</p>
<h4>Loading IDEAL into the SRAM</h4>
<p>The first thing to do is to load the system into the SRAM so you can
access the hard disk. You can also load a bootstrap into the clock RAM.</p>
<p>N.B. If you have a Gram device, you may want to first replace the
file
<tt>IDEAL/G</tt> with the one corresponding to your Gram card: just
rename
<tt>IDEAL/GK</tt> for the german 128K Gram Karte, or <tt>IDEAL/PG</tt>
for the PGram card. The original <tt>IDEAL/G</tt> file contains both
routines,
but calls the one for the Gram Karte. If you have a different Gram
device,
you will need to write a custom routine if you want IDEAL to handle it
(which is optional anyhow). See <a href="#Gcard%20routine">below</a>
for
a description of the required routine.</p>
<p>Now load the program <tt>IDELOAD</tt> using Editor/Assembler option
5, or with a similar loader (such as Funnelweb). The program first
prompts
you for the CRU of your IDE card. Enter the value that you set with the
DIP-switch on the card. Provided the card is found and the hard-drives
answers properly, <tt>IDELOAD</tt> will ask whether you want to load
IDEAL,
the bootstrap and/or the configuration. Finally, you must enter the
number
of the drive where the files are to be found (normally, this will be <tt>DSK1</tt>).
At any time, you can press &lt;back&gt; to go back to the previous
step.
Loading begins after you entered the drive number.</p>
<p>If you elected to load the configuration, or if you loaded IDEAL, <tt>IDELOAD&nbsp;</tt>will
check the clock memory for valid configuration data, and ask you
whether
you want to keep it. If you decline, or if none was found, the program
checks a reserved area on the hard drive, where a backup of then
configuration
is kept. If a valid configuration is found there, you again have the
choice
to use it or not. If you don't, or if none was found, the programs asks
you if you want to load the configuration from the file <tt>IDEAL/M</tt>.
The latter option is not offered if you have just loaded IDEAL, since
in
this case the configuration has already been loaded from file.</p>
<p>The bootstrap is the file <tt>IDEAL/Z</tt>. It's a small program
that
resides into the clock memory and loads IDEAL from your hard drive when
you power-up your system. Of course, this implies that you have copied
(or intend to copy) IDEAL on your hard-drive. </p>
<p>Once loading is completed you have the option to leave the bootstrap
in control. This means that the next time you hit &lt;quit&gt;, the
bootstrap
will attempt to load IDEAL from the hard drive. Obviously, you should
only
select this option if you have already copied IDEAL on the hard drive
(i.e.
if you are reinstalling the system). Answer by Y or N, or press
&lt;back&gt;
to return to the drive number prompt. </p>
<p><u>Technical note</u></p>
<p>If you made changes to my schematics and are using different CRU
bits,
you will need to patch <tt>IDELOAD </tt>so that it modifies the
system
accordingly. See <a href="#non-standard">below</a> for details.</p>
<h4>Setting the time and date</h4>
<p>At this point, you may want to open the <tt>CLOCK </tt>DSR and set
up
the correct time and date. Refer to the clock section <a href="#clock">below</a>.</p>
<p>Alternatively, you can run the TI-Basic program <tt>SETIME </tt>that
will walk you through the process.</p>
<h4>Copying IDEAL on the hard disk</h4>
<p>If you are installing IDEAL for the first time, it's a good idea to
make a copy of it on the hard drive. This will make possible for the
bootstrap
to automatically load IDEAL when the system powers up. It is not
required
if you have a battery-backed SRAM, but it won't hurt to do it anyhow.</p>
<p>Create a new virtual floppy either with a disk manager "format"
command or by using the <tt>IDE.FLOPPIES</tt> pseudo-file:</p>
<pre>OPEN #1:"IDE.FLOPPIES", INTERNAL, VARIABLE 80, APPEND<br>PRINT&nbsp;#1:"IDEAL",720<br>CLOSE #1<br>CALL CD.5..IDEAL</pre>
<p>N.B. The <tt>CALL </tt>loads the virtual floppy into a virtual
drive
called <tt>DSK5</tt> (by default IDEAL comes with drives DSK4, 5, 6,
7,
8, 9, A and B installed).</p>
<p>Now use a disk manager to copy all the system files <tt>IDEAL/A </tt>through
<tt>IDEAL/M</tt> to <tt>DSK5</tt>.</p>
<p>IDEAL will be automatically reloaded in the following circumstances:</p>
<li>If DIP-switch 5 is in the "clock" position and a valid copy
of IDEAL is not present in the SRAM when you power-up the TI-99/4A, the
bootstrap will load IDEAL from the hard drive.</li>
<li>When you reset the TI-99/4A, IDEAL checks itself for integrity (so
as not to slow down the reset, only a small part of page 0 is tested).
If any corruption is detected, the boostrap is called and IDEAL is
reloaded
from disk. If no boostrap is present in the clock memory, IDEAL makes
itself
invisible to the system by clearing word &gt;4000 in the SRAM.</li>
<li>You can force a reload by holding down Ctrl-Enter while the
TI-99/4A
is restarting.</li>
<h4>Configuring your system</h4>
<p>The TI-Basic program called <tt>NEWCFG </tt>can be used to set
your
system configuration after you installed it. Note that you must perform
<tt>CALL FILES(1)</tt> before you load this program (it's big and
slow...).
The program starts by asking for a password: for the moment being just
hit &lt;enter&gt;. Later on you can use option 6 to set your own
password.
The other options let you configure IDEAL.</p>
<p>Alternatively, you can update the configuration yourself via the
file
<tt>IDE.CONFIG</tt>, which is what <tt>NEWCFG </tt>is doing anyway.
Refer
to the corresponding section <a href="#Configuration">below</a>. </p>
<p>In any case, the parameters that you should set are:</p>
<li>Hardware description (if non-standard)</li>
<li>User options</li>
<li>Name of the virtual drives</li>
<li>Location of the system files</li>
<li>Optionally: autostart program, location of the Extended Basic
cartridge.</li>
<p>Now you are ready to roll... A few more technical details follow,
but
on first reading you can just skip ahead to the "<a href="#Overview">Overview</a>"
section.</p>
<h4>Backup issues</h4>
<p>In addition to these options, IDEAL also retains some important
internal
pointers, such as the root of your floppy disk collection (arranged as
an <a href="avltrees.htm">AVL tree</a>) or pointers to each trash file
(arranged as double-linked lists). Obviously, you can't afford loosing
this information, so several layers of backup have been implemented in
IDEAL 1.0:</p>
<p>1) If you have a battery-backed SRAM, the configuration info should
be safe at any time, even when the PE-box is turned off. Unless of
course
the battery runs out...</p>
<p>2) If your clock chip has on-board memory, the configuration will
automatically
be saved into it after any change. When you reload IDEAL (either with <tt>IDELOAD</tt>,
or through the boostrap), the configuration is copied from the clock
memory
into the SRAM.</p>
<p>3) An additional backup is maintained on the hard-drive itself, in a
reserved area that is not part of your virtual floppy collection
(namely,
hard-drive sector 0). This backup is updated each time you <tt>CLOSE </tt>the
file <tt>IDE.CONFIG </tt>after a modification. If you reset the
computer
before closing the file, any change you made will be saved into the
clock
RAM but not on disk! </p>
<p>Note: This backup is only used if a valid configuration cannot be
found
in the clock memory when IDEAL is loaded. To invalidate it and use the
disk backup instead, use the <tt>CLOCK </tt>DSR to alter page 55 in
the
clock memory:</p>
<pre>100 OPEN #1:"CLOCK", INTERNAL, FIXED 128, RELATIVE<br>110 PRINT #1, REC(100+55): "0123456789abcdef0123456789abcdef"<br>120 CLOSE #1</pre>
<p>Then force a system reload by holding down Ctrl-Enter while you
reset
the TI-99/4A.</p>
<p>4) If you feel that you need an additional level of backup, you can
save the configuration present in the hard drive onto a floppy. This
implies
that sector-wise access of the hard drive is enabled (you can always
turn
it off later).</p>
<pre>100 OPEN #1: "IDE.SECTORS", INTERNAL, FIXED 129,&nbsp;RELATIVE<br>110 PRINT #1, REC 0: 0,0<br>120 INPUT #1: PART1$,PART2$,PART3$,PART4$<br>130 CLOSE #1<br>140 OPEN #2:"DSK1.BACKUP",INTERNAL, FIXED 129, OUTPUT<br>150 PRINT #2: PART1$,PART2$,PART3$,PART4$<br>160 CLOSE #2</pre>
<p>To restore a lost configuration from such a backup just reverse the
process, then invalidate the clock memory and force a reload as
described
above.</p>
<h4><br>
Mini-IDEAL</h4>
<p>IDEAL version 1.0 is quite a big program. Currently, it uses 10
pages
in the SRAM, for a total of about 50 Kbytes. That's not a problem if
you
have a 128K or a 512K SRAM on your card, but if you went the cheap way
and have only 32K you are in trouble. Not to worry though: there is a
way
to skim down IDEAL, so it would fit in four pages. This may also be
usefull
if you want to use a lot of RAMBO pages.</p>
<p>Here are the SRAM pages used by IDEAL:</p>
<pre>           Page 0               Page 1               Page 2        <br>&gt;4000+-----------------+  +-----------------+  +-----------------+<br>     | Registers       |  | xxxxxxxxxxxxxxx |  | xxxxxxxxxxxxxxx |<br>&gt;4000+-----------------+  +-----------------+  +-----------------+<br>     | Entry points    |  | CLOCK DSR       |  | Char patterns   |<br>     | Config data     |  | RAMBO manager   |  | for LD          |<br>     | Common          |  | ISR             |  |                 |<br>     | subroutines     |  |                 |  |                 |<br>&gt;5000+-----------------+  +-----------------+  +-----------------+<br>     | Sub &gt;10 &gt;14 &gt;15 |  | Opcodes 0 to 4  |  | Autostart       |<br>     | Dir-files subs  |  | 8 and 9         |  | LD DSR          |<br>     |                 |  |                 |  | Opcodes &gt;A to &gt;C|<br>     |                 |  |                 |  | Sub &gt;11 &gt;12 &gt;13 |<br>     | Buffers (&gt;5B00) |  |                 |  | Custom subs     |<br>     +-----------------+  +-----------------+  +-----------------+</pre>
<pre>           Page 3               Page 4               Page 5               Page 6<br>&gt;4000+-----------------+  +-----------------+  +-----------------+  +-----------------+<br>     |xxxxxxxxxxxxxxx  |  | xxxxxxxxxxxxxxx |  | xxxxxxxxxxxxxxx |  | xxxxxxxxxxxxxxx |<br>&gt;4100+-----------------+  +-----------------+  +-----------------+  +-----------------+<br>     |    not used     |  | Number Pi       |  | Encryption      |  |    not used     |<br>     |                 |  | for Blowfish    |  | key             |  |                 |<br>&gt;5000+-----------------+  +-----------------+  +-----------------+  +-----------------+<br>     | Floppy collec   |  | Configuration   |  | Blowfish        |  | Trash management|<br>     | management      |  | management      |  | encryption      |  | IDE.TRASHx      |<br>     | IDE.FLOPPIES    |  | Catalog         |  | IDE.BLOWxxx     |  |                 |<br>     |                 |  | Extended cat    |  |                 |  |                 |<br>     | Buffers         |  | Buffers         |  |                 |  |                 |<br>     +-----------------+  +-----------------+  +-----------------+  +-----------------+</pre>
<pre>          Next page            Next page            Next page       <br>&gt;4000+-----------------+  +-----------------+  +-----------------+<br>     | xxxxxxxxxxxxxxx |  | xxxxxxxxxxxxxxx |  | xxxxxxxxxxxxxxx |<br>&gt;4000+-----------------+  +-----------------+  +-----------------+<br>     |    not used     |  |    not used     |  |    not used     |<br>     |                 |  |                 |  |                 |<br>&gt;5000+-----------------+  +-----------------+  +-----------------+   (more pages)<br>     | Buffering subs  |  | Buffering subs  |  | Buffering subs  |   (if needed )<br>&gt;5400+ Opened files    |  | Opened files    |  | Opened files    |<br>     | buffers         |  | buffers         |  | buffers         |<br>     | (5 files)       |  | (5 files)       |  | (5 files)       |<br>     |                 |  |                 |  |                 |<br>     +-----------------+  +-----------------+  +-----------------+<br></pre>
<p>As you can see, Blowfish encryption is the most memory-hungry
feature.
So if you have no use for it, you can save a page and a half.</p>
<p>If you decide that your floppy collection is complete for now, you
can
remove the collection manager and the trash manager. This means that
you
will not be able to rename a floppy since it would require rearranging
the collection.</p>
<p>If you are satisfied with the current configuration and have no need
for the catalog function, you can also remove page 4.</p>
<p>You can reclaim the lower part of page 1 if you don't use RAMBO
mode,
nor call the <tt>CLOCK </tt>DSR (time stamping still works though).
Similarly,
if you don't use <tt>LD </tt>nor the autostart feature (or only to
launch
programs that set up their own character patterns) you can reclaim the
lower part of page 2.</p>
<p>Finally, you can decrease the number of opened files, so as to use
less
pages to buffer them. Opened files buffers are always in the pages
immediately
following the system. There is room for 5 files per page.</p>
<p>Once you have made up your mind as to what you want to keep, you can
remove some of the <tt>IDEAL/x</tt> files. Each time you remove such a
file, replace it with a copy of the file called <tt>NOLOAD</tt>
renamed
as <tt>IDEAL/x</tt>. Here is the list of system files:</p>
<pre>IDEAL/A  Page 0 high (required)<br>IDEAL/B  Page 1 low<br>IDEAL/C  Page 1 high (required)<br>IDEAL/D  Page 2 low<br>IDEAL/E  Page 2 high (required)<br>IDEAL/F  Page 3 high<br>IDEAL/G  Gram Card-specific routines (in page 2)<br>IDEAL/H  Page 4 low<br>IDEAL/I  Page 4 high<br>IDEAL/J  Page 5 high (page 5 low is filled on the fly)<br>IDEAL/K  Page 6 high<br>IDEAL/L  Buffer pages (required)<br>IDEAL/M  Page 0 low (required, must be last file)</pre>
<p>To avoid crashes, you should edit your system configuration and
indicate
which features have been disabled (record 20 in <tt>IDE.CONFIG</tt>).
Obviously,
if you disable the configuration feature, you should do this before
removing
the file!</p>
<p>If you ever need the full-fledge IDEAL, you can always load it from
a floppy with <tt>IDELOAD</tt>.</p>
<h4><a name="non-standard"></a>Non-standard IDE&nbsp;card</h4>
<p>If you did not build the IDE&nbsp;card according to specs, it is
still
possible to use IDEAL but you must configure it correspondingly with
the
hardware part of <tt>IDE.CONFIG</tt> (records 20 and 21, see <a
 href="#Configuration">below</a>).
The problem here is that, if you used different CRU bits than me, <tt>IDE.CONFIG</tt>
won't work. Thus you must patch <tt>IDELOAD </tt>so that it places
the
proper CRU values in IDEAL and in the bootstrap.</p>
<p>To this end, edit <tt>IDE-LD2/O</tt> with a text editor. It's a
non-compressed
DF80 file, with all the parameters needed by <tt>IDELOAD</tt>. Modify
them
according to your hardware. The file is commented for your convenience.</p>
<p>Remember that CRU bits are off at power-up time, so any function
that
you want to be the default should be active-low. For active-low bits,
enter
the string:</p>
<pre>9yyyyB1E0xB1D0xF </pre>
<p>Where x is the bit number, &gt;1D0x is the code for <tt>SBO </tt>and
&gt;1E0x is the opcode for <tt>SBZ</tt>. (9yyyy is the loading
address,
leave it unchanged).</p>
<p>For active-high bits, just invert the two commands:</p>
<pre>9yyyyB1D0xB1E0xF</pre>
<p>If you did not implement a bit, replace both commands with NOPs
(opcode
&gt;1000):</p>
<pre>9yyyyB1000B1000F</pre>
<p>Once done, save the file back in DF80 format. If your text editor
won't
let you do this (e.g. Funnelweb's), save it as DF80 and use the
TI-Basic
program VAR2FIX to convert it to DF80.</p>
<p>Alternatively, you can edit the source file <tt>IDE-LD2/S</tt> and
assemble
it.</p>
<p>In any case, once you have set up the proper bit values, the
procedure
is the following:</p>
<ul>
  <li>Load <tt>IDELOAD </tt>with Editor/Assembler option 5 (or
equivalent).</li>
  <li>Press &lt;back&gt; to exit immediately.</li>
  <li>Load <tt>IDE-LD2/O</tt> with Editor/Assembler option3 (or
equivalent).
It will auto-start and take you to the main menu in <tt>IDELOAD</tt>.</li>
  <li>Proceed as above to load your system.</li>
</ul>
<p>Yeah, I know it's complicated. That's what you get for not following
the specs...</p>
<h2><br>
<a name="Overview"></a>Overview</h2>
<h4>File access</h4>
<p>All virtual floppies in your collection can be accessed by name with
the <b>DSK@</b> device. For instance:</p>
<p><tt>OLD DSK@.DISKNAME.FILENAME</tt></p>
<p>Note the similarity with the <tt>DSK.DISKNAME.FILENAME</tt> syntax
used
by the floppy disk controller. In fact, the latter will also work with
the IDE card, but only if its CRU address is set as &gt;1000. This is
because
the floppy controller, which is the second card scanned (its CRU is
&gt;1100),
returns an error if it does not find <tt>DISKNAME </tt>in one of its
drives.
Of course, if you don't have a floppy controller installed, there won't
be any problem with using <tt>DSK.DISKNAME.FILENAME</tt>, no matter
what
the CRU of the IDE card is.</p>
<p>Alternatively, a virtual floppy can be "inserted" into a virtual
drive. There are eight such drives, with names in the format <b>DSKn</b>,
where n is a number from 1 to 9, or a letter from A to Z. Once a
virtual
floppy is inserted, it can be accessed as if it were in a real drive:</p>
<pre>OPEN #1:"DSK9.FILENAME",INPUT</pre>
<p>A difference with the standard TI floppy controller is that, if the
file already exists, you don't need to specify its type when opening
it:
if the record size is 0 (which it will be in Basic if you do not
specify
a record length), the size and file type are supplied from disk. Note
however
that Basic requires a comma after the filename in <tt>OPEN</tt>, so
you'll
need to supply at least one parameter (like <tt>INPUT&nbsp;</tt>in the
example above). </p>
<p>Another difference is that you can now open fixed files in append
mode.
</p>
<p>Inserting a floppy in a virtual drive is the only way you can make
it
available to the standard sector-access subprograms (subprograms &gt;10
to &gt;15). As most disk managers exclusively use these subprograms
(e.g.
DISKU), this feature will come handy with them.</p>
<h4><br>
Catalog access</h4>
<p>You can catalog the floppy currently in a virtual drive just the way
you would with a real floppy:</p>
<p><tt>OPEN #1:"DSK9.",INTERNAL, FIXED 38, INPUT</tt></p>
<p>or, using the disk name:</p>
<p><tt>OPEN #1: "DSK@.DISKNAME.", INTERNAL, FIXED 38, INPUT</tt></p>
<p>In addition, IDEAL 1.0 offers a more sophisticated catalog access,
see
<a href="#Catalog">below</a>.</p>
<h4><br>
<br>
Inserting a virtual floppy into a virtual drive</h4>
<p>To "insert" a virtual floppy into a virtual drive use the
<b>CD</b> subprogram. It can be used in several ways:</p>
<p>1) With the disk name:</p>
<pre>CALL CD.9..DISKNAME       or<br>DELETE "CD.9..DISKNAME"</pre>
<p>The double-dot syntax tells the system that you are not trying to
access
a file called <tt>DISKNAME </tt>on the floppy currently in <tt>DSK9</tt>,
but rather to insert the floppy called <tt>DISKNAME </tt>into the
drive
<tt>DSK9</tt>. </p>
<p>Note that CD can be considered both as a subprogram, called with <tt>CALL
</tt>from Basic and <tt>DSRLNK </tt>offset &gt;000A from assembly,
and
as a device, accessed with any file operation in Basic or offest
&gt;0008
in assembly:</p>
<p>The advantage of the later is that you can use string variables: <tt>DELETE
A$</tt> is legal in Basic, whereas <tt>CALL A$</tt> is not. Of course,
that's not a problem when working from assembly. Note that any file
operation
will do, <tt>DELETE </tt>is just convenient because it does not take
any
file number in Basic. And don't worry, nothing will be deleted: no
other
action than inserting the floppy will be taken whatever file operation
you use. </p>
<p>2) By following a directory path:</p>
<p>If the virtual floppy currently in the virtual drive contains a <a
 href="#Subdirectories">directory
pointer file</a>, you can follow it to access the corresponding
disk.&nbsp;This
will automatically insert the floppy the directory file is pointing at,
in place of the current floppy. For instance:</p>
<pre>CALL CD.9.MYDIR         or<br>DELETE "CD.9.MYDIR"     or<br>OPEN #1:"DSK9.MYDIR",INTERNAL,FIXED 1,INPUT</pre>
<p>will insert into <tt>DSK9 </tt>the floppy pointed at by the file <tt>MYDIR,</tt>
currently in <tt>DSK9</tt>.</p>
<p>3) Finally, how to insert a floppy into a virtual drive when working
within a disk manager program, like DISKU?</p>
<p>The problem here is that DISKU does almost everything with the
sector-access
subprogram &gt;10, which does not take any filename. Exceptions are
Viewing
and Deleting files. So here is the technique: 1) Create a file with the
name of the disk you want to insert, preceded with a dot (e.g. <tt>".MYDISK"</tt>).
2) Delete it. It won't be deleted (to do this you must rename it
first),
but the drive will now contain the required disk. </p>
<p>Alternatively, you can just follow a directory path by attempting to
View the corresponding directory file. DISKU will <tt>OPEN </tt>it,
which
automatically inserts the target disk into the drive. You'll get an
error
message because DISKU tries to <tt>READ</tt>, then <tt>CLOSE&nbsp;</tt>the
file, which cannot be found any more since the disk just changed.
Acknowledge
the error and press &lt;redo&gt; to update the listing: you should see
the content of the new disk.</p>
<h4><br>
Removing a virtual floppy from a virtual drive</h4>
<p>Do just as above, but with no diskname:</p>
<pre><tt>CALL CD.Z..  </tt>or <br><tt>CALL CD.Z.   or even<br>CALL CD.Z</tt></pre>
<p>This will not delete anything: the virtual floppy remains in your
collection.
It just means that it cannot be accessed via <tt>DSKZ </tt>any longer.</p>
<p>The DSR can be used in the same manner:</p>
<pre><tt>DELETE "CD.9.."  or<br>DELETE "CD.9."   or<br>DELETE "CD.9"</tt></pre>
<p>Caution: if you have opened files in this drive, you must close them
BEFORE removing the floppy, otherwise the most recent changes may be
lost
(of course, this may be precisely what you are trying to do).</p>
<h4><br>
Adding a new virtual floppy to your collection</h4>
<p>There are several methods:</p>
<p>1) Use a disk manager to format a virtual drive: an empty virtual
floppy
with the required size and name will be added to your collection. If
there
was a floppy in this drive before, it is simply returned to the
collection;
it won't be overwritten by the formatting operation.</p>
<p>2) Edit your collection by opening the file <tt>IDE.FLOPPIES </tt>in
append mode, and create a new record containing the new disk name and
its
size in sectors:</p>
<p><tt>100 OPEN #1:"IDE.FLOPPIES", INTERNAL, VARIABLE 80, APPEND<br>
110 PRINT&nbsp;#1:"DISKNAME",360<br>
120 CLOSE #1</tt></p>
<h4><br>
Removing a virtual floppy from your collection</h4>
<p>Edit your collection by opening the file <tt>IDE.FLOPPIES</tt> in
update
mode, locate the record of interest and overwrite it with an empty name
and a size of -1:</p>
<p><tt>100 OPEN #1:"IDE.FLOPPIES", INTERNAL, VARIABLE 80, APPEND<br>
110 I=1<br>
120 INPUT #1, REC I:A$<br>
130 IF A$="DISKNAME" THEN 200<br>
140 I=I+1<br>
150 GOTO 120<br>
200 PRINT&nbsp;#1, REC I:"",-1<br>
210 CLOSE #1</tt></p>
<p>NB. There is a faster way to locate the proper record, see <a
 href="#Collection">below</a>.
Also, there is a way to recover floppies deleted by mistake.</p>
<h2><br>
<a name="Subdirectories"></a>Subdirectories</h2>
<p>IDEAL 1.0 provides a rudimentary implementation of subdirectories:
it
lets you define files that do not contain any data, but rather point at
another virtual floppy. This second floppy can thus be considered as a
subdirectory of the first one. Note that, unlike PC folders,
subdirectories
don't need to be arranged in a tree: a given floppy can be a
subdirectory
of many others (there can even be circular references, so be carefull).
In fact, directories are more like Windows shortcuts, except that they
point to virtual floppies, not to files.</p>
<p>To a regular disk manager, subdirectories appear as empty Int/Fix 1
or Int/Var 1 files. Only IDEAL recognizes them as directory pointers
and
uses them accordingly.</p>
<h4>Accessing subdirectories</h4>
<p>To access a file in a subdirectory of the floppy currently in a
virtual
drive, use the following syntax:</p>
<p><tt>OPEN #1: "DSK7.DIRECTORY.FILENAME"</tt></p>
<p>Where <tt>FILENAME </tt>is a file located in the virtual floppy
pointed
at by the pointer file named <tt>DIRECTORY</tt>. To make things
clearer,
I'd suggest that you always give your pointer files the same name as
the
floppy they are pointing at. In fact IDEAL can do this automatically
for
Int/Fix 1 directory files: whenever you rename a floppy, all the files
pointing to it are also renamed (unless a file with this name already
exists,
in which case the pointer file becomes Int/Var 1). When you remove the
floppy from your collection, all pointer files leading to it are
deleted
or, if protected, marked as invalid (Int/Fix 2 or Int/Var 2).</p>
<p>If the target floppy itself contains pointer files, you can specify
a whole directory path:</p>
<p><tt>SAVE DSK6.DIR.SUBDIR.SUBSUBDIR.FILENAME</tt></p>
<p><br>
When you create a pointer file pointing to a floppy, this floppy
remember
the current directory as its "parent" (if you create more than
one pointer to a given floppy, you can choose which one will be the
parent).
You can walk back to the parent directory by using "&lt;" as
a subdirectory name (which means that "&lt;" is not a valid diskname
in your collection):</p>
<p><tt>OLD DSKA.&lt;.FILENAME</tt></p>
<p>This looks for the file "filename" in the parent of the disk
currently in drive <tt>DSKA, </tt>i.e. a disk that contains a pointer
file
pointing at the current disk.</p>
<p>And of course, you can combine all these in fairly cryptic pathes
like
this one:</p>
<p><tt>DELETE "DSK@.DISKNAME.&lt;.&lt;.DIRECTORY.SUBDIR.FILENAME"</tt></p>
<p>Let's see; this will delete the file <tt>FILENAME</tt>, in the
virtual
floppy pointed at by <tt>SUBDIR</tt>, which is a pointer file located
on
a floppy pointed at by <tt>DIRECTORY</tt>, which itself is located on
the
grand-parent of the floppy named <tt>DISKNAME</tt>. I'd be quite
careful
before I start using such a complicated path though...</p>
<h4><br>
Changing directories</h4>
<p>To insert the floppy corresponding to a pointer file located in the
current drive you can use the subprogram CD:</p>
<pre>CALL CD.7.DIRECTORY</pre>
<p>Alternatively, you could use DELETE in the same way:</p>
<pre>DELETE "CD.7.DIRECTORY"</pre>
<p>Both will insert the floppy pointed at by <tt>DIRECTORY </tt>into <tt>DSK7
(</tt>and <tt>n</tt>othing will be deleted). The file <tt>DIRECTORY </tt>must
be present in the virtual floppy currently inserted in <tt>DSK7</tt>.</p>
<p>Alternatively, you have the option of specifying the name of the
floppy
to be inserted:</p>
<pre>CALL CD.8..DISKNAME or<br>DELETE "CD.8..DISKNAME"</pre>
<p>Note the double-dot syntax, it indicates that <tt>DISKNAME </tt>is
a
virtual floppy, not a pointer file.</p>
<p>Finally, you can make combinations:</p>
<pre>CALL CD.B..DISKNAME.&lt;.DIRECTORY.SUBDIR</pre>
<p>In the above example, &lt; indicates the parent directory of <tt>DISKNAME</tt>,
i.e. a virtual floppy that contains a pointer file pointing at <tt>DISKNAME</tt>.
On this parent disk should be another file called <tt>DIRECTORY </tt>pointing
at another disk. On that other disk should be a file called <tt>SUBDIR
</tt>pointing at yet another disk, which is the one that will
ultimately
be inserted. You don't have to make it so complicated though...</p>
<h4><br>
Deleting directories</h4>
<p>You should always use the official <tt>DELETE </tt>operation
(opcode
&gt;07) to delete a directory file:</p>
<pre>DELETE "DSKG.DIRFILE"</pre>
<p>Don't worry, this will not delete the floppy pointed at, only the
file
that points at it. </p>
<p>Never attempt to delete pointer files "manually" with sector
edition: only the <tt>DELETE </tt>opcode knows how to maintain proper
linking
between all directory files that point at the same disk. Beware of disk
managers that may try to do it in this waym rather than calling opcode
&gt;07.</p>
<h4><br>
Creating directories</h4>
<p>To create a new directory pointer, just create a new Int/Fix 1 or
Int/Var
1 file, with the following syntax:</p>
<pre>OPEN #1:"DSK5.FILENAME..DISKNAME", INTERNAL, FIXED&nbsp;1, OUTPUT</pre>
<p>Note the double-dot syntax: it tells IDEAL that you are not really
trying
to create a regular IF1 file, but rather a pointer file that points to
the target floppy named <tt>DISKNAME</tt>. If you chose to make it a
Fixed
file, IDEAL will automatically substitute <tt>DISKNAME </tt>for the
filename
(which may cause an error if a file with this name already exists).</p>
<p>It is not allowed to overwrite an existing directory, even to point
it at the very same disk. If the file you are creating already exists,
you will get a write protection error (code 1), even if the file was
not
protected. To modify a pointer file, you must first delete it, then
create
it anew.</p>
<p>Opening the pointer file as <tt>OUTPUT </tt>will cause the disk it
resides
on to become the parent directory of the target disk. If you open the
file
as <tt>UPDATE </tt>(the default), and the target disk already has a
parent,
it will keep it. Note that you can set an <a href="#user%20options">option</a>
while configuring IDEAL that forbids you to change the parent
directory.
When this flag is set, a given disk can only have one Int/Fix 1
directory
file pointing at it: its parent. This forces you to arrange your disks
in a tree-wise manner, as on a PC, although no provision is made to
avoid
circular references. You can define extra Int/Var pointer files
pointing
at this disk, but only if automatic update has been disabled for
Int/Var
files (see below).</p>
<p>Finally, using <tt>SAVE </tt>instead of <tt>OPEN </tt>will also
work
to create a pointer file, but only <tt>OPEN </tt>lets you specify
file
options: if you use <tt>SAVE </tt>the default type is always Int/Fix
1,
and the parent directory will not be changed if it already exists.</p>
<h4><br>
Dynamic directory update</h4>
<p>Int/Fix 1 pointer files are automatically renamed when you change
the
name of the floppy they point at. That is, provided there isn't already
a file with this name on the disk they reside on, in which case the
file
type would be changed to Int/Var 1. Int/Var 1 pointer files are never
renamed.</p>
<p>If you remove the target floppy from your floppy collection, all
pointer
files pointing at it will be deleted. If a pointer file is protected
and
cannot be deleted, it is changed into a Int/Fix 2 file and unprotected.
This feature is mandatory for Int/Fix pointer files and optional for
Int/Var
files: these may be automatically deleted or not, depending on an <a
 href="#user%20options">option</a>
flag that you set when configuring IDEAL.</p>
<p>CAUTION: Dynamic update relies on the fact that a given pointer file
will always be at the same location on your hard drive. Therefore, do
not
copy a pointer file from a disk to another: it could not be properly
updated.
Instead, create another pointer on the second disk, using <tt>OPEN </tt>or
<tt>SAVE </tt>as described above. For the same reason, do not use a
disk
manager that rearranges files on disk when making your safety backup:
use
a sector-copy program instead. Always use <tt>DELETE </tt>to delete
pointer
files (rather than poking sectors 0 and 1) and never, ever doctor the
information
you will find at bytes &gt;20-2D in the FDR of a pointer file. </p>
<p>This becomes even more of a problem when a pointer file is located
on
an encrypted floppy and you did not turn encryption on. This pointer
file
won't be updated but, which is worse, it cannot even be read and
prevents
IDEAL from walking the pointer chain any further. One way to avoid this
problem is to always turn encryption on before renaming/deleting disks
and/or pointer files. Another is not to place on an encrypted disk any
pointer file pointing to a non-encrypted disk .</p>
<h2><br>
<a name="Encryption"></a>Encryption</h2>
<p>IDEAL 1.0 gives you the option to encrypt a floppy, or a file so
that
only you can access it. Encryption is performed according to Blowfish,
a very secure algorithm that has never been cracked so far. The price
to
pay is a slightly slower disk access.</p>
<p>Any attempt to access encrypted files or floppies without enabling
Blowfish
deciphering results in a file error. Using an incorrect password will
return
gibberish and may even crash your program. Furthermore, if you write
something
with an incorrect password, you'll never be able to read it again! So
my
advise is: just after you enter your password, make an attempt to read
something that you know for sure was encoded with this password. If you
can't read it, you made a typo.</p>
<h4>Entering your password</h4>
<p>Your password only needs to be entered once. It then remains active
until either you erase it or you turn the PE-box off. Caution: reseting
the TI-99/4A will not erase your password unless you set the
appropriate
<a href="#user%20options">option</a> while configuring IDEAL. Also, if
you
have a battery-backed SRAM on your IDE card, turning the power off
leaves
the encryption key intact in memory. (In such a case you should
actively
erase the key once you are done).</p>
<pre>DELETE "IDE.BLOWON.PASSWORD"    or<br>CALL&nbsp;IDE.BLOWON.PASSWORD</pre>
<p>Any file operation will do, but <tt>DELETE&nbsp;</tt>is quite
convenient
because it does not affect the file buffers in Basic. A <tt>CALL </tt>can
also be used, but the advantage of a file operation is that you can
pass
a string variable: <tt>DELETE A$.</tt></p>
<p><tt>PASSWORD </tt>should be a string of upto 56 characters.</p>
<p>The Blowfish routine will then create the encryption key from the
number
Pi and your password, this takes about 3 seconds. From this point on,
Blowfish
encryption is active. Any file or directory that was encrypted will be
automatically decrypted. Any new file (or virtual floppy) that you
create
will be encrypted with the current password.</p>
<p>If at any time you want to change passwords, just repeate the above
operation. Caution: make sure than any opened file has been closed
before
you change password or erase your key. Otherwise, any data still in
memory
cannot be saved back on disk.</p>
<p>Note that, for proper security, your password should never be
spelled
out in a Basic program as in the examples above (these assume
interactive
keyboard entry). If you want to enable Blowfish encryption from a
program,
use something like:</p>
<pre>100 PRINT "ENTER&nbsp;YOUR&nbsp;PASSWORD"<br>110 INPUT&nbsp;PW$<br>120 DELETE "IDE.BLOWON."&amp;PW$<br>130 PW$=SEG$("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX<br>    XXXXXXXXXXXXXXXXXXXXX",1,LEN(PW$))</pre>
<p>Line 130 serves to overwrite your password in the Basic string
space,
so that a collegue cannot retrieve your password by peaking the VDP
memory
while you went for a cup of coffee. It is not necessary if you reboot
your
computer once you are done. </p>
<h4>Turning Blowfish on/off</h4>
<p>You may turn encryption/decryption off without erasing your password
by calling</p>
<pre>DELETE "IDE.BLOWOFF"    or<br>CALL IDE.BLOWOFF</pre>
<p>Alternatively, you can turn encryption off, but leave decryption on
(i.e. newly created files and floppies won't be encrypted, but
previously
encrypted files will be accessed in an encrypted fashion):</p>
<pre>DELETE "IDE.BLOWOUT"    or<br>CALL&nbsp;IDE.BLOWOUT</pre>
<p>You can turn full encryption back on with:</p>
<pre>DELETE "IDE.BLOWON"    or<br>CALL&nbsp;IDE.BLOWON</pre>
<p>Again, make sure all opened files are closed before you turn
encryption
off.</p>
<p>Note that the password can also be passed with <tt>BLOWOUT </tt>and
<tt>BLOWOFF</tt>, in the same way as with <tt>BLOWON</tt>.</p>
<h4><br>
Erasing the key</h4>
<p>Your password remains in effect even if you reboot the TI-99/4A (as
long as you don't turn off the PE-Box). This was done so you can leave
encryption on while changing cartridges, etc. If that's not what you
want,
you have the <a href="#user%20options">option</a> to configure the
system
so that it automatically wipes off the encryption key upon power-up.</p>
<p>For proper security, it is critical that you remove the key from
memory
once you are done with accessing encrypted data. In addition, IDEAL
will
also wipe out any unciphered data that may remain in the opened file
buffers.
This is especially critical if you are using a battery-backed SRAM that
will retain buffer contents and encryption key even after power was
turned
off. To erase the current key, just perform any file operation on <tt>IDE.BLOWAWAY</tt>:</p>
<pre>DELETE "IDE.BLOWAWAY"    or<br>CALL&nbsp;IDE.BLOWAWAY</pre>
<h4><br>
Encrypting data</h4>
<p>You can also access the encryption engine directly so as to
encode/decode
data yourself. This is done via two pseudofiles, <tt>IDE.BLOWPLAIN</tt>
and <tt>IDE.BLOWCIPHER</tt>. As you might have guessed, <tt>BLOWPLAIN
</tt>is
used to pass/retrieve plain text, whereas <tt>BLOWCIPHER </tt>accesses
the chiphertext.</p>
<p><tt>IDE.BLOWPLAIN</tt> can be a file of any type you want, as long
as
the maximum record length is 248 or less. Larger records result in a
256-byte
ciphered string, which is illegal in Basic (It's ok if you work from
assembly,
but be aware that a 256-byte string has a size byte of &gt;00). <tt>IDE.BLOWCIPHER</tt>
should be an <tt>INTERNAL, FIXED 249</tt> file. Smaller record lengths
may be ok, as long as they can accomodate all data passed to <tt>BLOWPLAIN
</tt>rounded up to the next multiple of 8, plus 1 byte for string size.</p>
<p>The password should be specified with <tt>IDE.BLOWOFF.<i>password</i></tt>
as explained above. That is, assuming that you don't want to turn on
encryption
for your hard-drive. Otherwise, you may just as well use <tt>BLOWON </tt>to
set the password.</p>
<p>To encode data, write them to <tt>BLOWPLAIN </tt>and retrieve the
coded
version from <tt>BLOWCIPHER</tt>. This will be a single string, upto
248
characters in length. NB: It is critical that BOTH files are opened
before
you write anything to one of them (otherwise you'll get an end-of-file
error).</p>
<pre>DELETE "IDE.BLOWOFF.THIS-IS-MY-PASSWORD"<br>RUN</pre>
<pre>100 OPEN #1:"IDE.BLOWPLAIN",INTERNAL,VARIABLE 80<br>110 OPEN #2:"IDE.BLOWCIPHER",INTERNAL,VARIABLE 249<br>120 PRINT&nbsp;#1:"This is a test",1234,Y,B$<br>130 INPUT #2:CODED$</pre>
<p>To decode previously coded data, perform the opposite operation:
write
the ciphered string to <tt>BLOWCIPHER </tt>and read back the plain
data
from <tt>BLOWPLAIN</tt>.</p>
<pre>140 PRINT&nbsp;#2:CODED$<br>150 INPUT #1:A$,X,Y,B$</pre>
<p>Note that, because Blowfish always operates on 8-byte values, it may
have padded the end of the record with spaces. You shouldn't notice it
in Basic (that trims trailing spaces), but be aware of it when working
from assembly.</p>
<p>If you have battery-backed SRAMs, always close <tt>BLOWPLAIN </tt>when
done: this will wipe out any plain text that may remain in the card
buffers.<br>
</p>
<h4>What's encrypted?</h4>
<p>On a crypted disk, all sectors are encrypted except for sectors 0
and
1. Such a disk is created if encryption is on when you format it. A
flag
is sector 0 indicates that the disk is encrypted. Be aware that
individual
files cannot be super-encrypted on a disk that's already crypted.</p>
<p>If you encrypt a file on a non-crypted disk, a flag bit is set in
its
FDRs to indicates that the file is encrypted (the FDR is a sector that
contains all the file information). The FDR itself is not encrypted,
only
the sectors that make up the file. These sectors are completely
encrypted,
irrespective of whether the data occupies the full sector or if there
are
"junk" bytes in the end.</p>
<p>Since they consists of only a FDR, directory pointers are never
encrypted
(unless they are on an encrypted disk, of course).</p>
<h2><br>
<br>
<a name="Catalog"></a>Extended catalog access</h2>
<p>As mentionned above, you can obtain the catalog of a virtual floppy
in the same way as with the TI floppy disk controller:</p>
<p><tt>OPEN #1:"DSK9.",INTERNAL, FIXED 38, INPUT</tt></p>
<p>Record 0 returns disk informations, the following records return
information
on each file, in alphabetical order. The first empty record returns an
empty string and 0 values. Attempts to access records beyond this one
result
in an end-of-file error.</p>
<h4>Extra information</h4>
<p>IDEAL 1.0 provides you with a more sophisticated catalog access. To
use it, open the file as either:</p>
<p><tt>OPEN #1:"DSK9.",INTERNAL, VARIABLE 128</tt></p>
<p>or, from assembly language</p>
<p><tt>OPEN #1:"DSK9.",INTERNAL, VARIABLE&nbsp;120</tt></p>
<p>The second form returns all numbers in the form of integers, instead
of floating point numbers. These are more convenient for assembly
language
programs. Strings are still prefaced with size bytes, though.</p>
<p>Technical note: Actually, you can open the catalog as a file of any
type. For instance, if you want to access it as a relative file, Basic
will force you to open it as a <tt>FIXED </tt>file. Any file type is
accepted,
only the record length matters: 38 opens the regular type catalog, 39
to
120 opens the extended catalog and passes numbers as integers, 121 to
128
passes them as floating point numbers. Finally, a record size of 129 or
higher is used for sector-wise access (<a href="#Sector%20access">see
below</a>).
If you don't specify any record size, it defaults to 128.</p>
<p>When opened as "extended", the catalog returns many additional
variables (although you don't have to input all of them, if you don't
need
them all).</p>
<p>Record 0 returns disk information:</p>
<p><tt>INPUT #1, REC
0:NAME$,FILES,SECTORS,FREE,TIMEC,DATEC,TIMEM,DATEM,FLAGS,RES</tt></p>
<li><tt>NAME$</tt>: A 10-character string containing the disk name</li>
<li><tt>FILES</tt>: Number of files in the catalog</li>
<li><tt>SECTORS</tt>: Number of sectors on disk</li>
<li><tt>FREE</tt>: Number of free sectors on disk.</li>
<li><tt>TIMEC</tt>: Time when the disk was created </li>
<li><tt>DATEC</tt>: Date when the disk was created (0 = not specified)</li>
<li><tt>TIMEM</tt>: Time of the last modification to the catalog </li>
<li><tt>DATEM</tt>: Date of the last modification to the catalog (0 =
not
specified)</li>
<li><tt>FLAGS</tt>: 1 = Disk is protected, 2 = Disk is encrypted, 4 =
720
sectors, 8 = 1440 sectors, 16 = Archive bit (reset when modified).</li>
<li><tt>RES</tt>: Reserved. </li>
<p>The next records return information on the files, in the order they
appear in the catalog (which should be alphabetical):</p>
<p><tt>INPUT
#1:NAME$,TYPE,SECTORS,RECLEN,TIMEC,DATEC,TIMEM,DATEM,FLAGS,FDR</tt></p>
<li><tt>NAME$</tt>: A 10-character string containing the file name</li>
<li><tt>TYPE</tt>: File type: 1=Dis/Fix 2=Dis/Var 3=Int/Fix 4=Int/Var
5=program.
Negative if protected.</li>
<li><tt>SECTORS</tt>: Number of sectors in file (including the FDR)</li>
<li><tt>RECLEN</tt>: Record length. For program files: # of bytes used
in last sector.</li>
<li><tt>TIMEC</tt>: Time when the file was created </li>
<li><tt>DATEC</tt>: Date when the file was created (0 = not specified)</li>
<li><tt>TIMEM</tt>: Time of the last modification to the file </li>
<li><tt>DATEM</tt>: Date of the last modification to the file (0 = not
specified)</li>
<li><tt>FLAGS</tt>: 1 = File is protected, 2 = File is encrypted, 4 =
File
is fractured (i.e. uses non-adjacent sectors), 8 = Directory, 16 =
Archive
bit (reset when modified).</li>
<li><tt>FDR</tt>: Sector # of the file descriptor (the FDR, i.e. the
sector
containing all the info about the file).</li>
<p>The time stamps have the following form:</p>
<p><tt>DATE = (YEAR*512) + (MONTH * 32) + DAYOFMONTH</tt></p>
<p><tt>TIME = (HOURS * 2048) + (MINUTES *32 ) + (SECONDS / 2)</tt></p>
<p>Where <tt>YEAR </tt>= 0 to 99, <tt>MONTH </tt>= 1 to 12, <tt>DAYOFMONTH
</tt>= 1 to 31 (whatever month it is), <tt>HOURS </tt>= 0 to 23, <tt>MINUTES
</tt>= 0 to 59, and <tt>SECONDS </tt>= 0 to 58.</p>
<p>Note that note that, in order to pack the time in a single word, it
is specified in 2-second increments.</p>
<p>A <tt>TIMEM </tt>value of 65535 is understood as a command for
IDEAL
not to update the time stamps for this file/floppy. You also have the <a
 href="#user%20options">option</a>
to globally disable stamping of all floppies and/or all files when
configuring
your system.</p>
<h4><br>
Writing to the catalog</h4>
<p>You can perform a number of disk operations without a disk manager,
by just writing to the appropriate record. Any field that you want to
leave
unchanged should contain zero. </p>
<p><tt>NAME$</tt>: you can change the name of a file but you cannot
rename
the disk (for this use IDE.FLOPPIES, see below). Caution, the name
should
be unique: if another file with the same name already exist a "file
error" is issued. Leave this string empty to keep the same name.</p>
<p><tt>SECTORS</tt>: You can decrease or increase the number of sectors
on disk. However, you should not exceed the number of sectors indicated
in the <tt>FLAG </tt>word (this is the maximum space reserved on the
hard
disk for this floppy).</p>
<p><tt>DATEx</tt> and <tt>TIMEx</tt>: You can always change a date and
time, even that of creation. If you set the date of last modification
to
65535 (&gt;FFFF), neither the date nor the time will be updated when
the
file is modified. If you set a value a zero, the current value, as read
from the clock, will be used instead. This works for both the disk and
the files.</p>
<p><tt>TYPE </tt>and <tt>RECLEN</tt>: You can change the file type
and
record length, but be carefull: this may well render the file unusable.
Negative <tt>TYPE&nbsp;</tt>values result in protecting the file,
positive
values do not affect the protection status unless the value is out of
range
(e.g. <tt>TYPE </tt>= 99) although it is probably more convenient to
use
the <tt>FLAG </tt>bits to change the file protection. Here are some
examples
of modifications:</p>
<li>Program ---&gt; DF128 (or DF64 or DF32, etc). Very convenient to
patch
a program file from Basic...</li>
<li>Any --&gt; Program. A program file can contain any type of data.
Note
that <tt>RECLEN </tt>will now correspond to the end-of-file offset
(last
byte in last sector).</li>
<li>DF16 --&gt; DF32 Expands a fixed file by merging its records. Safe
as long as it does not result in a record not fitting in the sector.</li>
<li>DF16 --&gt;DF48 won't work: there are sixteen DF16 records per
sector,
but five DF48 records. These can only accomodate fifteen DF16 records!</li>
<li>DF80 --&gt; DF40 It is generally ok to split fixed records in
several
smaller records, provided this does not result in using the unused
bytes
at the end of the sector.</li>
<li>DF200 --&gt;DF50 Here is a case when it's not ok: there are 56
unused
bytes per sector with DF200 files. If you make it DF50, there will be
five
DF50 records per sector, the last one containing only garbage.</li>
<li>DV80 --&gt; DV130 It's always ok to extend the maximum record size,
since no record should be greater than the current size anyhow.</li>
<li>DV80 --&gt; DV60 This may result in loss of data, unless you know
for
sure that no record on this file is greater than 60.</li>
<p><tt>FLAGS</tt>: You can modify the following flags: Disk protected,
File protected, Archive bit for either disk or file. </p>
<h4>Archive bit</h4>
<p>Each time a file is modified and its FDR (File Descriptor Record, a
sector that contains the file name and all kind of info about it) is
written
back to the disk, a special "archive" bit is reset in the FDR.
This allows automatic backup programs to monitor which file has
changed.
All such a program needs to do is to set the archive bit in the FDR of
any file it backs up. Next time you do a backup, the program will only
archive files whose "archive" bit was reset. Another possibility
is to compare the "last modification date" of the file with that
of the archive, and back up the file if it's greater.</p>
<p>The disk iteself also contains an archive bit which is modified only
if the disk catalog is modified. Which means that if you write to a
file,
the directory archive bit won't necessarily be changed (it may if you
changed
the file size, which modifies the sector bitmap).</p>
<h3><br>
<a name="Sector access"></a>Sector access</h3>
<p>Provision is made for you to access a virtual floppy in a
sector-wise
manner. But be carefull: this is an extremely powerfull feature and you
can hopelessly mess up a virtual floppy if you don't know what you're
doing.
In fact, you have the <a href="#user%20options">option</a> to turn
this feature
off while configuring IDEAL 1.0, so that no malicious program will be
able
to damage your virtual floppies.</p>
<p>Note: From assembly language, it is more convenient to use
subprogram
&gt;10 to perform sector access.</p>
<p>To access a floppy sector-wise, open its catalog as an <tt>INTERNAL,
FIXED&nbsp;129</tt> file. Each sector maps to two records in the file,
in numeric order. Each record contains a single 128-byte string that
corresponds
to half a sector.</p>
<p><tt>100 OPEN #1: "DSKV.",INTERNAL,FIXED 129,RELATIVE<br>
110 INPUT #1, REC 2: SEC1A$<br>
120 INPUT #1, REC 3: SEC1B$</tt></p>
<p>Sector numbering starts from zero, so records 0 and 1 correspond to
sector 0, records 2 and 3 to sector 1, etc. The above program reads the
content of sector 1 into the strings <tt>SEC1A$</tt> that contains the
first 128 bytes in the sector, and <tt>SEC1B$</tt> that contains the
last
128 bytes.</p>
<p>You can modify these strings at will, then write them back at the
same,
or another location. If the string you write is smaller than 128
characters,
only that many bytes are modified and the end of the half-sector
remains
unchanged.</p>
<p>The file can also be opened as a <tt>SEQUENTIAL </tt>file, but
don't
forget that each read/write operation moves to the next record. So if
you
<tt>PRINT </tt>back a string just after you <tt>INPUT </tt>it, you
will
actually write it to the next record!</p>
<p><u>Technical notes:</u></p>
<li>You may have noticed that all bytes at the end of sector 0 in each
vitual floppy (bytes 238-255) read as 255, no matter what you write
there.
IDEAL uses these bytes to store the information needed to manage the
floppy
collection: links to the previous and next floppy, to the parent
directory,
flag bits, etc. Altering these bytes may result in hopelessly messing
up
your floppy collection. For this reason, neither subprogram &gt;10 nor
the above sector-wise access technique let you modify them. In
addition,
I had to camouflage them as &gt;FF upon reading, because DISKU would
panic
when trying to write to sector 0 and reading different data!</li>
<li>Also note that if you alter the disk name in sector 0 your virtual
floppy collection will be rearranged, which could take a few seconds.
If
you have protected your collection, the write operation will fail with
a "write-protected" error.</li>
<h2><br>
<a name="Collection"></a>Editing your virtual floppy collection</h2>
<p>Your virtual floppy collection can be accessed via a pseudo-file
named:
<tt>IDE.FLOPPIES</tt>. This file must be opened as <tt>INTERNAL, FIXED
128 </tt>from Basic and as <tt>INTERNAL, FIXED&nbsp;120</tt> from
assembly.
The difference is that numbers are passed as floating point values in
Basic
and as integers in assembly. Strings are passed with a leading size
byte
in both cases.</p>
<p>You can open the file as either <tt>RELATIVE </tt>or <tt>SEQUENTIAL
</tt>mode. Relative files are easier to work with, but they are limited
to 32767 records in Basic and to &gt;FFFE records in assembly, so if
you
have more floppies you won't be able to access all of them. A
sequential
file is more cumbersome, but has no limitations on the number of
floppies.
Note that <tt>IDE.FLOPPIES</tt> has a special mechanism to jump to any
record via record 0 (see <a href="#Floppies%20rec%200">below</a>),
that works
with both sequential and relative files.</p>
<p><tt>100 OPEN #1: "IDE.FLOPPIES",INTERNAL,FIXED 128, RELATIVE</tt></p>
<p>Note: You can set a security <a href="#user%20options">option</a>
bit
while configuring your system, so that the collection cannot be
modified
by writing to <tt>IDE.FLOPPIES</tt>. This will prevent malicious
programs
from messing with your collection. While this bit is set, you can read
from <tt>IDE.FLOPPIES</tt>, but not write to it. Also you cannot use a
disk manager to rename a virtual floppy, nor to create a new one.
Trying
to do so will result in an I/O error #5.</p>
<h4><br>
Retrieving floppy disk parameters</h4>
<p>Record 0 has a special meaning so we'll set it aside for the moment
being. Each of the next records accesses one of your virtual floppies,
arranged in alphabetical order. Note that, because Basic file
operations
limit the number of records to 32767, you won't be able to access more
virtual floppies than this, unless you use a sequential file (from
assembly,
you can reach upto 65534 records).</p>
<p><tt>INPUT #1, REC X: NAME$,SECTORS,TIMEC,DATEC,TIMEM,DATEM,FLAGS,RES</tt></p>
<li><tt>NAME$</tt>: A 10-character string containing the disk name</li>
<li><tt>SECTORS</tt>: Apparent number of sectors in the disk, as stated
on sector 0. The actual amount of memory reserved for the virtual
floppy
depends on flag bits 4 and 8: 360, 720 or 1440 sectors. The <tt>SECTORS
  </tt>value should be small enough to fit in there. A value of 0
defaults
to this size.</li>
<li><tt>DATEC</tt>: Date when the disk was created (-1 = not used,
0=now)</li>
<li><tt>TIMEC</tt>: Time when the disk was created (-1 = not used,
0=now)</li>
<li><tt>DATEM</tt>: Date of the last modification to the catalog (-1 =
not used, 0=now)</li>
<li><tt>TIMEM</tt>: Time of the last modification to the catalog (-1 =
not used, 0=now)</li>
<li><tt>FLAGS</tt>: 1 = Protect disk, 2 = Encrypt disk, 4 = 720
sectors,
8 = 1440 sectors, 16 = Archive bit (reset when modified).</li>
<li><tt>RES</tt>: Reserved. </li>
<p><tt>INPUT </tt>automatically moves to the next record each time
it's
called so you can easily travel a sequential file, or a relative file
without
a <tt>REC </tt>clause, by just repetedly reading its records.</p>
<h4><br>
Modifying a floppy</h4>
<p>You can modify any of these parameters by writing back to the same
record.
The <tt>PRINT </tt>instruction always writes to the last record that
was
read (or searched for) and does not move to the next record. This was
done
so you can read records until you find the one you want and then modify
it. To write to the next record, you must first <tt>INPUT </tt>it,
then
write to it. Of course, if you are using a relative file with a <tt>REC
</tt>clause, the specified record is accessed.</p>
<p>The record structure is the same as described above. Any parameter
that
you omit or leave as 0 remains unchanged. To keep the same name, you
can
pass it as an empty string.</p>
<p><tt>PRINT&nbsp;#1, REC 12: "",356</tt></p>
<p>This changes the apparent disk size (as it appears on its catalog,
on
sector 0) to 356 sectors.</p>
<p>The one thing that you cannot change is the physical size of the
floppy
as determined by the flag bits, i.e. the amount of space it takes on
the
hard disk. If you really want to do this, you must delete the floppy
and
create another with the proper size. </p>
<h4><br>
<a name="Floppies rec 0"></a>Locating a floppy</h4>
<p>Rather than walking your floppy collection record by record to
locate
a given floppy, you can use record 0 to locate it. Just write the
desired
floppy name to record 0 and the next record that you access (to read or
write) will be that of the floppy. </p>
<p><tt>PRINT #1,&nbsp;REC 0: "MYDISK"</tt></p>
<p>If the name does not exist, a "file error" is issued. Searching
for an empty string jumps to the end of the file, so you can add new
floppies
to your collection. </p>
<p>You can also read back the record number corresponding to the
searched
floppy, from record 0. Be aware that doing so rewinds the file, so the
next record accessed will be record 1.</p>
<p><tt>INPUT #1, REC 0: A$,R </tt></p>
<p>or, for sequential files</p>
<p><tt>RESTORE #1<br>
INPUT&nbsp;#1:&nbsp;A$,R</tt></p>
<p>A$ will contain the string you passed with the <tt>PRINT&nbsp;</tt>statement
above (if any). R contains the record number that corresponds to this
floppy,
or 0 if the floppy wasn't found. </p>
<p>N.B. None of this can be done with the trash files.</p>
<h4><br>
Creating a new floppy</h4>
<p>To create a new floppy, move to the end of the file by passing an
empty
string to record 0 or by opening the file in <tt>APPEND </tt>mode.
Then
simply write a record with the required parameters: name, size, etc.
Actually,
only the name is required: all other parameters have default values
(360,-1,-1,-1,-1,0,0).
But the name must be unique: if another floppy with the same name
already
exists, nothing is created and a file error is issued. </p>
<p>CAUTION: every time you create, delete or rename a floppy, your
collection
is rearranged in alphabetical order. Thus, you should never assume that
a given record will access the same floppy after an addition/deletion
than
it did previously. In addition, as your collection grows, you may
notice
a delay of a few seconds, and a lot of disk activity while the
collection
is rearranged.</p>
<h4><br>
Deleting a floppy</h4>
<p>To remove a floppy from your collection, you can use opcode &gt;08
(scratch
record) from assembly, or just overwrite its record with an empty name
string AND&nbsp;a size of -1. Removed floppies are placed in a trash
file
(there are three of them, one per floppy size) so the space they
occupied
can be reclaimed next time you create a new floppy. Until this happens,
you have the possibility to recover deleted floppies from the trash.
You
also have the <a href="#user%20options">option</a> to configure IDEAL
1.0
so that it only recycles the trashed floppies once your hard drive is
full.</p>
<h4><br>
Recovering a deleted floppy</h4>
<p>A floppy that was erased by mistake can be recovered from the trash
by opening <tt>IDE.TRASHn</tt> where n is a number from "1" to
"3" and is used to access the trash files that respectively contains
the 360-, 720- and 1440-sector floppies. The file should be opened in
update
mode, as an Int/Fix file with a record size of 11 or more. It can be
either
sequential or relative.</p>
<p>To recover a floppy from the trash, you must first locate it. The
most
recently deleted floppy is in record 0, the oldest one at the end of
the
file: this is the one that will be recycled next. Each record consists
in only one string of at most 10 characters, which contains the name of
the deleted floppy.</p>
<p>Once you found the record containing your floppy, just write a new
name
(or the same one) to its record. This will automatically return the
floppy
in your collection, provided the disk name does not already exist in
the
collection, in which case a file error would be issued.</p>
<pre>90 REM Recover a 360-sector floppy named HERE-IT-IS<br>100 OPEN&nbsp;#1:"IDE.TRASH1", INTERNAL, FIXED 80, UPDATE, RELATIVE <br>110 I=-1<br>120 I=1+1<br>130 INPUT #1,REC I:NAME$<br>140 IF&nbsp;NAME$&lt;&gt;"HERE-IT-IS" THEN 120<br>150 REM we found it in record I. Let's recover it (with same name)<br>160 PRINT #1,REC I:NAME$<br>170 REM we could use ON ERROR in case the name already exists, to pick a different name<br>180 CLOSE #1</pre>
<p>You can also open the file as sequential: every read operation moves
forward to the next record. A write operation accesses the record that
was read last (or record 0 if the file was just open).</p>
<pre>90 REM Recover a 720-sector floppy named THAT-ONE<br>100 OPEN&nbsp;#1:"IDE.TRASH2", INTERNAL, FIXED 22, UPDATE, SEQUENTIAL<br>110 RESTORE #1<br>120 INPUT #1:NAME$<br>130 IF&nbsp;NAME$&lt;&gt;"THAT-ONE" THEN 120<br>130 REM we found it. Let's recover it with a different name.<br>140 PRINT #1:"NEWNAME"<br>150 CLOSE #1</pre>
<h2><br>
<a name="clock"></a>Clock access</h2>
<p>You can access the real-time clock onboard the IDE card by opening a
pseudo-file called CLOCK (by default, but you can change this name
while
configuring your system). It should be opened as internal, fixed 128 in
relative mode. You can then access the various clock functions through
specific records.</p>
<pre>100 OPEN #1:"CLOCK", INTERNAL, FIXED 128, RELATIVE</pre>
<p>Most variables can be modified by just writing the new values to the
appropriate record. Note that you must write all elements in a record,
even if you leave some unchanged. Illegal values are ignored, so it is
a convenient way to leave an element unchanged (alternatively, read it
first and write back what you read).</p>
<p>There is no need to close the file when done, but it won't hurt to
do
it:</p>
<pre>500 CLOSE #1</pre>
<h4>Record 0: Date</h4>
<pre>110 INPUT #1,REC 0:WEEKDAY,DAY,MONTH,YEAR1,YEAR2</pre>
<li><tt>WEEKDAY </tt>is the day-of-the-week. Sunday is 1, Monday is 2,
etc.</li>
<li><tt>DAY </tt>is the day-of-the-month</li>
<li><tt>MONTH </tt>is the month</li>
<li><tt>YEAR1 </tt>contains the first two digits of the year (e.g. 19
or
20).</li>
<li><tt>YEAR2 </tt>contains the last two digits of the year. For a
4-digit
date calculate <tt>(100*YEAR1)+YEAR2</tt>.</li>
<h4>Record 1: Time</h4>
<pre>120 INPUT #1, REC 1: HOURS,MINUTES,SECONDS,SETTINGS</pre>
<li><tt>HOURS </tt>contains the hour. In 24-hour mode, valid values
are
0 (midnight) to 23 (11 pm). In am/pm mode, valid values are 1 to 12
(am)
and 129 to 140 (pm). As you can see, pm hours are marked by adding 128
to the hour. When you set the time, make sure that the convention you
are
using is the one specified in <tt>SETTINGS</tt>, otherwise you may end
up with crazy values (e.g. 17 am).</li>
<li><tt>MINUTES </tt>Valid values are 0 to 59.</li>
<li><tt>SECONDS </tt>Valid values are 0 to 59.</li>
<li><tt>SETTINGS </tt>are the clock settings: 2=clock is in 24-hour
mode.
1=daylight savings mode enabled: the clock automatically gains an hour
at 2:00 am the first Sunday in April and looses it at 2:00 am the last
Sunday in October.</li>
<h4>Record 2: Alarm</h4>
<p>You can set one alarm that will occur every day at the same time.
Optionally,
you can make it an hourly alarm or even an alarm that occurs every
minute.
This is done by placing a "don't care" value in the appropriate
alarm register. To disable alarms, set a value of 60 for the seconds.</p>
<pre>130 INPUT #1,REC 2:HOUR,MINUTE,SECOND,INTF,ACTION,VECT,REC,SCRAD</pre>
<li><tt>HOUR </tt>is the hour at which the alarm must ring. The format
is the same as for <tt>HOURS </tt>in record 1, except that values 192
to
215 are also legal: they mean that the alarm should occur whatever hour
it is (i.e. bits &gt;C0 are set).</li>
<li><tt>MINUTE</tt> Legal values are 0 to 59. Values from 192 to 251
disregard
the minutes for alarm purposes.</li>
<li><tt>SECOND </tt>Legal values are 0 to 59. Values from 192 to 251
ignore
the seconds. To disable alarms completely just enter 60.</li>
<li><tt>INTF </tt>adds up the interrupt flags: 16=alarm interrupt
enabled,
8=an interrupt occured, 4=it was a periodic interrupt, 2=it was an
alarm,
1=there was an update (occurs every second). Only flag 16 can be
written
to, the others are automatically reset when accessing record 2.</li>
<li><tt>ACTION </tt>indicates the action to take when a periodic
interrupt
occurs. 0=do nothing. 128=enable drive sleeping, 1=blink screen,
2=beep,
4=display record, 8=call program.</li>
<li><tt>VECT is </tt>the address of a BLWP vector (workspace and
address)
where to branch at if the call program option is enabled. </li>
<li><tt>REC </tt>is the record number of the string you want to
display
(see record numbers below, only the first string is displayed).</li>
<li><tt>SCRAD </tt>is the screen address where to display the time or
date.
Add &gt;80 to add the Basic bias to every character, &gt;40 to prevent
this from happening. If you add neither, the charater at address <tt>SCRAD
  </tt>will be read and, if it is &gt;80 or greater, the Basic bias
will
be added to the string.</li>
<p>If your IDE&nbsp;card is built so, the clock can trigger TI-99/4A
interrupts,
either at defined intervals or when the alarm goes off. Of course,
interrupts
will only be effective if the program currently running has enabled
them
(with a LIMI 2 instruction). Basic and Extended Basic do so, but some
assembly
programs may not. </p>
<p>Reading INTF lets you know what happened, writing to it lets you
specify
which kind of interrupt is allowed. </p>
<p>Four actions can be taken when an alarm occurs: the screen can blink
3 times (this uses the copy of VDP register 1 stored at &gt;83D4), a
beep
can sound 3 times, the time or the date can be displayed on screen in
one
of the formats specified in records 4 and above, or a call can be made
to a program of yours. Any combination of these actions is allowed.</p>
<p>To display the time or the date, select the format desired from
those
described for the records below and use this record number for the <tt>REC
</tt>value. For instance, use 8 to display the time as "6:55 pm".
Tip: using records 100-227 accesses the clock RAM, which allows you to
display a preset message on screen. Just place the message (with a
leading
size byte) in the appropriate clock page by writing it to the
corresponding
record and puts this record number in <tt>REC</tt>. Be carefull not to
overwrite the bootstrap program in the first clock pages.</p>
<p>If you call a program it MUST&nbsp;be in memory when the interrupt
occurs,
otherwise the system will crash mercilessly. The program is entered
with
a BLWP after then interrupt service routine has returned. Once done,
you
can return to the interrupted program with a simple RTWP.</p>
<p>In addition, IDEAL uses alarms to put a drive to sleep after a given
period of inactivity. The sleep algorithm triggers an interrupt every
minute
and counts them until the specified number of minutes has elapsed. Any
disk operation resets the counter. If you are using the alarm for any
other
purpose, you should clear bit 128 in the <tt>ACTION </tt>word so as
not
to mess up the count (unless you happen to have set an alarm every
minute).
</p>
<p>Finally, turning the console off, then back on disables all
interrupts.
This was done so that the computer won't lock up if an interrupt fires
when IDEAL is not loaded to acknowledge it.</p>
<h4>Record 3: Periodic events</h4>
<p>You can cause the clock to repetedly trigger an event at defined
intervals,
that range from 122 microseconds to half a second. You can also issue a
square-wave signal on the corresponding pin on the IDE card. </p>
<pre>140 INPUT&nbsp;#1,REC3:PERIOD,INTS,ACTION,DATA</pre>
<li><tt>PERIOD </tt>is the delay between two interrupts, which is also
the frequency of the square-wave output. See the IDE page for <a
 href="ide.htm#square%20wave">legal
values</a>.</li>
<li><tt>INTS </tt>contains the control flags: 1=square-wave enabled,
8=periodic
interrupt enabled, 9=both.</li>
<li><tt>ACTION </tt>indicates the action to take when a periodic
interrupt
occurs. 0=do nothing. 128=enable drive sleeping, 1=blink screen,
2=beep,
4=call program.</li>
<li><tt>DATA </tt>the address of a BLWP vector (workspace and address)
where to branch at if the call program option is enabled.</li>
<p>The same actions as for an alarm interrupt can be specified.
However,
since the maximum interval is half a second, there is no point in
blinking
the screen, nor beeping when such an interrupt occurs. Most likely you
will only want to call a program at this point. Just be aware that
answering
an interrupt takes time. So if you set interrupts at too short a
period,
the computer will end up spending most of its time servicing interrupts!</p>
<h4>Record 4 to 7: Formatted date</h4>
<p>The next four records contains the date formatted in different ways
into text strings. These records cannot be written to.</p>
<pre>150 INPUT #1,REC 4:DATE$,DAY$</pre>
<li><tt>DATE$</tt> is in the form "12/25/99"</li>
<li><tt>DAY$</tt> is in the form "Mon"</li>
<pre>160 INPUT #1,REC 5:DATE$,DAY$</pre>
<li><tt>DATE$</tt> is in the form "Sep 4 96"</li>
<li><tt>DAY$</tt> is in the form "Wed"</li>
<pre>170 INPUT #1,REC 6:DATE$,DAY$</pre>
<li><tt>DATE$</tt> is in the form "October 1, 2000"</li>
<li><tt>DAY$</tt> is in the form "Friday"</li>
<pre>180 INPUT #1,REC 7:DATE$,YEAR$,DAY$</pre>
<li><tt>DATE$</tt> is in the form "January, the 3rd"</li>
<li><tt>YEAR$</tt> is in the form "1976"</li>
<li><tt>DAY$</tt> is in the form "Saturday"</li>
<h4>Record 8 to 11: Formatted time</h4>
<p>The next four records contains the time formatted in different ways
into text strings. These records cannot be written to.</p>
<pre>190 INPUT #1,REC 8:TIME$</pre>
<li><tt>TIME$</tt> is in the form "9:55 pm"</li>
<pre>200 INPUT #1,REC 9:TIME$</pre>
<li><tt>TIME$</tt> is in the form "11:23:06 am"</li>
<pre>210 INPUT #1,REC 10:TIME$</pre>
<li><tt>TIME$</tt> is in the form "13:45"</li>
<pre>220 INPUT #1,REC 11:TIME$</pre>
<li><tt>TIME$</tt> is in the form "17:25:00"</li>
<h4><br>
Record 12: RAM registers</h4>
<p>Most clock chips contain extra register that are available to the
user
as battery-backed RAM. PC computers save the so-called "CMOS setup"
in these. According to the chip, there may be a total of 64 or 128
registers
(the RTC-65271 has only 64), but is all cases registers 0 to 13 map to
clock functions.</p>
<p>You can get a dump of all clock registers by accessing record 12:</p>
<pre>230 INPUT #1,REC 12:R0TO63$,R64TO127$</pre>
<li><tt>R0TO63$</tt> is a 64-byte string that contains registers 0 to
63,
one character per register. See the IDE page for the meaning of
registers
0-13. Note that, if the first character (the seconds) is 59, the
content
of the clock registers may not be accurate because the clock may have
moved
to the next minute/hour/day/etc just after the seconds register was
read.</li>
<li><tt>R64TO127$</tt> is a 64-byte string that contains registers 64
to
127, if they exist. If your clock chip has only 64 registers, chances
are
that this string will have accessed the same registers as <tt>R0TO63$ </tt>(and
thus will be identical unless the seconds were incremented).</li>
<p>You can write to this record to place new values in the clock RAM
registers.
Registers 0 to 13 are reserved for clock registers, so the first 14
characters
of <tt>R0TO63$</tt> will be ignored. Register 14 is used by IDEAL to
store
the first two digits of the year (20), so make sure you leave this 15th
character intact. By contrast <tt>R64TO127$</tt> is copied entirely,
which
may result in modifying the clock registers if you have only 64
registers.
For this reason, you must always pass two strings when writing to
record
12: the second string should be empty unless you are sure you have a
clock
chip with more than 64 registers.</p>
<pre>240 A$=SEG$(R0TO63$,1,15)&amp;CHR(67)&amp;SEG$(R0TO63$,17,64)<br>250 PRINT&nbsp;#1, REC 12: A$,""</pre>
<p>This example puts the number 67 into register 15 (the 16th character
in the string) and leaves the other registers unchanged.</p>
<h4>Records 100 to 227: XRAM pages</h4>
<p>If your IDE card carries the RTC-65271 clock, you have an additional
4K of battery-backed RAM at your disposal. This memory is part of the
clock
chip and arranged as 128 pages of 32 bytes. You can access these pages
via records 100 to 227: the record number corresponds to the page
number
plus 100.</p>
<pre>300 INPUT #1, REC PAGE+100: A$</pre>
<li><tt>A$</tt> is a 32-byte string that contains the content of page <tt>PAGE</tt>.</li>
<p>You can also write to these pages, but be carefull as IDEAL reserves
the first pages for its own use (they contain the system configuration
and the boot sequence that loads IDEAL into the card SRAM). Before
writing
anything, check the fourth byte in page 0: it contains the number of
the
first free page (or zero if all pages are used). Feel free to update
this
byte as you reserve pages for your own use.</p>
<pre>310 INPUT #1, REC 100:A$<br>320 PAGE=ASC(SEG$(A$,4,1)<br>330 PRINT #1, REC PAGE+100:MYFIRSTPAGE$</pre>
<p>If the string you write is shorter than 32 bytes, the remainder of
the
page remains unchanged.</p>
<h2><br>
<a name="Configuration"></a>Configuring IDEAL 1.0</h2>
<p>IDEAL 1.0 has the capability to configure itself following your
instructions.
To this end, open the pseudo-file <tt>IDE.CONGIF</tt> as an <tt>INTERNAL,
VARIABLE&nbsp;128</tt> file. The various records provide access to the
multiple features of IDEAL 1.0.</p>
<pre>100 OPEN #1:"IDE.CONFIG",INTERNAL, FIXED 128, UPDATE, RELATIVE</pre>
<p>Alternatively, you can open it as Int/Fix 120, in which case all
numbers
will be passed as integers (or 32-bit long integers for LBAs). This is
usefull when working from assembly, so you don't have to deal with
floating
point numbers.</p>
<p>Technical note: actually, the file type is not checked, only the
record
size is. A record size of 128 or above uses floating point numbers, any
size under 128 uses integers. Basic stupidely prevents you to open
variable
files as relative, so you must either use <tt>FIXED</tt>, or open the
file
as <tt>SEQUENTIAL</tt>. There is no such limitation if you work from
assembly.</p>
<p>You can modify some of these values by writing to the desired
record.
Note that some records are read-only.</p>
<p>Once you are done, don't forget to close the file: it's at this
point
that the configuration is saved on disk. When you write to the file,
the
changes are only saved in the clock XRAM.</p>
<pre>500 CLOSE #1</pre>
<p>By the way, saving the configuration to the hard drive is something
that you may want to do from time to time, just is case the clock
battery
would run out... To this end, you must open <tt>IDE.CONFIG</tt>, write
to it at least once (e.g. to enter your password), the close it. <br>
</p>
<h4>Record 0</h4>
<pre>110 INPUT #1:PASSWORD$, LOCK, VERSION, PARTITION,&nbsp;VIRDRIVE </pre>
<li><tt>PASSWORD$</tt> is a password string that lets you write-protect
IDE.CONFIG so that a malicious program cannot fool around with your
system
settings. The password can be upto 32 characters in length, by default
it is "ThN" (my initials). For obvious reasons, <tt>PASSWORD$</tt>
is write-only and always reads as an empty string. </li>
<li><tt>LOCK </tt>is the lock status flag: if it is 0, you don't need
a
password to write to IDE.CONFIG (except to change <tt>PASSWORD </tt>and
  <tt>LOCK)</tt>. When <tt>LOCK </tt>is different from 0, you will
need to
write your password to record 0 before you can write to any other
record.
NB You don't need to change <tt>LOCK </tt>when doing so: the file is
temporarily
unlocked when you enter your password and will be relocked once you
close
it.</li>
<li><tt>VERSION</tt> Version number of IDEAL (Currently 1.0). Read only.</li>
<li><tt>PARTITION</tt> Current partition (currently, only partition 1
is
available). Read only.</li>
<li><tt>VIRDRIVE</tt> Current virtual drive. Read only.</li>
<p>To access a locked file, all you need to do is to write your
password
to record 0. The file is temporarily unlocked, until you close it. If
you
want to unlock it permanently, set <tt>LOCK </tt>as 0.</p>
<p>To change your password you must write twice to record 0: first
write
the <b>old</b> password and set <tt>LOCK </tt>as 1, then write the
new
password and set <tt>LOCK </tt>as you like.</p>
<h4>Record 1 through 4</h4>
<p>These records access the current directory in partitions 1 through
4.
Not implemented in version 1.0.</p>
<pre>110 INPUT #1:PATH$,DRIVENB,LBA</pre>
<li><tt>PATH$</tt> Path to the current directory in this partition.
Currently,
set as partition root (i.e. A.).</li>
<li><tt>DRIVENB</tt> Drive number through wich this partition can be
accessed
(currently &gt;61).</li>
<li><tt>LBA </tt>Address of the current directory in the partition.</li>
<h4>Record 5</h4>
<pre>110 INPUT #1,REC 5: SYSPATH$,MAXLBA,SLAVELBA,ROOTLBA,TOPLBA,SYSLBA</pre>
<li><tt>SYSPATH$</tt> Diskname and filename of the first system file
(e.g.
"<tt>DISKNAME.IDEAL/A</tt>").</li>
<li><tt>MAXLBA </tt>Last address that can be used by the floppy
collection
in the master drive.</li>
<li><tt>SLAVELBA </tt>Last address in the slave drive (if any).</li>
<li><tt>ROOTLBA </tt>Address of the virtual floppy disk collection
(floppy
at root of the tree). Read only.</li>
<li><tt>TOPLBA </tt>Current address reached by the floppy collection
(there
may be some empty slots in this space, if you deleted floppies). Read
only.</li>
<li><tt>SYSLBA</tt> Address of the virtual floppy containing the system
files. Read only.</li>
<p><tt>MAXLBA </tt>and <tt>SLAVELBA </tt>let you define the size of
your
master and slave drive respectively. This space will be available for
the
floppy disk collection. If you wanted to reserve space for other
purposes
on the drive, you could set either parameter to less than the actual
disk
size. If you have no slave drive, just set <tt>SLAVELBA </tt>as 0, so
that
the floppy collection won't be expanded on the slave drive once the
master
is full.</p>
<p><tt>TOPLBA</tt> and <tt>ROOTLBA&nbsp;</tt>are internal pointers to
your
floppy disk collection. They are automatically updated when you edit
the
collection.</p>
<p>With <tt>SYSPATH$</tt> you indicate the location of the IDEAL
system
files, so they can be loaded at power-up time. It must be in the form
of
a diskname, a dot, and the name of the first system file. When you
write
to <tt>SYSPATH$</tt>, the corresponding <tt>SYSLBA </tt>is
automatically
computed or a "file error" is issued if the disk does not exist
(but the presence of the system files on this disk is not verified). </p>
<h4>Record 6 through 9</h4>
<p>These records access the four partitions. Only partition 1 is
implemented
in IDEAL 1.0.</p>
<pre>110 INPUT #1: NAME$,DRIVENB,LBA,SIZE</pre>
<li><tt>NAME$</tt> Name of the DSR for the partition (Currently "A"
for partition 1).</li>
<li><tt>DRIVENB </tt>Drive number to access the partition from
subprograms
(Currently &gt;61 for partition 1).</li>
<li><tt>LBA </tt>Address of the partition.</li>
<li><tt>SIZE </tt>Size of the partition, in 512-byte sectors.</li>
<h4>Record 10 through 17</h4>
<p>These records access the virtual drives DSRs that emulate floppy
drives.</p>
<pre>110 INPUT #1:NAME$,DRIVENB,FLOPPYLBA</pre>
<li><tt>NAME$</tt> Name of the DSR for this drive (Normally <tt>DSK1 </tt>through
  <tt>DSK9 </tt>and <tt>DSKA </tt>through <tt>DSKZ</tt>).</li>
<li><tt>DRIVENB</tt> Drive number to access this drive from subprograms
(for <tt>DSKx</tt>, ascii of x minus &gt;30, e.g. <tt>DSK2</tt> =
&gt;02,
etc).</li>
<li><tt>FLOPPYLBA</tt> Hard disk address of the virtual floppy
"inserted"
in this drive (-1 if none).</li>
<h4>Record 18</h4>
<pre>200 INPUT #1:RTCNAME$</pre>
<li><tt>RTCNAME$</tt>: Name of the clock access DSR. By default "<tt>CLOCK</tt>".</li>
<h4><a name="Auto &amp; XB files"></a>Record 19</h4>
<pre>130 INPUT #1:FULLNAME$,ONOFF,XBFULLNAME$,CRU</pre>
<li><tt>FULLNAME$</tt>: Specifies which program is launched upon
power-up
(if any). It must be in the form <tt>DISKNAME.FILENAME</tt> (no
subdirectory
path). The file should be a "program" file, containing either
an assembly language program, an Extended Basic program (in which case
the Extended Basic cartridge should be plugged in, or loadable in a
GRAM-card),
or a GPL program (such as a cartridge) to be loaded in your GRAM-card.</li>
<li><tt>ONOFF</tt>: Determines whether the program will start
automatically
upon power up. 0=no, 1=yes, 2=load but don't start.</li>
<li><tt>XBFULLNAME$</tt>: Specifies the location of the Extended Basic
cartridge to be loaded in a GRAM-card. It must be the name of the first
file, in the form <tt>DISKNAME.FILENAME</tt>.</li>
<li><tt>CRU </tt>is the base CRU of your GRAM-card, if you have one. 0
stands for &gt;1000, 1 for &gt;1100, ... 15 for &gt;1F00.</li>
<p>The existance of <tt>FULLNAME$</tt> and <tt>XBFULLNAME$</tt> is
only
verified when they are actually used, so you won't get an error if you
enter the name of a file that does not exist (yet).</p>
<h4><a name="user options"></a>Record 20</h4>
<p>This record collects a whole bunch of options. To set one or more
options,
add up the values of the corresponding flags and pass the result in <tt>OPTIONS</tt>.
</p>
<pre>240 INPUT #1:OPTIONS, SLEEP, OPENED, MAXOPEN</pre>
<li><tt>OPTIONS</tt>: User preferences flags. Just add up the flag
values
of the desired options.</li>
<li><tt>SLEEP</tt>: Number of minutes of inactivity before the drives
go
to sleep (0=ignored).</li>
<li><tt>OPENED`</tt> Number of opened files allowed simultaneously
(just
like CALL FILES, but IDE-specific).</li>
<li><tt>MAXOPEN </tt>Maximum value for <tt>OPEN</tt>, depends on the
size
of the SRAM.</li>
<p><u>Option flags:<br>
</u>1 = Time-stamp virtual floppies.<br>
2 = Time-stamp files.<br>
4 = Allow sector-wise access.<br>
8 = Recycle deleted floppies to create new ones.<br>
16 = Wipe encryption key upon reset.<br>
32 = Allow only one Dis/Fix directory file per disk (the parent).<br>
64 = Do not delete Dis/Var directory files when target disk is deleted.<br>
128 = Do not allow modifications to the floppy collection (i.e.
write-protect
<tt>IDE.FLOPPIES</tt>).<br>
256= Put inactive drives to sleep.</p>
<p>512 = RAMBO mode not allowed (even if supported by the hardware).<br>
1024= Encryption not supported.<br>
2048= Floppy collection manager and trash manager not supported.<br>
4096= Configuration manager, extended catalog and sector-wise access
not
supported.<br>
8192= <tt>CLOCK </tt>DSR not supported (but time stamping still is).<br>
</p>
<p>Flags "1" through "128" are self explanatory and
have been discussed in the relevant sections anyhow.</p>
<p>By setting the "256" flag, you can cause the drives to be
put to sleep after a given number of minutes of inactivity. The number
of minutes can be set with the <tt>SLEEP </tt>value. The sleeping
algorithm
makes use of the clock alarm to trigger an interrupt every minute, and
decrease a counter. When the counter reaches zero, the "sleep"
command is sent to the drives. Accessing any DSR or CALL on the card
resets
the counter to the <tt>SLEEP </tt>value, thereby delaying the moment
to
put the drives to sleep. Once a drive is asleep it may take several
seconds
to wake up, so the next drive operation could appear hanged up, but
don't
worry: the command will complete as soon as the drive is ready. N.B.
Modifications
to this flag only become effective when you reset your TI-99/4A.</p>
<p>The flags "512" through "8192" let you disable some
parts of IDEAL, so that you can save memory or loading time, by using a
truncated version of IDEAL. I'd recommend that you use the full-fledge
version, but it's up to you.</p>
<h4>Record 21</h4>
<p>This record lets you access hardware information: it describes the
peculiarities
of your card, how you wired it, what is available, etc.</p>
<pre>250 INPUT #1:CONFIG,SRAM,RAMBO,REGBIT,SWBIT,FIXBIT,RAMBOBIT,WPBIT,RSTBIT,IRQBIT</pre>
<li><tt>CONFIG</tt>: Hardware configuration flags.</li>
<li><tt>SRAM</tt>: Size of the on-board SRAM.</li>
<li><tt>RAMBO</tt>: Number of available RAMBO banks (8 K each).</li>
<li><tt>REGBIT</tt>: CRU bit that selects register access (normally 1).</li>
<li><tt>SWBIT</tt>: CRU bit that enables bank switching. Negative if
active-low,
0 if none (normally 2).</li>
<li><tt>FIXBIT</tt>: CRU bit that freezes the area &gt;4000-4FFF to
bank
0. Negative if active-low, 0 if none (normally -3).</li>
<li><tt>RAMBOBIT</tt>: CRU bit that enable RAMBO mode. Negative if
active-low,
0 if none (normally 4).</li>
<li><tt>WPBIT</tt>: CRU bit that write-protects the SRAM. Negative if
active-low,
0 if none (normally 5).</li>
<li><tt>RSTBIT</tt>: CRU bit that resets the drives. Negated if
active-low,
0 if none (normally 7).</li>
<li><tt>IRQBIT</tt>: CRU bit that senses drive-issued interrupts.
Normally
0.</li>
<p>Configuration flags:<br>
1 = has battery-backed SRAM.<br>
2 = has XRAM in clock.<br>
4 = clock can send interrupts.<br>
8 = RAMBO mode supported by hardware.<br>
</p>
<h2><br>
<a name="Drive ID"></a>IDE controller configuration</h2>
<p>It is possible to query the IDE controller chip on both the master
and
the slave drive. The controller then returns a set of drive parameters
following a well-established convention. Just open <tt>IDE.MASTER</tt>
or <tt>IDE.SLAVE</tt> as an IV254 file:</p>
<pre>OPEN #1:"IDE.MASTER",INTERNAL,VARIABLE 254,INPUT</pre>
<p>Then you can read (but not modify) the drive parameters via the
following
records:</p>
<pre>INPUT #1,REC 0:CONFIG,CYL,RES1,HEADS,TRACKSIZE,SECSIZE,RES2,RES3,RES4</pre>
<li><tt>CONFIG</tt>: Configuration bits </li>
<li><tt>CYL</tt>: Number of physical cylinders (i.e. tracks)</li>
<li><tt>RES1</tt>: Reserved</li>
<li><tt>HEADS</tt>: Number of heads</li>
<li><tt>TRAKCSIZE</tt>: Number of unformatted bytes per physical track</li>
<li><tt>SECSIZE</tt>: Number of unformatted bytes per sector</li>
<li><tt>RES2</tt>, <tt>RES3</tt>, <tt>RES4</tt>: Reserved</li>
<p><u>Configuration bits</u>:<br>
2 = hard-sectored<br>
4 = soft-sectored<br>
8 = RLL/ARLL format<br>
16 = head switch 15 usec delay<br>
32 = power-down mode implemented<br>
64 = hard drive<br>
128 = removable drive (CD ROM)<br>
256 = transfer rate &lt; 5 Mbit/sec<br>
512 = transfer rate 5 to 10 Mbit/sec<br>
1024 = transfer rate &gt; 10 Mbits/sec<br>
2048 = rotation deviation &lt; 0.5% (notebook drives).</p>
<pre>INPUT #1,REC 1:SERIAL$,BUFTYPE,BUFSIZE,ECCSIZE</pre>
<li><tt>SERIAL$</tt>: Ascii string containing the drive's serial number.</li>
<li><tt>BUFTYPE</tt>: Buffer type. 1=one-way, 2=bidirectional, 3=cache
buffer.</li>
<li><tt>BUFSIZE</tt>: Buffer size in bytes, divided by 512.</li>
<li><tt>ECCSIZE</tt>: Number of ECC (error correction code) bytes
transfered
by read/write-long operations.</li>
<pre>INPUT #1,REC2:FIRMWARE$,MODEL$</pre>
<li><tt>FIRMWARE$</tt>: Ascii string containing the version number of
the
controller software.</li>
<li><tt>MODEL$</tt>: Ascii string containing the drive model.</li>
<pre>INPUT #1,REC3:SECPINT,IO32,DMALBA,RES5,PIOTIME,DMATIME,RES6</pre>
<li><tt>SECPINT</tt>: Number of sectors between interrupts (multiple
read/write
only).</li>
<li><tt>IO32</tt>: Flag bit. 1= 32-bit I/O.</li>
<li><tt>DMA/LBA</tt>: Flag bits. 256=DMA (direct memory access),
512=LBA
(logical block addressing).</li>
<li><tt>PIOTIME</tt>: I/O cycle time. 0=600 nanoseconds, 1=380 ns,
2=240
ns, 3=180 ns.</li>
<li><tt>DMATIME</tt>: DMA cycle time. 0=960 ns, 1=380 ns, 2=240 ns,
3=150
ns.</li>
<li><tt>RES5</tt>, <tt>RES6</tt>: Reserved.</li>
<pre>INPUT&nbsp;#1,REC4:LCYL,LHEADS,LTRACKSIZE,LSECSIZE,LSECPINT,LSECNB</pre>
<li><tt>LCYL</tt>: Number of logical cylinders.</li>
<li><tt>LHEADS</tt>: Number of logical heads.</li>
<li><tt>LTRACKSIZE</tt>: Number of logical sectors per logical track.</li>
<li><tt>LSECSIZE</tt>: Number of bytes per logical sector.</li>
<li><tt>LSECPTINT</tt>: Number of sectors between two interrupts.</li>
<li><tt>LSECNB</tt>: Total number of logical sectors addressable in LBA
mode.</li>
<p>NB. Modern drives can mimic more primitive drives and pretend they
have
a different geometry (cylinders, heads, etc) than their own. This is
called
address translation and it is why IDE&nbsp;drives should only be
formatted
in factory. This mechanism may cause the above parameters to vary
according
to your drive configuration.</p>
<pre>INPUT #1,REC5: SDMASUP,SDMA,MDMASUP,MDMA</pre>
<li><tt>SDMASUP</tt>: Single DMA modes suported.</li>
<li><tt>SDMA</tt>: Active single DMA&nbsp;mode.</li>
<li><tt>MDMASUP</tt>: Multiple DMA modes supported.</li>
<li><tt>MDMA</tt>: Active multiple DMA mode.</li>
<p>Irrelevant for our purpose: the IDE card does not support DMA.</p>
<p><br>
Records 6 to 9 return each 16 values corresponding to reserved
parameters.<br>
Records 10 and 11 return each 16 manufacturer-dependent values.<br>
Records 12 to 17 return each 16 values corresponding to reserved
parameters.</p>
<h2><br>
<br>
<a name="hard-drive access"></a>Direct access to the hard drives</h2>
<p>It is possible for you to access your hard drives directly, on a
sector-by-sector
basis. Just be aware that it is an extremely powerfull feature and that
you may end up completely scrambling the contents of your drives if you
don't know what you are doing. In fact, you have the option to disable
sector-wise access when configuring IDEAL, so that no malicious program
can play havoc with your drives.</p>
<p>To access your drives, open the file <tt>IDE.SECTORS</tt> as a <tt>INTERNAL</tt>,
<tt>FIXED 129 </tt>file.</p>
<pre>100 OPEN #1: "IDE.SECTORS", INTERNAL, FIXED 129,&nbsp;RELATIVE</pre>
<p>This is a pseudofile that contains only five records. Record 0 is
used
to set the sector number, and records 1 through 4 each contain a
128-byte
string corresponding to a quarter of the selected sector. Oh yes, I
forgot
to mention it, but hard drives have 512-byte sectors.</p>
<pre>110 PRINT #1, REC 0: LBA1,LBA2<br>120 INPUT #1: PART1$,PART2$,PART3$,PART4$</pre>
<p>Then you can write the strings back. The address won't change unless
you write a new one to record 0. (In case you forgot what it was, you
can
read it back from record 0).</p>
<pre>130 PRINT #1:PART1$,PART2$,PART3$,PART4$</pre>
<p>If one of the strings contains less than 128 bytes, or if you don't
write back all four strings, the remaining bytes in the sector are
unchanged.</p>
<p>You don't have to explicitely close this file, but it won't hurt
doing
it:</p>
<pre>200 CLOSE #1</pre>
<h4><br>
<br>
LBA addressing</h4>
<p>Nowadays, most hard drives use logical block addressing (LBA). Which
means that you can consider your drive as a huge array of 512-byte
sectors,
numbered from 0 to whatever your drive size allows. Addresses 0 through
268,435,455 are on the master drive, whereas addresses 268,435,456
through
536,870,912 are on the slave drive. In hexadecimal notations, these are
0 through &gt;0FFFFFFF and &gt;10000000 through &gt;1FFFFFFF. If you do
the math and multiply these numbers by 512 bytes, you'll find out that
you can access 128 megabytes per drive!</p>
<p>For your convenience, if you pass a negative number in LBA1 it will
be ignored and LBA2 is assumed to contain an address in the slave
drive,
to which the corresponding bias will be added (thus LBA2 should be in
the
range 0 to 268,435,455). If LBA1 is positive, LBA2 will be ignored.</p>
<p>Finally, if both LBA1 and LBA2 are negative, the address is bumped
up
to the next sector. This is usefull to walk the drive sector by sector:</p>
<pre>140 PRINT #1, REC 0:-1,-1</pre>
<p>When working from assembly, you can avoid dealing with floating
point
numbers and use long integers (32-bit words) instead. To this end, just
open the file as <tt>INTERNAL</tt>, <tt>FIXED 130</tt>. This tells
IDEAL
that all LBAs should be passed to and from record 0 as long integers.</p>
<h2><br>
<a name="DSRs"></a>DSRs</h2>
<p>IDEAL version 1.0 implements several DSRs :</p>
<ul>
  <li>Eight virtual drives that emulate TI drives. They can have any
name
upto 7 characters, but I'd suggest you stick with DSKx, where x is a
digit
from '1' to '9', or a letter from 'A' to 'Z'. This will make them fully
compatible with existing TI programs.</li>
  <li>Four partitions that will be used for full-disk access in a
future
version. Their default names are "A", "B", "C"
and "D" and they are meant to implement two partitions on the
master drive and two on the slave drive. Currently, only "A"
is used to hold your collection of virtual floppies (and you can't
access
it as a partition).</li>
  <li>A DSR called LD that will load any program file, whether
assembly,
Extended Basic or cartridge dump.</li>
  <li>A DSR named IDE, that lets you configure your drives or the
system
itself. It contains several pseudo-files:</li>
  <ul>
    <li><tt>IDE.MASTER</tt> queries the master drive (see <a
 href="#Drive%20ID">above</a>).</li>
    <li><tt>IDE.SLAVE</tt> queries the slave drive (see <a
 href="#Drive%20ID">above</a>).</li>
    <li><tt>IDE.CONFIG</tt>&nbsp;configures the system (see <a
 href="#Configuration">above</a>).</li>
    <li><tt>IDE.BLOWON</tt>, <tt>BLOWOFF</tt>, <tt>BLOWOUT </tt>and <tt>BLOWAWAY
      </tt>access the Blowfish encryption functions (see <a
 href="#Encryption">above</a>).</li>
    <li><tt>IDE.FLOPPIES</tt> accesses the floppy disk collection (see <a
 href="#Collection">above</a>).</li>
    <li><tt>IDE.TRASH1,</tt> <tt>TRASH2 </tt>and <tt>TRASH3 </tt>accesses
the
deleted floppies (see <a href="#Collection">above</a>).</li>
  </ul>
  <li>A clock DSR, named CLOCK (by default), that lets you access the
real-time
clock. You can read time and date, set alarms, etc. See <a
 href="#clock">above</a>
for a detailed description.</li>
</ul>
<p><a href="#DSKx">DSKx virtual drives<br>
</a><a href="#loaders">LD loader<br>
</a><a href="#autostart">Autostart feature<br>
</a><a href="#%3E0A">Opcode &gt;0A</a>: load assembly program<br>
<a href="#%3E0B">Opcode &gt;0B</a>: load Basic program<br>
<a href="#%3E0C">Opcode &gt;0C</a>: load cartridge</p>
<h4><a name="DSKx"></a>DSKx </h4>
<p>These DSRs emulate a floppy drive. Their names can be set with
IDE.CONFIG,
but should be kept in the range <tt>DSK1 - DSK9 </tt>and <tt>DSKA -
DSKZ</tt>.
As always with DSRs, parameters are passed via a <a
 href="../../headers.htm#PAB">PAB</a>
(peripheral access block) in VDP memory.</p>
<p>It is also possible to use the <tt>DSK.DISKNAME.FILENAME</tt>
syntax,
but this may not work if the TI disk controller is installed: this
stupid
controller returns an error if it does not find the disk in drives 1-3.
Thus <tt>DSK.DISKNAME</tt> only works properly when the IDE card is
called
before the TI disk controller, i.e. when its CRU is &gt;1000. </p>
<p>As a remedy to this unfortunate situation, an extra DSR called <b>DSK@</b>
is provided. It is completely equivalent to <tt>DSK </tt>and should
be
used in the same way: <tt>DSK@.DISKNAME.FILENAME</tt>. Since the TI
controller
does not contain <tt>DSK@ </tt>it won't interfer with the search. </p>
<p>An extra DSR called <b>DSK*</b> lets you access files on the same
drive
that was last used (by either a DSR or a call). This is usefull when a
program must load data files: by using the <tt>DSK*.FILENAME</tt>
syntax,
you ensure that the data files will always be loaded from the drive the
program was on.</p>
<p>The standard opcodes defined by Texas Instruments are all
implemented:</p>
<li>&gt;00 Open file</li>
<li>&gt;01 Close opened file</li>
<li>&gt;02 Read record from opened file</li>
<li>&gt;03 Write record to opened file</li>
<li>&gt;04 Rewind opened file to a given record</li>
<li>&gt;05 Load program file</li>
<li>&gt;06 Save program file</li>
<li>&gt;07 Delete file</li>
<li>&gt;08 Scratch record from file (NB this one did not work with the
TI controller. It does now)</li>
<li>&gt;09 Return file status.</li>
<p>Several improvements introduced with the Horizon Ramdisk have been
included:
</p>
<li>It is not necessary to specify the file type (DV80, IF254, etc)
with
  <tt>OPEN </tt>if the file already exists. If you do not specify a
record
length, the file type will be taken from disk, not from what you
specified.
Be aware that Basic wants at least one comma after the file name in the
  <tt>OPEN </tt>instruction.</li>
<li>Fixed files can now be opened in append mode: the number of the
next
record past the end of file will be placed in PAB+6. This will only
work
from assembly though, since Basic and Extended Basic are in the stupid
habit of reseting the record number to 0 after <tt>OPEN</tt>.</li>
<li>Adding &gt;40 to the opcode means that the data buffer specified at
PAB+2 is located in CPU memory, not in VDP RAM.</li>
<li>Opcode 8 (scratch record) works both for fixed and variable
records.
There is no way to call it from Basic unfortunately.</li>
<li>All opcodes return the file status in PAB+8, (only opcode &gt;09
did
it with the TI controller). If a device error occured (IO error code 6)
this byte should contain the error code read from the IDE error
register.
See my <a href="ide.htm#error%20codes">IDE page</a> for meanings.</li>
<p>In addition, the following extra opcodes were defined by the Horizon
Ramdisk, and are also supported by IDEAL:</p>
<li>&gt;0A Load <b>A</b>ssembly program</li>
<li>&gt;0B Load Extended <b>B</b>asic program</li>
<li>&gt;0C Load <b>C</b>artridge in a GRAM card</li>
<p>These serve to load and run a program. They are called automatically
by the LD DSR, but you can also use them from your assembly programs.</p>
<h3><a name="loaders"></a>The program loaders</h3>
<h4>The LD DSR</h4>
<p>The LD DSR can be used to automatically load and run an assembly
program,
in the form of one or more memory dump files in Editor/Assembler option
5 format. It can also trigger execution of an Extended Basic file, or
load
a cartridge into a GRAM device, using the GramKracker file format.
Remember
that this is a DSR (a device) not a subprogram, so the syntax is:</p>
<pre>DELETE "LD.n.filename"</pre>
<p><b><tt>DELETE </tt></b>is used here as an exemple. Actually, any
file
operation will do (e.g. <tt>OPEN</tt>, <tt>OLD</tt>, <tt>SAVE</tt>, <tt>RUN</tt>,
and <tt>DELETE</tt>). <br>
<b>n</b> is the drive number. If you did not name your drives following
the DSKn convention, n is the number you have assigned to the drive
plus
48 (the ascii code for '0').<br>
<b>filename</b> can be a simple file name, or a directory path ending
with
a filename: <tt>LD.3.DIR1.DIR2.DIR3.MYFILE</tt></p>
<p>Alternatively, you may use the disk name:</p>
<pre>RUN "LD.@.diskname.filename"</pre>
<p>The <b>@</b> sign in place of a drive number instructs LD to look
for
a vitual floppy in your collection (by analogy with <tt>DSK@</tt>).<br>
<b>diskname </b>is the name of the desired virtual floppy.<br>
<b>filename </b>is a simple file name or a full directory path.</p>
<h4><br>
<a name="autostart"></a>Autostart feature</h4>
<p>You have the option to automatically cause LD to load a given
program
at power-up time. The program name can be selected with IDE.CONFIG, or
with one the the subprograms HAO, HAF and HAB (respectively standing
for
<b>H</b>ard-drive <b>A</b>utostart <b>O</b>n, o<b>F</b>f and <b>B</b>oot).</p>
<pre>CALL HAO</pre>
<p>Toggles autostart on: each time you reboot your TI-99/4A the
selected
program will be called in place of the "Texas Instruments Home
Computer"
colorfull screen.</p>
<pre>CALL HAO.diskname.filename</pre>
<p>Same as above, but lets you change the file that should be called
when
booting. Note that you must specify a diskname (not a DSKn drive) and a
filename with no subdirectories inbetween.</p>
<pre>CALL HAF</pre>
<p>Toggles autostart off. Note that <tt>CALL HAF.diskname.filename</tt>
can also be used.</p>
<pre>CALL HAB</pre>
<p>Toggles autostart on for only one time: when you do a hard reboot
(i.e.
turn the PE box power off ). This is usefull if you want to load a
cartridge
in your GRAM card at power-up time: obviously, there is no need to
reload
it each time you press the &lt;quit&gt; key. On the other hand, if
power
is turned off, the cartridge will likely be wiped out of the GRAM card,
and you'll need to reload it. Since IDEAL will also be reloaded in such
a situation, it will automatically load your cartridge. </p>
<p>Here also, <tt>CALL HAB.diskname.filename</tt> is legal.</p>
<p>Note: the autostart file can also be set with the configuration
manager
(see <a href="#Auto%20&amp;%20XB%20files">above</a>).</p>
<h4><br>
<a name="&gt;0A"></a>Opcode &gt;0A. Load assembly program</h4>
<p>From assembly language, you have the option to use three special
opcodes
to load a file with any "DSKn" DSR.</p>
<p>Opcode &gt;0A loads a program file in EA5 format, i.e. that starts
with
a 6-byte header in the form:</p>
<p>&gt;0000: flag<br>
&gt;0001: bank<br>
&gt;0002: size<br>
&gt;0004: loading address</p>
<p>If <b>flag </b>is not &gt;00xx, loading continues with a file
having
the same name but for the last character that is incremented (e.g. <tt>MYFILE1
</tt>becomes <tt>MYFILE2</tt>). Execution normally starts at the
beginning
of the first file.<br>
<b>Bank </b>is used to load a program into the IDE card SRAM banks. It
should contain the bank number, plus 32 (because banks 1 through 31 are
reserved for GRAM cards). Note that, when execution begins, the last
bank
is on not the first one!<br>
<b>Size </b>specifies the number of bytes to load. It can be ignored,
depending
on the PAB (in which case the whole file is loaded).<br>
<b>Address </b>is the address where to load the program. It can be
superceeded
by the PAB.</p>
<p>Some parameters in the PAB have unusual meanings:</p>
<table border="1">
  <tbody>
    <tr>
      <th>&gt;0000</th>
      <td>&gt;0A</td>
      <td>&gt;00</td>
    </tr>
    <tr>
      <th>&gt;0002</th>
      <td colspan="2">Start address</td>
    </tr>
    <tr>
      <th>&gt;0004</th>
      <td colspan="2">(not used)</td>
    </tr>
    <tr>
      <th>&gt;0006</th>
      <td colspan="2">Loadable size</td>
    </tr>
    <tr>
      <th>&gt;0008</th>
      <td>(not used)</td>
      <td>Name size</td>
    </tr>
    <tr>
      <th>&gt;000A</th>
      <td colspan="2">DSKn.FILENAME</td>
    </tr>
  </tbody>
</table>
<p><b>PAB+0</b>: Contains the opcode (&gt;0A)<br>
<b>PAB+1</b>: Should be 0. Will contain error flags if an error occurs.<br>
<b>PAB+2</b>: Address where to start execution. &gt;0000: at the
beginning
of the first file. &gt;FFFF: load but don't execute.<br>
<b>PAB+6</b>: If this word contains 0 (or &gt;8000) no size checking
will
occur. Otherwise, the file will only be loaded if its size (as
specified
in the file FDR) is smaller or equal to this value. The &gt;8xxx bit
has
a special meaning: when set, the number of bytes is taken from <tt>SIZE</tt>,
the second word in the file. When the bit is reset, this word is
ignored
and the whole file is loaded.</p>
<h4><br>
<a name="&gt;0B"></a>Opcode &gt;0B. Load Extended Basic program</h4>
<p>This opcode only works if the Extended Basic cartrige is plugged in,
or is emulated by a GRAM-card. It launches Extended Basic and snoops on
it via a hook to the interrupt routine. When it sees that Extended
Basic
is about to load "<tt>DSK1.LOAD</tt>" it patches the filename
in memory and replaces it by the name of the program to be run. Nifty
isn't
it? (I whish I could claim this trick as mine, but it's lifted from the
Horizon Ramdisk ROS and they lifted it for someone else). </p>
<p>Note that execution cannot return to the caller once Extended Basic
is done.</p>
<p>If IDEAL does not find Extended Basic, but you have a GRAM card and
you have the Extended Basic cartridge stored somewhere on the hard
disk,
the program will load the cartridge into the GRAM card and the proceed
with launching the XB program. For this to happen however, you must use
IDE.CONFIG to declare the location of the XB cartridge (see <a
 href="#Auto%20&amp;%20XB%20files">above</a>).</p>
<p>Only a few bytes in the PAB are actually used with opcode &gt;0B:</p>
<table border="1">
  <tbody>
    <tr>
      <th>&gt;0000</th>
      <td>&gt;0B</td>
      <td>&gt;00</td>
    </tr>
    <tr>
      <th>&gt;0002</th>
      <td colspan="2">(not used)</td>
    </tr>
    <tr>
      <th>&gt;0004</th>
      <td colspan="2">(not used)</td>
    </tr>
    <tr>
      <th>&gt;0006</th>
      <td colspan="2">(not used)</td>
    </tr>
    <tr>
      <th>&gt;0008</th>
      <td>(not used)</td>
      <td>Name size</td>
    </tr>
    <tr>
      <th>&gt;000A</th>
      <td colspan="2">DSKn.FILENAME</td>
    </tr>
  </tbody>
</table>
<p>PAB+0: Contains the opcode (&gt;0B)<br>
PAB+1: Should be 0. Will contain error flags if an error occurs.</p>
<h4><br>
<a name="&gt;0C"></a>Opcode &gt;0C. Load cartridge.</h4>
<p>This opcode loads one or more program files into a GRAM device. The
files should follow the Gram-Kracker format, i.e start with a 6-byte
header
in the form:</p>
<p>&gt;0000: flag<br>
&gt;0001: bank<br>
&gt;0002: size<br>
&gt;0004: address<br>
&gt;0008: option</p>
<p>If <b>flag </b>is not &gt;00, loading continues with another file.
The
second file has the same name than the first one, with an extra "1".
For the following files, the "1" is incremented. So the sequence
would be: <tt>MYFILE</tt>, <tt>MYFILE1</tt>, <tt>MYFILE2</tt>, etc.<br>
<b>Bank </b>specifies the GRAM area into which the file should be
loaded.
Note that this information is redundant, since the address is already
part
of the header. Alternatively, bank can specify a page in the cartrige
RAM
space (&gt;6000-7FFF). Standard cartridges and GRAM cards have only two
RAM pages but the german GramKarte allows for 16. In general the lower
part (&gt;6000-6FFF) is identical in each bank, but there may be
exceptions...<br>
<b>Size </b>specifies the number of bytes to load.<br>
<b>Address </b>it the address (in GRAM or RAM) where to load the data.<br>
<b>option </b>corresponds to byte 4 in the GRAM, which is normally
zero.
If it contains &gt;A5 the GRAM device will be turned off after loading.
If it contains &gt;5A only the RAM banks in the GRAM card will be
turned
off after loading.</p>
<p>Here is a summary of the valid values for "bank":<br>
&gt;01: GRAM at &gt;6000 <br>
&gt;02: GRAM at &gt;8000<br>
&gt;03: GRAM at &gt;A000<br>
&gt;04: GRAM at &gt;C000<br>
&gt;05: GRAM at &gt;E000<br>
&gt;06: GRAM at &gt;0000 (caution: conflicts with console GROMs)<br>
&gt;07: GRAM at &gt;2000 (ditto)<br>
&gt;08: GRAM at &gt;4000 (ditto)<br>
&gt;09: RAM bank 1 (&gt;6000-7FFF)<br>
&gt;0A: RAM bank 2 (normally only &gt;7000-7FFF, but some device may
allow
&gt;6000-7FFF).<br>
&gt;0B: RAM bank 3 (only on some devices)<br>
etc.<br>
&gt;18: RAM bank 16</p>
<p>Some parameters in the PAB have a special meaning:</p>
<table border="1">
  <tbody>
    <tr>
      <th>&gt;0000</th>
      <td>&gt;0C</td>
      <td>&gt;00</td>
    </tr>
    <tr>
      <th>&gt;0002</th>
      <td colspan="2">GRAM base</td>
    </tr>
    <tr>
      <th>&gt;0004</th>
      <td colspan="2">(not used)</td>
    </tr>
    <tr>
      <th>&gt;0006</th>
      <td colspan="2">(not used)</td>
    </tr>
    <tr>
      <th>&gt;0008</th>
      <td>(not used)</td>
      <td>Name size</td>
    </tr>
    <tr>
      <th>&gt;000A</th>
      <td colspan="2">DSKn.FILENAME</td>
    </tr>
  </tbody>
</table>
<p>PAB+0: Contains the opcode (&gt;0C)<br>
PAB+1: Should be 0. Will contain error flags if an error occurs.<br>
PAB+2: If this word contains &gt;98xx, this value is used as a GRAM
base.
Otherwise, the current GRAM base stored at &gt;83FA is used. If
&gt;83FA
does not contain a valid &gt;98xx value, the default base &gt;9800 is
used.</p>
<h4><a name="Gcard routine"></a>Gram card-specific routines</h4>
<p>IDEAL 1.0 currently supports only the german 128K GramKarte and the
P-Gram+ card. IDEAL's gram-card management routines are all calling a
card-specific
subroutine, that resides in a separate file. For the German 128K
Gram-Karte,
rename <tt>IDEAL/GK</tt> as <tt>IDEAL/G</tt> (this is the default).
For
the P-Gram+ card, rename <tt>IDEAL/PG</tt> as <tt>IDEAL/G</tt>.</p>
<p>If you have another GRAM device than the above, you can write
yourself
a new version of this subroutine and IDEAL will use it to control your
device. This routine should be assembled as an AORG segment, to reside
at addresses &gt;5900-5B00. As it is called by a BLWP instruction the
first
two words (at &gt;5900 and &gt;5902) should be the workspace and the
routine
address. You can place your workspace in the same memory area, between
&gt;5904 and &gt;5B00. I would advise you to use the RAG linker to
generate
the final "program" file, since the TI loader cannot load a DF80
file at &gt;5900. Be aware that your routine will not be able to call
DSRs
or other routines in the gram-card ROM since these would conflict with
the IDE card DSR space.</p>
<p>The default gram-card CRU, as set with <tt>IDE.CONFIG,</tt> can be
retrieved
from the caller's R1 with a <tt>MOV @2(13),R12</tt> but this is
entirely
optional: you could "hard-wire" the CRU inside your code if you
want to (for instance if you have several gram-cards).</p>
<p>IDEAL will call your routine for various purposes. The reason for
the
call is found in the caller's R0, that you can retrieve with a <tt>MOV
*R13,R0</tt>. </p>
<ul>
  <li>If R0 is a positive number between &gt;00 and &gt;08, IDEAL is
about
to load data into GRAM memory. R0 is the number of the target GROM (see
"bank" above for valid values). Your routine should write-enable
the corresponding memory, The GROM port to be used (e.g. &gt;9800) can
be found in the caller's R8, i.e. at @16(R13). You can change it if
necessary,
but do not modify any other register in the caller's workspace. </li>
  <li>If R0 is &gt;09 or greater, IDEAL is about to load data into the
cartridge
RAM space, at &gt;6000-7FFF. R0 contains the bank number (&gt;09 =
first
bank, &gt;0A = second, etc). Your routine should switch on the
corresponding
bank, and write-enable it.</li>
  <li>If R0 is negative, IDEAL is done with loading and lets you decide
what
you want to do with your card. As a clue, the least significant byte of
R0 contains the fourth byte of the last GROM loaded that contained a
standard
header (i.e started with &gt;AA). The fourth byte is normally unused
(&gt;00)
but when creating a GRAM file you have the option to set it to a
special
value to specify loading options:</li>
  <ul>
    <li>If R0 is &gt;xxA5, the card should be turned off after loading.
    </li>
    <li>If R0 is &gt;xx5A, only the ROM banks should be turned off.</li>
  </ul>
</ul>
<p>Once done, you should return to the caller with a <tt>RTWP</tt>
instruction,
preceded with an <tt>INCT R14</tt>. Returning without modifying R14
signifies
IDEAL that the current file should not be loaded (of course, if they
are
more files to come, IDEAL will call again). For instance, since the
console
GROMs map at &gt;0000-57FF, you may want to reject any request to load
at these addresses. If, and only if, IDEAL was calling with &gt;FFxx in
R0, returning without <tt>INCT R14</tt> will cause a "file error".</p>
<p>Here is a sample Gram-card routine, that handles the German 128K
Gram
Karte:</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre>*====================================================<br>*  User-defined GRAM card routines for GramKarte<br>*  Common entry point, loading code in *R13<br>*----------------------------------------------------<br>* CRU bit   Meaning<br>* -------   --------<br>* Bit 0     1=DSR on<br>* Bit 1     1=banks on<br>* Bit 2     GRAM-enable 2<br>* Bit 3     0=GRAM on<br>* Bit 4     0=write-protect banks<br>* Bit 5     1=overwrite console GROMs<br>* Bit 6     1=use default bank (DIP-switch selected)<br>* Bit 7     0=switch banks 1=access banks<br>*====================================================<br>       AORG &gt;5900<br><br>GCARD  DATA WREGS,GKARTE      vectors (MUST be right here)<br>*<br>GKARTE INCT R14               always ok: skip JMP upon return<br>       MOV  @2(R13),R12       get default CRU <br>       MOV  *R13,R11          get loading code<br>       JLT  GKDONE            &gt;FFxx = done<br>       CI   R11,&gt;0008         check if RAM-bank or GRAM<br>       JH   GKBNK             bank<br><br>*&nbsp;Load in GRAM<br>       SBZ  3                 turn GRAM on<br>       CI   R11,&gt;0006         is it in console space ? <br>       JL   GK1               no<br>       SBO  5                 yes: override console GROMs<br>*      DECT R14               alternative: skip this file<br>GK1    RTWP <br><br>* Load in banks<br>GKBNK  SBZ  1                 bank read ok<br>       SBZ  4                 bank write-protected<br>       SBZ  6                 no default bank<br>       SBZ  7                 bank switching enabled<br>       AI   R11,-9            adjust bank #<br>       SLA  R11,1<br>       MOV  R11,@&gt;6000(R11)   switch<br>       SBO  7                 bank switching disabled<br>       SBO  4                 bank write-enabled<br>       RTWP <br><br>* Done with loading<br>GKDONE SB   R11,R11           keep only clue code<br>       CI   R11,&gt;00A5         code for "card off" <br>       JNE  GK2  <br>       SBO  1                 banks off<br>       SBO  3                 GRAM off<br>       SBZ  4                 write-protect banks<br>       SBZ  5                 console GROMs in charge<br>       RTWP <br><br>GK2    CI   R11,&gt;005A         code for "banks off"<br>       JNE  GK3<br>       SBO  1                 banks off<br>       SBZ  4                 and write-protected<br>       RTWP <br><br>GK3    SBZ  4                 "normal": write-protect banks <br>       SBZ  7                 enable switching<br>       RTWP <br>*<br>WREGS  BSS  32                our workspace<br><br>       END</pre>
      </td>
    </tr>
  </tbody>
</table>
<li>Assemble such a file with the TI assembler.</li>
<li>Link the resulting DF80 file with the RAG linker and name the final
program file IDEAL/G.</li>
<li>Edit IDEAL/G with a file editor like DISKU and change the first two
bytes from &gt;0000 to &gt;FF22.</li>
<li>Put it where all the other IDEAL/x files are.</li>
<h2><br>
<a name="Subprograms"></a>Subprograms</h2>
<p><b>Basic calls<br>
</b><a href="#WO&amp;WF">WO and WF<br>
</a><a href="#DN">DN<br>
</a><a href="#HAO+HAF+HAB">HAO, HAF, and HAB<br>
</a><a href="#CD">CD<br>
</a><b>Assembly callable subprograms<br>
</b><a href="#%3E10">&gt;10 Sector access<br>
</a><a href="#%3E11">&gt;11 Disk format<br>
</a><a href="#%3E12">&gt;12 File protection<br>
</a><a href="#%3E13">&gt;13 File rename<br>
</a><a href="#%3E14">&gt;14 Bulk read<br>
</a><a href="#%3E15">&gt;15 Bulk write<br>
</a><a href="#%3EB0">&gt;B0 Rambo manager<br>
</a><b>Others<br>
</b><a href="#Other%20subs">DSRs used as calls</a></p>
<h3><a name="Basic sub"></a>Basic subprograms</h3>
<p>There are several subprograms that are designed to be called from
Basic
or Extended Basic. You can also call them from assembly, just be aware
that the error code is returned in byte &gt;8342 and that they skip a
word
on return when no error occurs (<tt>INCT R11</tt>).</p>
<h4><a name="WO&amp;WF"></a>Write-protection</h4>
<p>Real floppy disks can be protected in two ways: by software, by
changing
the "DSK " string in sector 0 to "DSKP", or by hardware,
by blocking the write-protection notch with some opaque tape. The first
mechanism is ignored by the majority of disk managers, and virtual
floppies
obviously don't have any notch! Instead, IDEAL is using a special bit
in
sector 0 to indicate write-protected floppies. This bit can be set and
cleared with the <tt>IDE.FLOPPIES</tt> utility, or by accessing the
disk's
extended catalog.</p>
<p>When a floppy is "inserted" into a virtual drive, its protection
status is read by the drive and comes into effect. However, you have
the
option to temporarily override this status and set a different
protection,
just for this drive:</p>
<p><b><tt>CALL&nbsp;WO.n</tt></b> sets write protection on for drive n</p>
<p><b><tt>CALL&nbsp;WF.n</tt></b> turns write-protection off for drive
n</p>
<p>Note that this does not affect the write-protection status of the
floppy
in your collection, nor does it affect other drives that may be
accessing
the same floppy. (Yes, you can load the same floppy in several drives.
But this is quite risky if more than one of them is allowed to write to
it.) </p>
<p>Once you insert a new floppy in the drive, the protection status of
that floppy will come into effect. In other words, whatever command
arrives
last is the one that prevails.</p>
<h4><br>
<a name="DN"></a>Drive name</h4>
<p>Provided that a virtual drive obeys the DSKn naming convention, you
can change its number n with the following subprogram:</p>
<pre><b>CALL DN.o.n</b></pre>
<p>where o is the old drive number and n the new number (e.g. <tt>CALL&nbsp;DN.8.5</tt>
renames <tt>DSK8 </tt>as <tt>DSK5</tt>).</p>
<p>An error will occur if a drive with that number already exists in
the
IDE card, but IDEAL cannot check for the presence of such a drive in
the
floppy disk controller card, nor in a Ramdisk card. In case of
conflicting
drive names, the card with the lowest CRU address is the one who will
be
accessed.</p>
<h4><br>
<a name="HAO+HAF+HAB"></a>Autostart</h4>
<p>As described above, you can toggle the autostart feature on and off
the the following three subprograms:</p>
<p><b><tt>CALL HAO</tt></b> turns autostart on</p>
<p><b><tt>CALL HAF</tt></b> turns autostart off</p>
<p><b><tt>CALL HAB</tt></b> only autostarts at boot time (i.e. once,
after
power went off).</p>
<p>Either of these can also be used to change the program to be started
at power-up time:</p>
<pre>CALL HAO.diskname.filename</pre>
<p>The selected program may be an assembly program, an Extended Basic
program
(in which case the Extended Basic cartridge may be automatically loaded
in your GRAM card, if needed), or a cartridge. Note that cartridges are
loaded, but not executed, unless they contain a power-up routine, of a
foreign language translator.</p>
<h4><a name="CD"></a>Change disk</h4>
<p>As described previously, the CD subprogram can be used in several
manners
to change the virtual floppy accessed through a drive:</p>
<pre><tt>CALL CD.n..diskname</tt></pre>
<p>This will "insert" the virtual floppy named "diskname"
into drive <tt>DSKn</tt>. Note the double-dot syntax that signals a
disk
name.</p>
<pre><tt>CALL CD.n.directory</tt></pre>
<p>This will insert the disk pointed at by a directory file located on
the disk currently inserted in <tt>DSKn</tt>. This time, there is only
one dot after the drive number, which indicates a directory path.</p>
<p><tt>CALL CD.n.&lt;</tt></p>
<p>This will insert the parent of the current vitual floppy in DSKn. A
virtual floppy has a parent if at least one directory file points to
it.
If there is more than one, the first one you created is the parent
unless
you specified it otherwise. This allows you to organise your floppies
in
a tree-wise manner, as on a PC:</p>
<pre><b>DISK1<br></b>+-HERSTUFF-------&gt;<b>DISK5<br></b>|                 +-LETTER1<br>|                 +-LETTER2<br>|<br>+-MYDIR----------&gt;<b>MYDIR<br></b>+-OTHERFILE       +-GAMES-----&gt;<b>GAMES<br></b>                  |            +-CHESS<br>                  |            +-HANGMAN<br>                  |<br>                  +-NUDIES----&gt;<b>DISK4<br></b>                               +-CLAUDIA<br>                               +-ELLE<br>                               +-SOPHIE</pre>
<p>For example, assume the virtual floppy named <tt>GAMES</tt> is
currently
inserted in drive <tt>DSKZ</tt> and you want to access the file called
<tt>LETTER1.</tt> You could do something like:</p>
<pre>OPEN #1: "DSKZ.&lt;.&lt;.HERSTUFF.LETTER1", DISPLAY, VARIABLE 80</pre>
<p>Of course, you could also do it this way:</p>
<pre>OPEN #1: "DSK@.DISK5.LETTER1", DISPLAY, VARIABLE 80</pre>
<p>or this way:</p>
<pre>OPEN #1: "DSK@.DISK1.HERSTUFF.LETTER1", DISPLAY, VARIABLE 80</pre>
<h4><br>
<a name="Assembly subs"></a>Assembly subprograms</h4>
<p>The standard assembly level subprograms &gt;10 through &gt;16 are
provided.
A common extra feature is that you can add &gt;80 to the drive number,
to indicate that the data buffer is located in CPU memory instead of
VDP
memory.</p>
<h4><a name="&gt;10"></a>&gt;10 Sector I/O</h4>
<p>This subprogram reads or writes a sector from the disk to/from a
data
buffer that you provide. This buffer is normally in VDP memory, unless
you add &gt;80 to the drive number. The number of bytes transfered is
always
256.</p>
<p>Input parameters</p>
<table border="1">
  <tbody>
    <tr>
      <td>&gt;834A</td>
      <td colspan="2" width="80%">-</td>
    </tr>
    <tr>
      <td>&gt;834C</td>
      <td width="40%">Drive # </td>
      <td width="40%">0: write <br>
&lt;&gt;0: read</td>
    </tr>
    <tr>
      <td>&gt;834E</td>
      <td colspan="2" width="80%">Data buffer address</td>
    </tr>
    <tr>
      <td>&gt;8350</td>
      <td colspan="2" width="80%">Sector number</td>
    </tr>
  </tbody>
</table>
<p>Output parameters</p>
<table border="1">
  <tbody>
    <tr>
      <td>&gt;834A</td>
      <td colspan="2" width="80%">Sector number</td>
    </tr>
    <tr>
      <td>&gt;834C</td>
      <td width="40%">-</td>
      <td width="40%">-</td>
    </tr>
    <tr>
      <td>&gt;834E</td>
      <td colspan="2" width="80%">-</td>
    </tr>
    <tr>
      <td>&gt;8350</td>
      <td colspan="2" width="80%">Error code</td>
    </tr>
  </tbody>
</table>
<p><u>Technical notes</u></p>
<p>IDEAL stores some information at the end of sector 0 (bytes
&gt;EE-FF)
that is used to manage the floppy disk collection. Since these data are
critical for proper operation, subprogram &gt;10 does not let you
modify
them. </p>
<p>If you have set the time-stamping option while condiguring IDEAL,
bytes
&gt;14 through &gt;1B may be automatically modified upon writing sector
0. The current time and date are written to bytes &gt;18-1B (last
modification
stamp) unless bytes &gt;18-19 contain &gt;FFFF. If bytes &gt;14-15
contain
&gt;0000, the same values are also written to bytes &gt;14-17 (creation
stamp).</p>
<p><u>Encryption issues</u></p>
<p>Subprogram &gt;10 can tell whether sector 0 is encrypted or not, but
it cannot do it with other sectors. So it just assumes that, if
encryption
is on (<tt>DELETE "IDE.BLOWON"</tt>), the whole disk must be
encrypted: it decodes any sector you read and encodes anything you
write.
If that's not what you wanted, turn encryption off (e.g. <tt>DELETE
"IDE.BLOWOFF"</tt>).
</p>
<p>Additionally, if encryption is set with <tt>DELETE "IDE.BLOWOUT"</tt>,
subprogram &gt;10 will use encryption or not (both to read and write),
according to what was determined the last time sector 0 was read. This
lets you turn encryption on and off from within a disk manager: first
read
sector 0, then the sector you want to access. As it turns out, DISKU's
sector editor always reads sector 0 (to determine what the maximum
sector
number is) before it lets you edit another sector, so if you use DISKU
encryption is always turned on/off appropriately.</p>
<p>To sector-edit encrypted files on a non-encrypted disk, you will
need
to force encryption with <tt>DELETE&nbsp;"IDE.BLOWON"</tt>. This
will of course cause all non-crypted sectors of the disk (except
sectors
0+1) to appear scrambled.</p>
<p>If you try to access an encrypted disk (as determined by a flag in
sector
0) but no password has been entered yet, you will get a disk error. If
you have entered the wrong password, no error is issued but you'll read
only garbage. Note that, as long as you write back exactly what was
read,
no data will be lost. Problems only arise when you modify a sector and
save it with the wrong password.</p>
<ol>
  <p><br>
  </p>
</ol>
<h4><a name="&gt;11"></a>&gt;11 Format disk</h4>
<p>This subprogram will NOT&nbsp;format the hard-disk: IDE&nbsp;drives
are formatted in factory and should never be reformatted by the user
(it
may mess up the address translation mechanism). What subprogram &gt;11
does is simply to create a new virtual floppy and add it to your
collection..</p>
<p>Input parameters</p>
<table border="1">
  <tbody>
    <tr>
      <td>&gt;834A</td>
      <td colspan="2" width="80%">-</td>
    </tr>
    <tr>
      <td>&gt;834C</td>
      <td>Drive # </td>
      <td width="40%">&gt;A5 flag</td>
    </tr>
    <tr>
      <td>&gt;834E</td>
      <td colspan="2" width="80%">Diskname ptr</td>
    </tr>
    <tr>
      <td>&gt;8350</td>
      <td width="40%">Density (1/2)</td>
      <td># of sides (1/2)</td>
    </tr>
  </tbody>
</table>
<p><br>
Density (1 or 2) and number of sides (1 or 2) are combined so as to
choose
among 3 possible sizes:<br>
SS/SD: 360 sectors (90K)<br>
SS/DD and DS/SD: 720 sectors (180K)<br>
DS/DD: 1440 sectors (360K).</p>
<p>Byte &gt;834D should contain &gt;A5 if you wish to pass a diskname
in
the buffer pointed at by &gt;834E. The name must be exaclty 10
characters
in size, so pad the string with trailing spaces if necessary. If this
name
already exists in your floppy collection, a "file error" is issued.
If the first character in the name is not printable (ascii 33-127) the
filename is considered invalid and IDEAL will coin a dummy filename in
the form "!xxxx" where xxxx is an arbitrarily chosen hexadecimal
number. This also happens if the flag byte &gt;A5 is not found in
&gt;834D.
This is generally the case when you use the "format" command
of a disk manager: it creates a noname disk and then names it by
modifying
sector 0. </p>
<p>Output parameters</p>
<table border="1">
  <tbody>
    <tr>
      <td>&gt;834A</td>
      <td colspan="2" width="80%"># of sectors per disk</td>
    </tr>
    <tr>
      <td>&gt;834C</td>
      <td width="40%">-</td>
      <td width="40%">-</td>
    </tr>
    <tr>
      <td>&gt;834E</td>
      <td colspan="2" width="80%">-</td>
    </tr>
    <tr>
      <td>&gt;8350</td>
      <td colspan="2" width="80%">Error code</td>
    </tr>
  </tbody>
</table>
<p>If encryption is on (i.e. <tt>DELETE "IDE.BLOWON"</tt>) the
new disk will be automatically encrypted with the current password.
This
will not occur if encryption is set as "output-only" (i.e. <tt>DELETE
"IDE.BLOWOUT"</tt>).</p>
<p><br>
</p>
<h4><a name="&gt;12"></a>&gt;12 File protection</h4>
<p>This routine is used to modify the protection status of a file, i.e
whether the file can or cannot be deleted and modified.</p>
<p>Input parameters</p>
<table border="1">
  <tbody>
    <tr>
      <td>&gt;834C</td>
      <td width="40%">Drive #</td>
      <td width="40%">0: unprotected<br>
&gt;FF: protected</td>
    </tr>
    <tr>
      <td>&gt;834E</td>
      <td colspan="2" width="80%">Filename ptr </td>
    </tr>
    <tr>
      <td>&gt;8350</td>
      <td colspan="2" width="80%">-</td>
    </tr>
  </tbody>
</table>
<p>The filename must be a left-justified, 10-char string. Add as many
trailing
spaces as necessary.</p>
<p><br>
Output parameters</p>
<table border="1">
  <tbody>
    <tr>
      <td>&gt;834C</td>
      <td width="40%">-</td>
      <td width="40%">-</td>
    </tr>
    <tr>
      <td>&gt;834E</td>
      <td colspan="2" width="80%">-</td>
    </tr>
    <tr>
      <td>&gt;8350</td>
      <td colspan="2" width="80%">Error codes</td>
    </tr>
  </tbody>
</table>
<p><br>
</p>
<h4><a name="&gt;13"></a>&gt;13 Rename file</h4>
<p>This routine changes the name of a file on a given drive.</p>
<p>Input parameters</p>
<table border="1">
  <tbody>
    <tr>
      <td>&gt;834C</td>
      <td width="40%">Drive # </td>
      <td width="40%">-</td>
    </tr>
    <tr>
      <td>&gt;834E</td>
      <td colspan="2" width="80%">New name ptr </td>
    </tr>
    <tr>
      <td>&gt;8350</td>
      <td colspan="2" width="80%">Old name ptr </td>
    </tr>
  </tbody>
</table>
<p>Filenames must be 10 character strings, with as many trailing spaces
as necessary. Beware that no check is made to ensure that the new name
is a valid filename!</p>
<p><br>
Output parameters</p>
<table border="1">
  <tbody>
    <tr>
      <td>&gt;834C</td>
      <td width="40%">-</td>
      <td width="40%">-</td>
    </tr>
    <tr>
      <td>&gt;834E</td>
      <td colspan="2" width="80%">-</td>
    </tr>
    <tr>
      <td>&gt;8350</td>
      <td colspan="2" width="80%">Error codes</td>
    </tr>
  </tbody>
</table>
<p><br>
</p>
<h4><a name="&gt;14"></a>&gt;14 File input</h4>
<p>This routine reads data from a file sector-wise, irrespective of its
type, record length, etc. For instance, it can read a "program"
file by chunks of 256 or 512 bytes (or whatever size is convenient).</p>
<p>Input parameters</p>
<table border="1">
  <tbody>
    <tr>
      <td>&gt;834C</td>
      <td width="40%">Drive #</td>
      <td width="40%"># of sectors</td>
    </tr>
    <tr>
      <td>&gt;834E</td>
      <td colspan="2" width="80%">Filename ptr </td>
    </tr>
    <tr>
      <td>&gt;8350</td>
      <td width="40%">Info ptr (&gt;83xy)</td>
      <td width="40%">-</td>
    </tr>
  </tbody>
</table>
<p># of sectors: 0 = Get file info (fills the structure below, using
data
from the file's FDR)<br>
&lt;&gt;0 = Read this number of sectors (starting from the first sector
indicated in the structure below).</p>
<table border="1">
  <tbody>
    <tr>
      <td>&gt;83xy</td>
      <td colspan="2" width="80%">VDP buffer address</td>
    </tr>
    <tr>
      <td>+2</td>
      <td colspan="2" width="80%">First sector #</td>
    </tr>
    <tr>
      <td>+4</td>
      <td width="40%">File type</td>
      <td width="40%">Recs / sector</td>
    </tr>
    <tr>
      <td>+6</td>
      <td width="40%">EOF offset</td>
      <td width="40%">Rec lenght</td>
    </tr>
    <tr>
      <td>+8</td>
      <td width="40%"># of rec</td>
      <td width="40%">-</td>
    </tr>
  </tbody>
</table>
<p><br>
Output parameters</p>
<table border="1">
  <tbody>
    <tr>
      <td>&gt;834C</td>
      <td width="40%">-</td>
      <td width="40%"># of sectors read</td>
    </tr>
    <tr>
      <td>&gt;834E</td>
      <td colspan="2" width="80%">-</td>
    </tr>
    <tr>
      <td>&gt;8350</td>
      <td colspan="2" width="80%">Error codes</td>
    </tr>
  </tbody>
</table>
<p>Result of get file info (# of sectors=0):</p>
<table border="1">
  <tbody>
    <tr>
      <td>&gt;83xy</td>
      <td colspan="2" width="80%">-</td>
    </tr>
    <tr>
      <td>+2</td>
      <td colspan="2" width="80%">-</td>
    </tr>
    <tr>
      <td>+4</td>
      <td width="40%">File type</td>
      <td width="40%">Recs / sector</td>
    </tr>
    <tr>
      <td>+6</td>
      <td width="40%">EOF offset</td>
      <td width="40%">Rec lenght</td>
    </tr>
    <tr>
      <td>+8</td>
      <td width="40%"># of rec</td>
      <td width="40%">-</td>
    </tr>
  </tbody>
</table>
<h4><br>
<a name="&gt;15"></a>&gt;15 File output</h4>
<p>This routine writes data to a file sector-wise, irrespective of its
type, record length etc.</p>
<p>Input parameters</p>
<table border="1">
  <tbody>
    <tr>
      <td>&gt;834C</td>
      <td width="40%">Drive # </td>
      <td width="40%"># of sectors</td>
    </tr>
    <tr>
      <td>&gt;834E</td>
      <td colspan="2" width="80%">Filename ptr </td>
    </tr>
    <tr>
      <td>&gt;8350</td>
      <td width="40%">Info ptr (&gt;83xy)</td>
      <td width="40%">-</td>
    </tr>
  </tbody>
</table>
<p># of sectors: 0 = Create file (using info in the structure below to
create the FDR)<br>
&lt;&gt;0 = Write this number of sectors (from the first sector
indicated
in the structure below).</p>
<table border="1">
  <tbody>
    <tr>
      <td>&gt;83xy</td>
      <td colspan="2" width="80%">VDP buffer address</td>
    </tr>
    <tr>
      <td>+2</td>
      <td colspan="2" width="80%">First sector #</td>
    </tr>
    <tr>
      <td>+4</td>
      <td width="40%">File type</td>
      <td width="40%">Recs / sector</td>
    </tr>
    <tr>
      <td>+6</td>
      <td width="40%">EOF offset</td>
      <td width="40%">Rec lenght</td>
    </tr>
    <tr>
      <td>+8</td>
      <td width="40%"># of rec</td>
      <td width="40%">-</td>
    </tr>
  </tbody>
</table>
<p><br>
Output parameters</p>
<table border="1">
  <tbody>
    <tr>
      <td>&gt;834C</td>
      <td width="40%">-</td>
      <td width="40%"># of sectors writen </td>
    </tr>
    <tr>
      <td>&gt;834E</td>
      <td colspan="2" width="80%">-</td>
    </tr>
    <tr>
      <td>&gt;8350</td>
      <td colspan="2" width="80%">Error codes</td>
    </tr>
  </tbody>
</table>
<h4><br>
&gt;16 and FILES: Number of files </h4>
<p>With the TI floppy controlle, these two subprograms serve to change
the number of files that can be opened at a time. CALL FILES(n) is used
from Basic, and subprogram &gt;16 from assembly. This was necessary
because
the DSRs on the floppy controller card used VDP memory to buffer opened
files, and space is quite limited over there (that's where Basic
programs
and variables resides, among other things).</p>
<p>The IDE card has its own memory chip and uses it both to store the
DSR
and to buffer opened files. Therefore it is not necessary to constantly
jungle with VDP memory usage, and subprogram &gt;16 and FILES are not
implemented
in IDEAL.</p>
<p>There is a way to specify how many opened files you allow, when
configuring
your system with IDE.CONFIG. By default, this number is 15, so at any
given
time you can have upto 15 files opened on the hard-drive .The absolute
maximum value depends on the size of your SRAM.</p>
<h4><br>
<a name="&gt;B0"></a>&gt;B0 Rambo access</h4>
<p>This subprogram was introduced in the Horizon Ramdisk operating
system.
It allows access to Rambo banks, i.e. memory in the area &gt;6000-7FFF.
The subprogram actually consists in 3 subfunctions, selected by the
value
in &gt;834C.</p>
<h5>Page count</h5>
<table border="1">
  <tbody>
    <tr>
      <th>Word</th>
      <th>Input </th>
      <th>Output </th>
    </tr>
    <tr>
      <td>&gt;834A </td>
      <td>0</td>
      <td>Available pages</td>
    </tr>
    <tr>
      <td>&gt;834C</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <td>&gt;8350</td>
      <td>-</td>
      <td>0: ok<br>
-1: error</td>
    </tr>
  </tbody>
</table>
<p>Returns the total number of pages available in all Rambo devices.</p>
<p>Important note: if you have an Horizon Ramdisk and an IDE card, you
should run this subprogram first. It will let IDEAL bias the page
number
by whatever pages there are on the Ramdisk (e.g. if there are 100 pages
in the Ramdisk, page 101 is the first one in the IDE card).</p>
<h5><br>
Page selection</h5>
<table border="1">
  <tbody>
    <tr>
      <th>Word</th>
      <th>Input </th>
      <th>Output </th>
    </tr>
    <tr>
      <td>&gt;834A </td>
      <td>-</td>
      <td>CRU base</td>
    </tr>
    <tr>
      <td>&gt;834C</td>
      <td>Page # </td>
      <td>CRU value </td>
    </tr>
    <tr>
      <td>&gt;8350</td>
      <td>-</td>
      <td>0: ok<br>
-1: error</td>
    </tr>
  </tbody>
</table>
<p>Selects a given Rambo page. Returns the CRU of the Rambo device in
&gt;834A
and the CRU value used in &gt;834C. Note that Rambo pages are not
selected
by the CRU in the IDE card, so the value returned in &gt;834C can only
be used to turn Rambo mode on, NOT to switch pages: always use
subprogram
&gt;B0 for this.</p>
<h5>Rambo off</h5>
<table border="1">
  <tbody>
    <tr>
      <th>Word</th>
      <th>Input </th>
      <th>Output </th>
    </tr>
    <tr>
      <td>&gt;834A </td>
      <td>-</td>
      <td>-</td>
    </tr>
    <tr>
      <td>&gt;834C</td>
      <td>-1</td>
      <td>-1</td>
    </tr>
    <tr>
      <td>&gt;8350</td>
      <td>-</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
<p>Turns off Rambo mode.</p>
<h4><a name="Other subs"></a>DSRs used as subprograms</h4>
<ul>
  <li>The DSRs <tt>IDE.BLOWON</tt>, <tt>IDE.BLOWOFF</tt>, <tt>IDE.BLOWOUT</tt>
and <tt>IDE.BLOWAWAY</tt> can also be accessed as subprograms, for
instance
with a Basic <tt>CALL</tt>..</li>
  <li>So does the <tt>LD.filename</tt> loader device.</li>
  <li>Conversely, the <tt>CD </tt>subprogram can be called as a DSR.</li>
</ul>
<h2><br>
<a name="New format"></a>Modifications to the TI disk format</h2>
<p>As far as possible, I have tried to stick to the floppy disk format
established by Texas Instruments. However, I had to make a few
modifications
to allow for new features. They are summarized here.</p>
<h4>Sector 0</h4>
<p>This sector holds the disk directory just like with the TI format,
but
most of the reserved bytes have now been put to use. Bytes &gt;EE
through
&gt;FF are protected by IDEAL so they cannot be modified with a sector
editor.</p>
<pre><u>Bytes   Contents                                             <br></u>&gt;14-15: Time of creation.<br>&gt;16-17: Date of creation.<br>&gt;18-19: Time of last modification.<br>&gt;1A-1B: Date of last modification.</pre>
<pre>&gt;EE   : Flags (&gt;10=archive, &gt;02=encrypted, &gt;04=720 sectors, &gt;08=1440 sectors, &gt;20=protected).<br>&gt;EF   : Node balance (&gt;FF=heavy left, &gt;00=balanced, &gt;01=heavy right, &gt;80=deleted).<br>&gt;F0-F1: Number of items in the left subtree.<br>&gt;F2-F5: LBA of left subtree(&gt;0000 0000 if none).<br>&gt;F6-F9: LBA of right subtree.<br>&gt;FA-FD: LBA of parent directory.<br>&gt;FE-FF: Sector # for FDR of pointer file on parent directory.</pre>
<p>N.B. Sector 1 follows the TI format with no modification.</p>
<h4>File Descriptor Records (FDRs)</h4>
<p>There is one such sector for each file, that contains all the
relevant
file informations. These are the sectors listed in sector 1. The
following
modifications were introduced.</p>
<pre><u>Bytes   Contents                                             <br></u>&gt;0A   : Flags (&gt;10=acrchive bit, &gt;02=Encrypted, &gt;08=directory pointer).</pre>
<pre>&gt;14-15: Time of creation.<br>&gt;16-17: Date of creation.<br>&gt;18-19: Time of last modification.<br>&gt;1A-1B: Date of last modification.</pre>
<h4>Directory pointer files</h4>
<p>A directory pointer is nothing more than an empty file, consisting
of
only the FDR. It follows the new FDR format described above. There are
some extra modifications to allow chaining of all pointer files that
refer
to the same directory.</p>
<pre><u>Bytes   Contents                                             <br></u>&gt;20-23: LBA of the current disk (i.e. of sector 0).<br>&gt;24-27: LBA of sector 0 for previous link.<br>&gt;28-29: Sector number for previous link.<br>&gt;2A-2D: LBA of sector 0 for next link.<br>&gt;2E-2F: Sector number for next link.<br>&gt;30-31: Number &gt;0000 (used to detect when it's encrypted).</pre>
<address>Revision 1. 7/28/00. Preliminary, not for release.<br>
Revision 2. 5/28/01. Ok to release (about time!).<br>
Revision3. 8/25/01. Minor modifs to "Getting started".</address>
<ul>
  <center>
  <p><br>
  <a href="titechpages.htm">Back to the TI-99/4A Tech Pages</a></p>
  </center>
</ul>
</body>
</html>
