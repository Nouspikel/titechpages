<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
  <title>mm_mod</title>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <meta name="GENERATOR"
 content="Mozilla/3.04Gold (Win95; U) [Netscape]">
</head>
<body>
<h1 align="center"><a
 href="http://www.nouspikel.com/ti99/titechpages.htm"><img
 src="logo.jpg" style="border: 0px solid ; height: 33px; width: 95px;"
 title="Back to main index" alt=""></a></h1>
<h1><br>
The Mini-memory module</h1>
<p>The mini-memory is a fairly complex, and very usefull, cartridge. It
contains a &gt;1800 bytes GROM that maps at GROM address &gt;6000-77FF
in all GROM bases, a ROM chip that maps at &gt;6000-6FFF in CPU memory
and two static RAM chips that map at &gt;7000-7FFF in CPU memory. The
cartridge
contains a 3V lithium battery that powers the SRAM even when the
cartridge
is not plugged in: this way the information contained in the SRAM won't
disappear when power is shut down. </p>
<p>The software in GROM and ROM allows you to load and run DV80
assembly
language files in tagged-object code format, such as those produced by
the Editor/assembler cartridge. A fairly limited, line-by-line
assembler
is provided on a companion disk, and can be installed in the cartridge
SRAM which allows you to create simple assembly language programs.
Subprograms
in GROM provide support to load and run assembly program from Basic,
pretty
much like for the Editor/Assembler cartridge. </p>
<p>The GROM also contains a so-called debugger, named Easy-bug, and
written
entirely in GPL. However, it's more a memory editor (and a poor one at
it) than a debugger since it lacks the possibility to set execution
breakpoints
or to step through an assembly program. </p>
<p>Finally, the cartridge lets you use the SRAM or the memory expansion
card as a RamDisk that can contain upto three files. </p>
<p><b><a href="#Hardware">Hardware</a></b> </p>
<p><b><a href="#Software">Software</a></b> <br>
Programs <br>
<a href="#Programs">_Mini memory</a> <br>
<a href="#EasyBug">_Easybug</a> <br>
Subprograms <br>
<a href="#subprograms">_Init</a> <br>
<a href="#load">_Load</a> <br>
<a href="#LINK">_Link</a> <br>
<a href="#peek">_Peek</a> <br>
<a href="#peekv">_Peekv</a> <br>
<a href="#pokev">_Pokev</a> <br>
<a href="#charpat">_Charpat</a> <br>
DSRs <br>
<a href="#DSRs">_Minimem, Memexp1, Memexp2</a> <br>
<a href="#Checking%20memory">_Checking memory usage</a> <br>
<a href="#DSR%20&amp;%20INIT">_DSRs and CALL INIT</a> <br>
<a href="#Bug">_The EXPMEM1 bug</a> <br>
&nbsp; <br>
&nbsp; </p>
<h2><a name="Hardware"></a>Hardware</h2>
<p>The cartridge consists in 6 chips: </p>
<li>a 6K GROM (labelled 8231 in my cartridge),</li>
<li>a 4K ROM (labelled 8234),</li>
<li>two 2K SRAM 6116 chips mounted in piggy back (i.e. on top of each
other,
with only the CE* pins connected differently),</li>
<li>a 72LS322 quad OR gate and</li>
<li>a 74LS04 hex inverter for the ROM/SRAM selection logic.</li>
<p>In addition, it contains a 3 volts CR2430 lithium battery, with a
3904
NPN and a 3906 PNP transistors (and several diodes) to handle the
switching
of the SRAM power supply between the console power and the backup
battery.
</p>
<p>Here's an <a href="mm_board.htm">annotated picture</a>.</p>
<p>And the schematics:&nbsp; </p>
<table cellspacing="2" cellpadding="2" bgcolor="#cccce6">
  <tbody>
    <tr>
      <td>
      <pre>&nbsp; Litium battery&nbsp;&nbsp;&nbsp;&nbsp; diode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp; | +3V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4148<br>Gnd--||---+-----------|&gt;|--+---------------------------------,<br>&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; '---|&gt;|---,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; diode&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |/&nbsp; 3906&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; 6116 SRAM (x2)<br>&nbsp;&nbsp; ,---+-----www----+-----|&nbsp;&nbsp; PNP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; +-------+<br>&nbsp;&nbsp; |&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1K&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |\&nbsp; transitor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Gnd---||-----+---|Vcc&nbsp;&nbsp;&nbsp; |+<br>&nbsp;&nbsp; |&nbsp;&nbsp; |&nbsp;&nbsp; 3904&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WE*&gt;---|WE* A10||---&lt;A5<br>&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; \| NPN&nbsp;&nbsp;&nbsp; 5.1K&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DBIN&gt;-----|&gt;o-----------|OE*&nbsp; A9||---&lt;A6<br>&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |---+----www------+----+5V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 74LS04&nbsp;&nbsp;&nbsp; D0&gt;---|D7&nbsp;&nbsp; A8||---&lt;A7<br>&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; /|&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D1&gt;---|D6&nbsp;&nbsp; A7||---&lt;A8<br>&nbsp;&nbsp; |&nbsp;&nbsp; v&nbsp;&nbsp;&nbsp;&nbsp; '--www--Gnd&nbsp;&nbsp; =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D2&gt;---|D5&nbsp;&nbsp; A6||---&lt;A9<br>&nbsp;&nbsp; |&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1K&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3&gt;---|D4&nbsp;&nbsp; A5||---&lt;A10<br>&nbsp;&nbsp; |&nbsp; Gnd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Gnd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D4&gt;---|D3&nbsp;&nbsp; A4||---&lt;A11<br>&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.3K&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D5&gt;---|D2&nbsp;&nbsp; A3||---&lt;A12<br>&nbsp;&nbsp; '-----------------------------------+---www------,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D6&gt;---|D1&nbsp;&nbsp; A2||---&lt;A13<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '---www---,&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D7&gt;---|D0&nbsp;&nbsp; A1||---&lt;A14<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '04&nbsp;&nbsp;&nbsp; '32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3.3K&nbsp; |&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; A0||---&lt;A15<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; A4&gt;---+---|&gt;o--,==)&gt;---|&gt;|---+--|--+------------|CE*&nbsp;&nbsp;&nbsp; ||<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+|<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '04&nbsp;&nbsp;&nbsp; '32 |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; +5V---||---'&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ,------|CE*&nbsp;&nbsp;&nbsp; |<br>A3&gt;------+--|&gt;o--,==)&gt;-|--------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 221&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4148&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br>ROMG*&gt;---|-------+&nbsp;&nbsp;&nbsp;&nbsp; '--------'==)&gt;---|&gt;|------+---------'<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | '32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Vdd (-5V)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '-------'==)&gt;------,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +5V---||---'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8234 ROM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 221 ??&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +---www---&lt;RESET*<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; 100 Ohm<br>&nbsp;A8&gt;---|1&nbsp;&nbsp;&nbsp; 24|----+5V&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; =<br>&nbsp;A9&gt;---|2&nbsp;&nbsp;&nbsp; 23|----&lt;A7&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8231 GROM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |<br>A10&gt;---|3&nbsp;&nbsp;&nbsp; 22|----&lt;A6&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Gnd<br>A11&gt;---|4&nbsp;&nbsp;&nbsp; 21|----+5V&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D7&gt;---|1&nbsp;&nbsp;&nbsp; 16|----Gnd&nbsp;<br>A12&gt;---|5&nbsp;&nbsp;&nbsp; 20|------------'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D6&gt;---|2&nbsp;&nbsp;&nbsp; 15|----&lt;GR<br>A13&gt;---|6&nbsp;&nbsp;&nbsp; 19|----&lt;A5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D5&gt;---|3&nbsp;&nbsp;&nbsp; 14|----Vdd(-5V)<br>A14&gt;---|7&nbsp;&nbsp;&nbsp; 18|----&lt;A4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D4&gt;---|4&nbsp;&nbsp;&nbsp; 13|----&lt;GRC<br>A15&gt;---|8&nbsp;&nbsp;&nbsp; 17|----&lt;D0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D3&gt;---|5&nbsp;&nbsp;&nbsp; 12|----&lt;DBIN<br>&nbsp;D7&gt;---|9&nbsp;&nbsp;&nbsp; 16|----&lt;D1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D2&gt;---|6&nbsp;&nbsp;&nbsp; 11|----&lt;A14&nbsp;<br>&nbsp;D6&gt;---|10&nbsp;&nbsp; 15|----&lt;D2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D1&gt;---|7&nbsp;&nbsp;&nbsp; 10|----&lt;GS*<br>&nbsp;D5&gt;---|11&nbsp;&nbsp; 14|----&lt;D3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; D0&gt;---|8&nbsp;&nbsp;&nbsp;&nbsp; 9|----+5V&nbsp;<br>&nbsp;Gnd---|12&nbsp;&nbsp; 13|----&lt;D4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</pre>
      </td>
    </tr>
  </tbody>
</table>
<h4>GROM wiring</h4>
<p>The GROM wiring is fairly straighforward as all the necessary
signals
are provided by the console through the cartridge port: <b>D0-D7</b>
make
up the data bus, that also serves to set (or retrieve) the GROM address
pointer. <br>
<b>GS*</b> is active (low) when a CPU address in the range
&gt;9800-9FFF
is accessed: it indicates a GROM port access. <br>
<b>A14</b> serves as an address/data selector: &gt;98x0 is the data
port
and &gt;98x2 is the address port. <br>
<b>DBIN</b> is used to determine whether a byte should be read or
written
to the GROM (obviously, only addresses can be written). Note that
address
line A5 is not needed to differentiate read operations (port &gt;98xx)
from write operations (port &gt;9Cxx): this is taken care of by the
console
when generating the GS* signal. <br>
<b>GRC</b> is the GROM clock, generated by the TMS9918a videoprocessor
color burst. <br>
<b>GR</b> is an active high signal indicating that the GROM is ready.
When
low, it puts the CPU on hold until the GROM is ready. </p>
<h4><br>
ROM wiring</h4>
<p>Here also, the wiring is straighforward: the cartridge port supplies
a ROMG* signals that is active (low) when an address in the range
&gt;6000-7FFF
is accessed. An OR gate is used to combine this signal with A3 (weight
&gt;1000) so that the ROM is active in the range &gt;6000-6FFF. <br>
<b>D0-D7</b> make up the data bus <br>
<b>A4-A15</b> make up the address bus (12 bits, i.e. &gt;1000 bytes). </p>
<h4><br>
SRAM wiring</h4>
<p><b>D7-D0</b> are connected to the data bus lines D0-D7. Note the
inverse
nomenclature: TI considers D0 as the most significant bit, whereas
almost
everyone else considers it as the least significant byte. <br>
<b>A10-A0</b> are connected to the address bus A5-A15, providing an
address
space of 11 bits, i.e. &gt;0800 bytes. Here also, the nomenclature is
reversed.
<br>
<b>WE*</b> is used to determine whether the memory access is a read or
a write operation. <br>
<b>OE*</b> enables the data outputs for read operations. It is
controlled
by the inverted DBIN line. <br>
The <b>CE*</b> connection is the only one which is not wired in the
same
way on both chips. It is used to determine whether a chip answers to
addresses
in the range &gt;7000-77FF or to addresses in the range &gt;7800-7FFF.
But the selection logic is further complicated by the fact that both
pins
should be held high when no power is present, so that the SRAMs don't
use
up the battery trying to output data when the cartridge is not plugged
in! </p>
<h4><br>
SRAM selection logic</h4>
<p>The ROMG* line from the cartridge port signals a memory access in
the
range &gt;6000-7FFF. It is combined with the inverted address line A3,
via an OR gate, to select the range &gt;7000-7FFF. This selection
signal
is further combined with address line A4 (weight &gt;0800) inverted or
not, so as to provide two chip selection signals: one for the range
&gt;7000-77FF
(piggy-backed chip) and one for the range &gt;7800-7FFF (basal chip).
I'm
not sure what's the function of the capacitors that connect the CE*
pins
to Vcc. In fact, I'm not even sure these are indeed caps, they wear
five
color bands: red-red-brown-silver-silver. Any insight? </p>
<h4><br>
Power selection</h4>
<p>The two transistors and the associated diodes and resistors are used
to select the type of power supply. </p>
<p>When the cartridge is not plugged in, or when it's plugged into a
console
that's turned off, the battery supplies +3V to the SRAM Vcc pins via a
diode. Another diode holds the basis of the 3906 PNP transistor at +3V,
which blocks the transistor. The same +3V are applied to the CE*
selection
pins of the two SRAM chips via a 1K resistor and two 3.3K resistors
(one
for each chip): this ensures that the chips won't output data when no
power
is present. Two diodes are used to prevent these +3V from flowing back
to the selection logic. </p>
<p>When the cartridge receives power from the console, +5V are applied
to the basis of the 3904 NPN transistor via a 5.1K resistor, which
makes
it passing. As a result, the basis of the 3906 PNP transistor is now
grounded
through a 1K resistor and the NPN transistor. The +5V current can thus
flow through the PNP transistor to the SRAMs Vcc pins (and that's why a
diode was placed in the battery circuit: we don't want these +5V to
flow
back to the battery). </p>
<p>In addition, the 3904 NPN transitor also grounds the two CE*
selection
pins, via the 3.3K resistors. These resistance values are chosen so
that
the selection logic (i.e. the OR gates) can easily drive the CE* pins
high
or low. </p>
<h4><br>
Additional circuitery</h4>
<p>The RESET connection in the cartridge port is connected via a 100
Ohm
resistor to the Vdd power supply and grounded through a capacitor. When
the cartridge is plugged in, the RESET line is briefly grounded until
the
capacitor is charged. This sends a reset signal to the TIM9904 clock
generator,
which in turns resets the TMS9900 microprocessor, the VDP and the
TMS9901.
In other words, inserting the cartridge resets the TI-99/4A. </p>
<p>Finally, by-pass capacitors are installed to filter statics by
connecting
the Vcc pin of each chip to the ground. These caps are labelled 104,
which
I suppose means that they are 10,000 pF. On the above schematic, only
the
one for the SRAM chips has been drawn. </p>
<h2><br>
<a name="Software"></a>Software</h2>
<p>The GROM has a standard header which contains: </p>
<li>Two programs (MINI MEMORY and EASYBUG),</li>
<li>Three <a href="#DSRs">DSRs</a> (MINIMEM, EXPMEM1 and EXPMEM2),</li>
<li>Seven subprograms (<a href="#subprograms">INIT</a>, <a href="#load">LOAD</a>,
  <a href="#LINK">LINK</a>, <a href="#peek">PEEK</a>, <a href="#peekv">PEEKV</a>,
  <a href="#pokev">POKEV</a> and <a href="#charpat">CHARPAT</a>).</li>
<p>You'll find a commented disassembly listing of the GROM in these
three
files: <a href="mmg.txt">mmg.txt</a> (main menu, DSRs and
subprograms),
<a href="mmg2.txt">mmg2.txt</a> (CHARPAT, options 1-3 of the main menu,
subroutines for internal use), and <a href="mmg3.txt">mmg3.txt</a>
(Easybug).
</p>
<p>For a commented disassembly of the ROM, look in the files <a
 href="mmr.txt">mmr.txt</a>
(loader and other assembly subprograms), and <a href="mmr2.txt">mmr2.txt</a>
(subprograms dealing with Basic). </p>
<h2><a name="Programs"></a>Mini memory program</h2>
<h3>Initialization</h3>
<p>When entered, the program loads the built-in character sets from the
console GROM: </p>
<li>small upper-case chars 32-95 at VDP address &gt;0900-0AFF,</li>
<li>lower-case characters 96-127 at VPD address &gt;0B00-0BF7,</li>
<li>empty chars 0-31 at VDP address &gt;0800-08FF, except for:</li>
<li>copyright character (10) at address &gt;0850-0857,</li>
<li>editor cursor (a solid 8x3 pixels vertical bar) at address
&gt;08F0-08F7
(i.e. char 30),</li>
<li>module cursor (an empty 6x6 square) at address &gt;08F8-08FF (i.e.
char 31).</li>
<p>For some reason, provision is made to load a different set of
characters,
possibly corresponding to another console version: the distinction is
made
by scanning the keyboard with keyboard type 5. If the type is not
changed
to 0 by the scanning routine, characters &gt;32-95 will be loaded at
addresses
&gt;0A00-0BFF in VDP memory, then characters 64-95 are modified by
adding
a small 2-pixel dash in their upper left corner. I have no idea what
this
is meant for, the TI-99/4 may be? </p>
<p>The VDP registers are then set with the following values: </p>
<p>R1=E0 Standard mode <br>
R2=00 Screen image at &gt;0000 <br>
R3=0E Color table at &gt;0380 <br>
R4=01 Char pattern table at &gt;0800 <br>
R5=06 Sprite attribute table at &gt;0300 <br>
R6=00 Sprite pattern table at &gt;0000 (not the same as char pats!) <br>
R7=F5 White on light blue </p>
<h3><br>
<a name="Main menu"></a>Main menu</h3>
<table border="2" cellspacing="2" cellpadding="2" bgcolor="#1822cd">
  <tbody>
    <tr>
      <td>
      <pre><font color="#ffffff">&nbsp;<br>&nbsp;* MINI MEMORY *&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;PRESS:<br>&nbsp; 1 TO LOAD AND RUN<br>&nbsp; 2&nbsp;&nbsp;&nbsp; RUN<br>&nbsp; 3&nbsp;&nbsp;&nbsp; RE-INITIALIZE<br><br><br><br>&nbsp; c)1981&nbsp; TEXAS INSTRUMENTS</font></pre>
      </td>
    </tr>
  </tbody>
</table>
<p><a href="#Option%201">Option 1</a> is used to load an assembly file
in
tagged-object code, it enters option 2 when done. <br>
<a href="#Option%202">Option 2</a> is used to run a program loaded in
memory
with option 1. <br>
<a href="#Option%203">Option 3</a> is used to reinitialise the SRAM,
i.e.
to reset the flags and pointers necessary for option 1. <br>
Fctn-9 resets the TI-99/4A. </p>
<h3><br>
<a name="Option 1"></a>1. Load and run</h3>
<table border="2" cellspacing="2" cellpadding="2" bgcolor="#1822cd">
  <tbody>
    <tr>
      <td>
      <pre><font color="#ffffff">&nbsp;<br>&nbsp;* LOAD AND RUN *&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp; FILE NAME?<br>&nbsp;</font><font
 color="#5dbaca"> user input (multiple)<br></font><font color="#ffffff">&nbsp; PROGRAM NAME?<br>&nbsp; </font><font
 color="#5dbaca">user input</font>



      </pre>
      </td>
    </tr>
  </tbody>
</table>
<p>Option 1 first checks whether the loading pointers were initialised,
by looking for a flag value of &gt;A55A at address &gt;7000. If that's
not the case, the pointers are initialised now. The user is then
prompted
for one or more filenames. These must be Dis/Fix 80 files that contain
tagged-object code. Such files are produced by the assembler in the
Editor/Assembler
cartridge for instance. The program prepares a PAB for the file at
address
&gt;1000 in VDP memory, with a data buffer area located at &gt;1080. It
then issues a XML &gt;71 instruction to call a loader located in the
cartridge
ROM (vector in &gt;6012). This is the very same loader than the one in
the Editor/Assembler cartridge, with one exception: it can handle three
different loading areas: the cartridge RAM, the low memory expansion
and
the high memory expansion. The loading order is: cartridge first, then
high-memory, then low-memory. </p>
<p>The symbol table for labels DEFined or REFerenced by the loaded file
is located at the end of the cartridge RAM, but there also is a table
of
<a href="#Predefined%20symbols">predefined labels</a> at the end of the
ROM,
addresses &gt;6F0E-6FFF. It contains the same labels than the editor
assembler
cartridge, but the standard assembly routine are located in the
cartridge
ROM instead of the low memory expansion. </p>
<p>The loader can return with an error by setting the Cnd bit in the
GPL
status byte and placing the error code in byte &gt;8322. The module
will
then issue an error message and (in most cases) re-enter the
load-and-run
menu. </p>
<p>If all went OK, the user is prompted for another filename, just as
above.
The loader is then called again and the whole process repeats until the
user enters an empty filename, at which point the program moves
automatically
to option 2. </p>
<h3><br>
<a name="Option 2"></a>2. Run</h3>
<table border="2" cellspacing="2" cellpadding="2" bgcolor="#1822cd">
  <tbody>
    <tr>
      <td>
      <pre><font color="#ffffff">&nbsp; * RUN *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br><br><br>&nbsp; PROGRAM NAME?<br>&nbsp;</font><font
 color="#5dbaca"> user input<br><br><br><br><br></font><font
 color="#ffffff">&nbsp;&nbsp;</font></pre>
      </td>
    </tr>
  </tbody>
</table>
<p>This menu can either be entered from the main menu, which displays
the
" <tt>* RUN * </tt>" title, or from the "load-and-run"
menu, after the user entered an empty filename. </p>
<p>The user is prompted for a 6-character program name. This must
correspond
to an assembly label, i.e. contain only upper-case letters and digits,
the first character cannot be a digit. This label should be present in
the symbol table, either because it's part of the pre-defined table or
because it was placed here by the loader (as a result of an
assembly-language
DEF statement). It is legal to enter an empty program name, in which
case
the last run program will be re-entered (if any). </p>
<p>The module checks for a flag value of &gt;A55A in word &gt;2000,
indicating
that the standard assembly language routines were dumped from the GROM.
If the value is not found, a "<tt>PROGRAM NOT FOUND</tt>" error
is issued. </p>
<p>Then the module sets up the VDP for the program to be executed: the
color table is filled with &gt;13 bytes (black on light green), the
screen
is erased, and VDP register 7 is set as &gt;F3 (white on light green).
Finally, the linker is entered via an XML &gt;70 (i.e. vector in
&gt;6010).
Upon return, the Cnd bit in the GPL status byte will cause an error
message,
if it's set. The error code is taken from byte &gt;8322, that was
cleared
before calling the linker. Otherwise, the VDP setup of the module is
restored,
and the message ""<tt>PRESS ENTER TO CONTINUE</tt>" is displayed
at the bottom of the screen. </p>
<p>When the user presses &lt;enter&gt; the program returns to the main
menu. Note however that nothing is erased in memory, so the user can
select
option 4 again and run another program, or the same one. To run the
same
program again, the user can just enter an empty program name. </p>
<h3><br>
<a name="Option 3"></a>3. Initialize memory</h3>
<table border="2" cellspacing="2" cellpadding="2" bgcolor="#1822cd">
  <tbody>
    <tr>
      <td>
      <pre><font color="#ffffff">&nbsp; * INITIALIZE MEMORY *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br><br>&nbsp; MEMORY ALREADY INITIALIZED<br>&nbsp; HIT "PROC'D" TO CONFIRM<br>&nbsp;</font><font
 color="#5dbaca">&nbsp;<br><br><br><br><br></font><font color="#ffffff">&nbsp;&nbsp;</font></pre>
      </td>
    </tr>
  </tbody>
</table>
<p>This options first checks for the presence of a &gt;A55A flag at
address
&gt;7000. If it was found, the SRAM was already initialized and there
may
even be a program loaded in it. The program therefore asks the user for
confirmation: pressing Fctn-6 resets the loading pointers, installs the
flag, and wipes out the rest of the SRAM. Any other key returns to the
main menu without any changes. </p>
<p>If the flag is not detected (or if Fctn-6 is pressed), the program
first
clears the whole SRAM range (&gt;7000-7FFF), then tests for the
presence
of a memory expansion card by writting and reading back address
&gt;A000.
It then sets the loading pointers accordingly at addresses
&gt;7022-702D
(or only &gt;701C-701F if no memory expansion is present). </p>
<h4><br>
<a name="RAM usage"></a>Cartridge RAM usage</h4>
<pre><u>Address Initially Usage&nbsp;<br></u>&gt;7000&nbsp;&nbsp; &gt;A55A&nbsp;&nbsp;&nbsp;&nbsp; Flag: loader pointers were initialised<br>&gt;7002-7011&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Used by CALL LINK to store parameter types</pre>
<pre>&gt;701C&nbsp;&nbsp; &gt;7118&nbsp;&nbsp;&nbsp;&nbsp; First free address in cartridge RAM: FSTMOD<br>&gt;701E&nbsp;&nbsp; &gt;8000&nbsp;&nbsp;&nbsp;&nbsp; Last free address in cartridge RAM: LSTMOD(bottom of symbol table)<br>&gt;7020&nbsp;&nbsp; &gt;0000&nbsp;&nbsp;&nbsp;&nbsp; Previous program address<br>&gt;7022&nbsp;&nbsp; &gt;A000&nbsp;&nbsp;&nbsp;&nbsp; First free address in high memory: FSTHI<br>&gt;7024&nbsp;&nbsp; &gt;FFE0&nbsp;&nbsp;&nbsp;&nbsp; Last free address in high memory: LSTHI<br>&gt;7026&nbsp;&nbsp; &gt;2000&nbsp;&nbsp;&nbsp;&nbsp; First free address in low memory: FSTLOW<br>&gt;7028&nbsp;&nbsp; &gt;3FFF&nbsp;&nbsp;&nbsp;&nbsp; Last free address in low memory: LSTLOW<br>&gt;702A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Checksum calculated by the loader for each record<br>&gt;702C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Used by LOADER to save the PAB pointer<br>&gt;702E&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Used by linker to save its return address<br>&gt;7030&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CRU address where DSR was found (set by DSRLNK, used by loader)<br>&gt;7032&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DSR address in card ROM (used by LOADER to speed up file operations)<br>&gt;7034&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DSR name size (copy of &gt;8354)<br>&gt;7036&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DSR name ptr (copy of &gt;8356)<br>&gt;7038&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Number of DSR occurences found (copy of GPL R1)</pre>
<pre>&gt;708A-7091&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Buffer for DSR name (for quick comparison by DSRLNK)<br>&gt;7092-70B1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Workspace for most standard assembly routines<br>&gt;70B8-70C7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; User-workspace upon program entry (return address in R11)<br>&gt;70D8-70F7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Workspace for the linking-loader<br>&gt;70F8-7117&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Workspace for Basic-handling subroutines</pre>
<h4><br>
<a name="Predefined symbols"></a>Pre-defined symbol table
(&gt;6F0E-6FFF)</h4>
<pre><u>Label&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Value&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Usage&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br></u>'UTLTAB'&nbsp;&nbsp;&nbsp; &gt;7020&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Utility table for loader<br>'PAD&nbsp;&nbsp; '&nbsp;&nbsp;&nbsp; &gt;8300&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Scratch-pad memory&nbsp;<br>'GPLWS '&nbsp;&nbsp;&nbsp; &gt;83E0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GPL workspace&nbsp;<br>'SOUND '&nbsp;&nbsp;&nbsp; &gt;8400&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Soud port<br>'VDPRD '&nbsp;&nbsp;&nbsp; &gt;8800&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VDP read-data port<br>'VDPSTA'&nbsp;&nbsp;&nbsp; &gt;8802&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VDP status-read port<br>'VDPWD '&nbsp;&nbsp;&nbsp; &gt;8C00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VDP write-data port<br>'VDPWA '&nbsp;&nbsp;&nbsp; &gt;8C02&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VDP write-address port<br>'SPCHRD'&nbsp;&nbsp;&nbsp; &gt;9000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Speech synthesizer read-data port<br>'SPCHWT'&nbsp;&nbsp;&nbsp; &gt;9400&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Speech synthesizer write-data port<br>'GRMRD '&nbsp;&nbsp;&nbsp; &gt;9800&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GRAM/GROM read-data port<br>'GRMRA '&nbsp;&nbsp;&nbsp; &gt;9802&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GRAM/GROM read-address port<br>'GRMWD '&nbsp;&nbsp;&nbsp; &gt;9C00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GRAM write-data port<br>'GRMWA '&nbsp;&nbsp;&nbsp; &gt;9C02&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GRAM/GROM write-address port<br>'SCAN&nbsp; '&nbsp;&nbsp;&nbsp; &gt;000E&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Keyboard scanning routine in console ROM<br>'XMLLNK'&nbsp;&nbsp;&nbsp; &gt;601C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Subroutines to call an XML from assembly (in cartridge ROM, WS &gt;7092)<br>'KSCAN '&nbsp;&nbsp;&nbsp; &gt;6020&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Subroutine to call the SCAN subroutine (in cartridge ROM, WS &gt;7092)<br>'VSBW&nbsp; '&nbsp;&nbsp;&nbsp; &gt;6024&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VDP single byte write subroutine (workspace &gt;7092)<br>'VMBW&nbsp; '&nbsp;&nbsp;&nbsp; &gt;6028&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VDP multiple bytes write subroutine (workspace &gt;7092)<br>'VSBR&nbsp; '&nbsp;&nbsp;&nbsp; &gt;602C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VDP single byte read subroutine (workspace &gt;7092)<br>'VMBR&nbsp; '&nbsp;&nbsp;&nbsp; &gt;6030&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VDP multiple bytes read subroutine (workspace &gt;7092)<br>'VWTR&nbsp; '&nbsp;&nbsp;&nbsp; &gt;6034&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; VDP write to register subroutine (workspace &gt;7092)<br>'DSRLNK'&nbsp;&nbsp;&nbsp; &gt;6038&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Subroutine to call a DSR or a subprogram (workspace &gt;7098)<br>'LOADER'&nbsp;&nbsp;&nbsp; &gt;603C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Tagged-object code files loader (workspace &gt;70D8)<br>'GPLLNK'&nbsp;&nbsp;&nbsp; &gt;6018&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Subroutine to call a GPL subroutine from assembly (workspace &gt;7092)<br>'NUMASG'&nbsp;&nbsp;&nbsp; &gt;6040&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Subroutine to assing a value to a Basic numeric variable (WS &gt;70F8)<br>'NUMREF'&nbsp;&nbsp;&nbsp; &gt;6044&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Subroutine to get the value of a Basic numeric variable/constant<br>'STRASG'&nbsp;&nbsp;&nbsp; &gt;6048&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Subroutine to assing a value to a Basic string variable<br>'STRREF'&nbsp;&nbsp;&nbsp; &gt;604C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Subroutine to get the value of a Basic string variable/constant<br>'ERR&nbsp;&nbsp; '&nbsp;&nbsp;&nbsp; &gt;6050&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Subroutine to re-enter Basic with an error message</pre>
<h2><br>
<br>
<a name="EasyBug"></a>EasyBug program</h2>
<p>EasyBug is a fairly primitive debugger, written entirely in GPL
(apart
for a few lines of assembly) that can therefore be run from the
cartridge
GROM without affecting the program it is supposed to debug. Its main
drawback
is that it does not easily allow to set breakpoints, nor to execute a
program
step by step. In fact, it is a line-by-line memory editor than a
debugger...
</p>
<p>Upon entry, EasyBug loads the patterns for upper case characters 32
to 96 at VDP address &gt;0900. It then display the following help
screen
and waits for the user to press a key. <br>
&nbsp; </p>
<table border="2" cellspacing="2" cellpadding="2" bgcolor="#80ff80">
  <tbody>
    <tr>
      <td>
      <pre><tt><font color="#400040">&nbsp;<b><font size="-1">&nbsp;&nbsp; ===COMMAND TYPES ARE===&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;<br>&nbsp;</font></b></font></tt><b><font
 color="#400040"><font size="-1">&nbsp; MXXXX&nbsp; MODIFY&nbsp; CPU&nbsp; MEMORY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp; GXXXX&nbsp; DISPLAY GROM MEMORY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp; VXXXX&nbsp; MODIFY&nbsp; VDP&nbsp; MEMORY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br><tt>&nbsp;&nbsp; EXXXX&nbsp; EXEC ASSEMBLY PROGRAM&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp; CXXXX&nbsp; CRU SINGLE BIT I/O&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp; SXXXX&nbsp; SAVE CPU MEMORY TO CS1&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (STARTING AT XXXX)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp; L&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOAD STORAGE FROM CS1&nbsp;&nbsp;&nbsp;<br>&nbsp;<br>&nbsp;&nbsp; ==SPECIAL FUNCTION KEYS ARE==&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp; 'AID'&nbsp;&nbsp;&nbsp; DISPLAY THIS SCREEN&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp; PERIOD&nbsp;&nbsp; ABORT A COMMAND&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp; ENTER&nbsp;&nbsp;&nbsp; ENTER COMMAND/DATA&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp; MINUS&nbsp;&nbsp;&nbsp; DISPLAY LAST MEMORY&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (CURRENT UNCHANGED)&nbsp;&nbsp;<br>&nbsp;&nbsp; SPACE&nbsp;&nbsp;&nbsp; DISPLAY NEXT MEMORY&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (CURRENT UNCHANGED)&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp; *NOTE* CPU RAM 8370-83FF IS&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RESERVED FOR EASYBUG&nbsp;&nbsp;</tt></font></font></b></pre>
      </td>
    </tr>
  </tbody>
</table>
<p>Once a key is pressed, easybug clears the screen, displays a
question
mark on the last line and waits for a command. No cursor is displayed.
</p>
<p>To enter a command, the user must type one of the following keys: <br>
<a href="#M%20command">M</a> to edit CPU memory, <br>
<a href="#V%20command">V</a> to edit VDP memory, <br>
<a href="#G%20command">G</a> to read GROM memory, <br>
<a href="#C%20command">C</a> to read and write CRU bits, <br>
<a href="#S%20command">S</a> to save CPU memory on tape, <br>
<a href="#L%20command">L</a> to load the content of a tape file in CPU
memory,
<br>
<a href="#E%20command">E</a> to execute an assembly program (in CPU
memory),
<br>
Fctn-7 (Aid) to display the help screen, <br>
Fctn= (Quit) to leave EasyBug and reset the TI-99/4A. </p>
<p>Most commands must be followed by an hexadecimal address. Valid keys
to enter an address are 0 through 9, A through F, &lt;enter&gt; that
starts
the command and the decimal point that aborts it and returns to command
mode. There is no backspake key available, but if you make a mistake
you
can just keep typing: only the last 4 digits will be considered. </p>
<h4><br>
<br>
<a name="M command"></a>The M command</h4>
<p>This commands is used to display and edit CPU memory (obviously, ROM
memory cannot be edited). Easybug displays the address, an equal sign,
and the content of this address as an hexadecimal byte. An arrow
follows,
after which you can enter a new value for that byte. </p>
<p>To move to the next address, press the spacebar. Any value you may
have
entered is ignored. <br>
To move to the previous one, press the minus key. Any value you may
have
entered is ignored. <br>
To abort the command and return to the command line, press the decimal
point. <br>
To abort the command and go back to the help screen, press the &lt; key
(why not Fctn-7, I have no idea). </p>
<p>To modify the content of a memory address, enter an hexadecimal byte
and press &lt;enter&gt;. Valid digits are 0 through 9 and A through F.
Just as above, no backspace key is provided but errors can be
"corrected"
by just typing the correct value again: only the last 2 digits are
considered.
Pressing &lt;enter&gt; with no new value leaves the memory byte
unchanged
(and is thus equivalent to pressing the spacebar). <br>
&nbsp; </p>
<table border="2" cellspacing="2" cellpadding="2" bgcolor="#80ff80">
  <tbody>
    <tr>
      <td>
      <pre><font color="#400040"><tt>&nbsp;</tt> ?M2000&nbsp;<br>&nbsp;&nbsp; M2000 =FD -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp; M2001 =00 -&gt;<br>&nbsp;&nbsp; M2002 =FF -&gt;<br>&nbsp;&nbsp; M2003 =00 -&gt;55<br>&nbsp;&nbsp; M2004 =00 -&gt;<br>&nbsp; ?M2003<br>&nbsp;&nbsp; M2003 =55 -&gt;</font></pre>
      </td>
    </tr>
  </tbody>
</table>
<p>Note that EasyBug won't let you modify the scratch-pad addresses
&gt;8370-83FF
as they are used by the program (and by the GPL interpreter). And of
course,
you can't modify the content of the console ROMs, although EasyBug will
let you try. </p>
<p>Interestingly, the read and write operations are not performed by
the
GPL instruction ST, as one may have expected. Instead, a tiny assembly
program is loaded in the scatch-pad, at addresses &gt;83B0-&gt;83BF and
executed via a XML &gt;F0 (which means the vector is at &gt;8300, but
EasyBug
saves the content of this address into &gt;838E, so it can be restored
upon return from assembly. <br>
&nbsp; </p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre>* Routine that reads a byte from CPU memory. The GPL program places<br>* the address in &gt;839A and expects the result in &gt;8391.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MOV&nbsp; @&gt;838E,@&gt;8300&nbsp;&nbsp;&nbsp;&nbsp; restore vector location (saved by GPL)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MOV&nbsp; @&gt;839A,R1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get address<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MOVB *R1,@&gt;8391&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; read a byte<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B&nbsp;&nbsp;&nbsp; *R11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return to GPL</pre>
      <pre>* The same routine is loaded and slightly patched to modify a byte.<br>* It expects the new byte value in &gt;8399.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MOV&nbsp; @&gt;838E,@&gt;8300&nbsp;&nbsp;&nbsp;&nbsp; restore vector location (saved by GPL)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MOV&nbsp; @&gt;839A,R1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get address<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MOVB @&gt;8399,*R1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write byte to address<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B&nbsp;&nbsp;&nbsp; *R11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return to GPL</pre>
      </td>
    </tr>
  </tbody>
</table>
<h4><br>
<a name="V command"></a>The V command</h4>
<p>This command lets you view and edit the content of the VDP memory.
It
is used just as the M command. Note that fooling around with the screen
area (addresses &gt;0000-0300) or the character pattern table
(addresses
&gt;0900-0AFF) may render the screen difficult to read... </p>
<p>Normally, the valid range of VDP addresses is &gt;0000-3FFF, but
there
is an interesting bug in the GPL program. Instead of masking the
address
you entered with a AND &gt;3FFF, EasyBug ANDs it with &gt;FFFF... which
does strictly nothing. This means that you can modify the VDP register
by entering an address in the form &gt;8rxx, where r is the register
you
want to modify and xx the new value. Note that modifications to
registers
0, 1, 2, 3 and 4 may result in making the display unreadable... </p>
<p>Examples: <br>
&nbsp; </p>
<table cellspacing="2" cellpadding="2" bgcolor="#80ff80">
  <tbody>
    <tr>
      <td>
      <pre>&nbsp;?V87F5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; changes the screen color to blue<br>&nbsp; V87F5 =38 -&gt;&nbsp;&nbsp;&nbsp;&nbsp; press . here<br><br>&nbsp;?V81F0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; places the screen in text mode<br>&nbsp; V81F0 =38 -&gt;&nbsp;&nbsp;&nbsp;&nbsp; press .&nbsp;</pre>
      </td>
    </tr>
  </tbody>
</table>
<p>Note that the initial value of register 1 is automatically restored
when a key is pressed, using the content of byte &gt;83D4 (which
EasyBug
won't let you modify). </p>
<h4><br>
<a name="G command"></a>The G command</h4>
<p>This command lets you view the content of the GROM memory. It works
pretty much like M and V, except that EasyBug won't make any attempt to
modify a byte (although you can enter a new value, it is just ignored).
Thus, you cannot use EasyBug to patch a program in a GRAM card. </p>
<p>In addition, no provision is made to change the GROM base: the
default
base found in word &gt;83FA-83FB is always used (and EasyBug won't let
you modify &gt;83FA). <br>
&nbsp; </p>
<table border="2" cellspacing="2" cellpadding="2" bgcolor="#80ff80">
  <tbody>
    <tr>
      <td>
      <pre><font color="#400040"><tt>&nbsp;</tt> ?G6000&nbsp;<br>&nbsp;&nbsp; G6000 =AA -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp; G6001 =01 -&gt;<br>&nbsp;&nbsp; G6002 =00 -&gt;<br>&nbsp;&nbsp; G6003 =00 -&gt;55<br>&nbsp;&nbsp; G6004 =00 -&gt;<br>&nbsp; ?G6003<br>&nbsp;&nbsp; G6003 =00 -&gt;</font></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4><br>
<a name="C command"></a>The C command</h4>
<p>This command lets you read and write CRU bits, a very interesting
feature
that most memory editors don't provide. It works pretty much like the
memory
edition commands above, with the exception that valid values can only
be
0 and 1 (since we're dealing with bits, not bytes). If you enter a
greater
value, only the least significant bit is considered, e.r. &gt;03 is
writen
as "1". </p>
<p>Note that according to the device you are accessing, some CRU bits
can
be read-only bits, other write-only bits (which generally means they
read
as 0), and some may have different meaning when read or written (which
means you don't read back what you wrote). </p>
<p>The CRU address is the value you would normally place in R12 for CRU
operations from assembly. For instance, &gt;1100 to access bit 0 in the
disk controller card. Since A15 is used to carry the data, only even
addresses
are valid. However, EasyBug will read bit from odd addresses (the bit
will
be the same as in the even address) and write bit from them (bit "1"
will be writing first, followed by the value you selected). </p>
<p>Caution: be carefull when modifying CRU bits, as it is easy to
lock-up
the system. Have a look at my <a href="cru.htm">CRU page</a> for more
information
about the CRU. </p>
<p>EasyBug performs CPU output with the GPL instruction I/O 3, but uses
a small assembly program to perform CPU input (beats me). This program
is loaded and executed in the scratch-pad, at addresses &gt;83B0-83C1.
<br>
&nbsp; </p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre>* This routine reads a CRU bit into byte &gt;8391<br>* The CRU address is expected in word &gt;839A<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MOV&nbsp; @&gt;838E,@&gt;8300&nbsp;&nbsp;&nbsp;&nbsp; restore vector location<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MOV&nbsp; @&gt;839A,@&gt;83F8&nbsp;&nbsp;&nbsp;&nbsp; load address in R12<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; STCR @&gt;8391,1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set 1 CRU bit<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B&nbsp;&nbsp;&nbsp; *R11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return to GPL</pre>
      </td>
    </tr>
  </tbody>
</table>
<h4><br>
<a name="E command"></a>The E command</h4>
<p>This command lets you execute an assembly program, starting at the
address
you entered. No provision is made for EasyBug to regain control via
breakpoints
or interrupts. It is up to the executed program to return to GPL with
either
<tt>B *R11</tt> or <tt>B @&gt;006A.</tt> Note that the GROM address
should
not be altered (or else it should be restored after execution). </p>
<p>This make the Execution command of limited interest for debugging
purposes.
Mainly, it is used to run a program loaded with the L command. </p>
<p>To enter the selected assembly program, EasyBug uses the same
assembly
routine than to patch the CPU memory (cf the M command), after patching
one instruction: <br>
&nbsp; </p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre>* This routine starts execution of an assembly program.<br>* The start address is expected in word &gt;839A<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MOV&nbsp; @&gt;838E,@&gt;8300&nbsp;&nbsp;&nbsp;&nbsp; restore vector location (saved by GPL)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MOV&nbsp; @&gt;839A,R1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get address<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B&nbsp;&nbsp;&nbsp; *R1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; patched: branch to start address</pre>
      </td>
    </tr>
  </tbody>
</table>
<p>Example: </p>
<p>We could use the E command together with the M command to patch
bytes
in the memory area tha EasyBug won't let us modify. For instance, we
could
modify byte &gt;83D4: it contains a copy of VDP register 1 that is used
by the keyboard scanning routine to restore VDP register 1 each time a
key is pressed. <br>
&nbsp; </p>
<table cellspacing="2" cellpadding="2" bgcolor="#80ff80">
  <tbody>
    <tr>
      <td>
      <pre>&nbsp;?M8302<br>&nbsp; M8302 =00 -&gt;D8&nbsp;&nbsp;&nbsp;&nbsp; This is MOVB @&gt;830A,@&gt;83D4<br>&nbsp; M8303 =00 -&gt;20<br>&nbsp; M8304 =00 -&gt;83&nbsp;&nbsp;&nbsp;&nbsp; Here is the address to modify&nbsp;<br>&nbsp; M8305 =00 -&gt;0A<br>&nbsp; M8306 =00 -&gt;83<br>&nbsp; M8307 =00 -&gt;D4<br>&nbsp; M8308 =00 -&gt;04&nbsp;&nbsp;&nbsp;&nbsp; This is B *R11<br>&nbsp; M8309 =00 -&gt;5B<br>&nbsp; M830A =00 -&gt;F0&nbsp;&nbsp;&nbsp;&nbsp; This is our new value<br>&nbsp; M830B =00 -&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Press . here<br>&nbsp;?E8302&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Execute our routine<br>&nbsp;?&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Press any key to place the screen in text mode</pre>
      </td>
    </tr>
  </tbody>
</table>
<p>The same routine could be used to change the GROM base in byte
&gt;83FB.
If you are running EasyBug from your GramCard, you can now access
different
GROM ports in your card. Just make sure that the mini-memory GROM is
copied
in each one, otherwise EasyBug will crash. </p>
<h4><br>
<a name="S command"></a>The S command</h4>
<p>This command allows you to save a program from CPU memory onto the
CS1
cassette recorder. Unfortunately, it won't work with disk drives. </p>
<p>The address you enter is the first address saved, and you are then
prompted
for the last address to save. EasyBug verifies that the end address is
higher than the start address, and that they do not lie in the console
ROM (address lower than &gt;2000), nor encompass the area reserved for
EasyBug (&gt;8370-83FF). Then EasyBug loads a small assembly program in
the scratch-pad addresses &gt;83AA-83BF and executes it with an XML
&gt;F0.
This program just copies the selected memory range into a buffer in VDP
memory at address &gt;1100. EasyBug itself places the program address
and
size at the beginning of the buffer. <br>
&nbsp; </p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre>* Routine that copies CPU memory to VDP memory.<br>* It expects the CPU address in word &gt;839C and the<br>* number of bytes in word &gt;8390.<br>* The GPL programs sets the VDP address for writing operations.&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MOV&nbsp; @&gt;838E,@&gt;8300&nbsp;&nbsp;&nbsp;&nbsp; restore vector location<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MOV&nbsp; @&gt;839C,R2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get byte pointer<br>LP1&nbsp;&nbsp; MOVB *R2+,@&gt;FFFE(R15)&nbsp; write byte to VDP<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DEC&nbsp; @&gt;8390&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; decrement counter<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JNE&nbsp; LP1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; more to do<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B&nbsp;&nbsp;&nbsp; *R11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return to GPL</pre>
      </td>
    </tr>
  </tbody>
</table>
<p>Finally, EasyBug installs a PAB for CS1 in VDP memory, at address
&gt;1000-100D
and calls the DSR scanning routine in the console GROMs at G@&gt;0010.
The file on tape will be Dis/Fix 64, as required for cassette
operations.
Note that the PAB specifies a screen bias of &gt;00 in its 8th byte,
since
we are not using the Basic bias. </p>
<p>The CS1 DSRs, in the console ROM, display all necessary prompts and
handle the file operations. Note that EasyBug saves the scratch-pad
area
&gt;8340-836F before to call the DSR and restores it afterwards. This
is
necessary because the CS1 DSR modifies several bytes in this area. </p>
<h4><br>
<a name="L command"></a>The L command</h4>
<p>This command is used to load a program previously saved with the S
command.
It uses the first 4 bytes in the file to determine the loading address
and the number of bytes to save. </p>
<p>Here also, EasyBug calls the CS1 DSR to perform the file operations.
It then loads the same assembly routine as above, and patches it so
that
it now copies the VDP memory into CPU memory: <br>
&nbsp; </p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre>* Routine that copies VDP memory to CPU memory.<br>* It expects the CPU address in word &gt;839C and the<br>* number of bytes in word &gt;8390.<br>* The GPL programs sets the VDP address for reading operations.&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MOV&nbsp; @&gt;838E,@&gt;8300&nbsp;&nbsp;&nbsp;&nbsp; restore vector location<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MOV&nbsp; @&gt;839C,R2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get byte pointer<br>LP1&nbsp;&nbsp; MOVB @&gt;FBFE(15),*R2+&nbsp;&nbsp; read byte from VDP (patched)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DEC&nbsp; @&gt;8390&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; decrement counter<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JNE&nbsp; LP1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; more to do<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; B&nbsp;&nbsp;&nbsp; *R11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return to GPL</pre>
      </td>
    </tr>
  </tbody>
</table>
<h2><br>
<br>
<br>
<a name="subprograms"></a>Subprograms</h2>
<h3>INIT</h3>
<p>This subprogram initialises the cartidge RAM for use with by the
loader.
It is equivalent to option 3 in the Mini-memory main menu.. It wipes
out
the whole RAM and resets the loading pointers. </p>
<h3><br>
<a name="load"></a>LOAD</h3>
<p>This subprogram can actually perform two distincts functions: place
numeric values at a given address in cpu memory, or call the loader and
load a tagged-object file into memory. Which function is selected
depends
on the type of parameter passed to the subprogram: a (non-empty) string
constant or string variable calls the loader, a number or a numeric
variable
patches the memory. </p>
<p>When a filename is passed as an argument, e.g. CALL
LOAD("DSK1.MYFILE"),
the subprogram loads the standard assembly language routines then calls
the loader with XML &gt;71. Upon return, if the Cnd bit of the status
byte
is set, an error will be returned. Otherwise, LOAD resumes parsing the
parameters. This means you can load several files, or mix file loading
and memory patching (however, once you started memory patching, you
cannot
load any more files). </p>
<p>To load values into memory, you must first specify the destination
address
as a number from -32768 to +32767, where negative numbers correspond to
addresses in the range &gt;8000-FFFF. LOAD calls XML &gt;12 to convert
the real number into an integer. The following parameters must contain
the bytes to place in memory, therefore the usefull range is 0-255.
Note
that you can specify any value from -32768 to 32767, but only the least
significant byte of the integer will be loaded. </p>
<p>If you want to specify a new address in the same CALL LOAD
statement,
you can use an empty string constant (or variable) as a separator. The
string must be empty so that it is not mistaken for a filename:
non-empty
strings issue a "bad argument" error. </p>
<h4>Example:</h4>
<p>CALL
LOAD("DSK1.MYFILE","DSK2.HISFILE",-24576,65,66,"",-20480,0,218,)
</p>
<p>Loads a tagged-object code file called MYFILE into memory, <br>
loads the file HISFILE into memory, <br>
places bytes 65 and 66 (i.e. "AB") at location &gt;A000, <br>
and places bytes 0 and 218 at location &gt;B000. </p>
<h3><br>
<a name="pokev"></a>POKEV</h3>
<p>Works exactly like LOAD, except that the target is the VDP memory.
The
address should therefore be in the range 0-3FFF (i.e. 16383). Of
course,
as programs can't run in VDP memory, it is not allowed to pass a
filename
within a CALL POKEV. </p>
<h3><br>
<a name="peek"></a>PEEK</h3>
<p>This subprogram performs the opposite of LOAD: it fetches bytes from
memory and transfers them in numeric variables. </p>
<p>Just like LOAD, you must specify an address in the range -32768 to
+32768
either as a number or as a numeric variable. Then you can enter as many
numeric variables as you like: each will receive one byte corresponding
to the content of the cpu memory, starting at the specified address.
Values
will be in the range 0-255. </p>
<p>You can use an empty string as a separator to enter a new address,
but
non-empty strings will cause an error. </p>
<h4>Example:</h4>
<p>CALL PEEK (12,CLOCK,"",72,A,B,C,D) <br>
XOP2WR=(256*A)+B <br>
XOP2PC=(256*C)+D </p>
<p>Gets the content of byte &gt;000C into the variable CLOCK (this is
the
console clock frequency: 48 for 3 MHz or 40 for 2 MHz). </p>
<p>Then gets the vectors for extended operation 2 (which does not exist
in all consoles). The next two statements combine the bytes into words:
XOP2WR should be 33696 (i.e.&gt;83A0) and XOP2PC should be 33536
(&gt;8300).
</p>
<h3><br>
<a name="peekv"></a>PEEKV</h3>
<p>Does the same as PEEK, but gets values from the VDP memory.
Addresses
should therefore be in the range 0-16383 (i.e &gt;3FFF). </p>
<h3><br>
<a name="LINK"></a>LINK</h3>
<p>This subprogram is used to begin execution of a program loaded with
CALL LOAD. The first argument should be a quoted string, or a string
variable
containing the program name (i.e. an assembly DEFined label). </p>
<p>Optionally, you can specify upto 16 additional parameters that will
be passed to the executed programs. LINK fetches each parameter from
the
Basic symbol table, concatenates strings connected with &amp; if
necessary,
and places the resulting numeric value or a string pointer on the value
stack in VDP memory. These values can be retrieved by the called
program
via XML &gt;18. </p>
<p>In addition, LINK places the total number of variables in byte
&gt;8212
and indicates the type of variable (number, string constant, numeric
variable,
etc) into bytes &gt;7002-7011, one byte per parameter. Note that this
is
different from CALL LINK in Extended Basic, that places the parameter
types
at &gt;8300 and from the Editor/Assembler cartridge that uses the low
memory
expansion for this purpose. </p>
<p>The parameter type values can be: <br>
0: number <br>
1: quoted string <br>
2: numeric variable <br>
3: string variable <br>
4: numeric array element <br>
5: string array element </p>
<p>All this makes parameter handling much easier for programs called
from
Basic. It's not really a piece of cake though... </p>
<p>Once all parameters have been processed, LINK calls the linker via
XML
&gt;70, with the program name in &gt;834A-834F and the name length in
word
&gt;8350-8351. If the name was en empty string, the linker will attempt
to call again the previously executed program, if any. </p>
<p>Upon return, ar error is issued if the Cnd bit is set in the GPL
status
byte. The error number is taken from byte &gt;8322. If no error occured
the subprogram removes all parameters from the value stack, if that
wasn't
done by the called program, and checks that the Basic statement
terminates
correctly (i.e &gt;8342 must contain &gt;00). Then it returns to Basic.
</p>
<h3><br>
<a name="charpat"></a>CHARPAT</h3>
<p>This subprogram is used to retrieve the pattern of a character, in
the
range 32-159. </p>
<p>The first parameter must be a number or a numeric variable: this is
the number of the character of interest. The second parameter must be a
string variable. Upon return, it will contain an hexadecimal
description
of the pattern, just like the ones used by the Basic CALL CHAR. </p>
<h4>Example:</h4>
<p>CALL CHARPAT(97,A$) </p>
<p>A$ now contains the pattern for character 97, the lower case A:
"00000038447C4444"
</p>
<h2><br>
<a name="DSRs"></a>DSRs</h2>
<p>The GROM contains three identical DSRs: MINIMEM, EXPMEM1 and
EXPMEM2.
Each of them allows you to save a file into a RAM domain, the cartridge
RAM, the low memory expansion and the high-memory expansion
respectively.
They provide you with some kind of very primitive RAMdisk: only 3 files
can be saved, and two of them will be forgotten when the power is
turned
off! </p>
<p>Each memory starts with a 8-byte header containing file info: </p>
<pre><u>Offset Contents&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br></u>0000&nbsp;&nbsp; &gt;5AA5 flag&nbsp;<br>0001&nbsp;&nbsp; file type (&gt;FF for program files)<br>0002&nbsp;&nbsp; record length&nbsp;<br>0004&nbsp;&nbsp; write pointer (var: mem offset / fix: rec #)&nbsp;<br>0006&nbsp;&nbsp; read pointer (ditto)</pre>
<p>The available memory space is thus: </p>
<pre>&gt;7008-7FFF for MINIMEM (i.e. &gt;0FF8 bytes)<br>&gt;2008-3FFE for EXPMEM1 (i.e. &gt;1FF7 bytes)<br>&gt;A008-FFE0 for EXPMEM2 (i.e. &gt;5FD8 bytes, the rest is reserved for XOP1 and LOAD interrupts)</pre>
<p>If the loader is intalled in the cartridge RAM (flag &gt;A55A at
&gt;7000),
and a file is loaded in the memory expansion card, the corresponding
pointers
are cleared, which prevent the loader from placing programs in this
area.
</p>
<p>The supported opcodes are Open, Close, Read, Write, Rewind, Load,
Save,
Delete, and Status. They respect the conventions established for the
disk
controller. </p>
<h4>Open</h4>
<p>Performs the necessary file type checks and issues errors if needed
(for instance: opening an empty memory for input, or opening a Fix file
in append mode). The default record length is 80 </p>
<p>If needed,Open initialises the selected memory area, by installing
the
8-byte header. It mercilessly overwrites any file currently in memory,
without any warning. There is a bug in this routine that causes EXPMEM1
to malfunction if the Mini-memory was initialized. </p>
<h4><br>
Close</h4>
<p>Returns immediately, without performing anything. </p>
<h4><br>
Read</h4>
<p>Reads a record from an opened file </p>
<h4>Write</h4>
<p>Writes a record to an opened file </p>
<h4>Rewind</h4>
<p>Points to a given record in an opened Fix file or to the top of a
Var
file. </p>
<p>Read, Write and Rewind make use of the two pointers in the header:
the
write pointer marks the end of the file, the read pointer points at the
next byte to be read. For variable records, these pointers contain an
offset,
within the selected memory. For fixed records, they contain the record
number. </p>
<h4><br>
Load</h4>
<p>Loads a "program" file into memory (used by the Basic OLD
statement, or by EA5 memory-image loaders). </p>
<h4><br>
Save</h4>
<p>Saves a "program" file into the appropriate "ramdisk".
If needed, it initialises the selected memory area, by installing the
8-byte
header. It mercilessly overwrite any file currently in the "ramdisk",
without any warning. EXPMEM1 suffers from the same bug than with OPEN
when
the Mini-memory is initialized. </p>
<h4><br>
Delete</h4>
<p>Removes the &gt;5AA5 flag and restores the loader pointers if
appropriate.
</p>
<h4><br>
Status</h4>
<p>Returns informations about the file in a given memory area. The file
type is taken from the 8-byte header. </p>
<p>For Fix files, the record number passed in the PAB is compared to
the
size of the memory area, and the "memory full" bit is set if
needed. It is then compared to the write pointer in the header, to set
the EOF bit. </p>
<p>For Var file, the EOF bit is set if the read and write pointers are
identical. </p>
<p>The "not found" bit and the "write protected" bit
are not used. If the memory area does not contain any file, the status
byte will be &gt;00. </p>
<pre><u>Bit Value Meaning&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br></u>0&nbsp;&nbsp; &gt;80&nbsp;&nbsp; Not used (file not found)<br>1&nbsp;&nbsp; &gt;40&nbsp;&nbsp; Not used (write protected)<br>2&nbsp;&nbsp; &gt;20&nbsp;&nbsp; Not used<br>3&nbsp;&nbsp; &gt;10&nbsp;&nbsp; Internal (else Display)<br>4&nbsp;&nbsp; &gt;08&nbsp;&nbsp; Program file<br>5&nbsp;&nbsp; &gt;04&nbsp;&nbsp; Var records (else Fix)<br>6&nbsp;&nbsp; &gt;02&nbsp;&nbsp; Memory full<br>7&nbsp;&nbsp; &gt;01&nbsp;&nbsp; End of file</pre>
<h3><br>
<a name="Checking memory"></a>Checking memory usage</h3>
<p>As we saw, there are two ways the Mini-memory can use the available
RAM: one is to store files via the DSRs, the other is to load assembly
language, via the LOAD subprogram. These two ways are not fully
compatible,
in that they tend to "fight" for memory, so if you want to mix
them you will have to exercise some care. In particular, neither DSR
will
issue any warning before wiping out any assembly language program that
you may have loaded into the memory expansion or into the cartridge
RAM.
Conversely, CALL INIT wipes out the file loaded into MINIMEM and makes
it difficult to access the other two. </p>
<p>One usefull thing to do is to PEEK the first addresses of each
domain,
to know whether a Mini-memory DSR has placed a file in there. The
addresses
are: </p>
<ul>
  <li>28672 for MINIMEM (i.e. &gt;7000)</li>
  <li>8192 for EXPMEM1 (i.e. &gt;2000)</li>
  <li>-24576 for EXPMEM2 (i.e.&gt;A000)</li>
</ul>
<p>And the Basic instructions would be something like this: </p>
<pre>100 CALL PEEK(ADDR,FLAG1,FLAG2,TYPE,RECLEN,WR1,WR2,RD1,RD2)<br>110 WRITPT=(WR1*256)+WR2<br>120 READPT=(RD1*256)+RD2</pre>
<p><b>FLAG1 </b>should be 90 and <b>FLAG2 </b>should be 165 if a
file is
present. <br>
<b>TYPE </b>is 0 for Dis/Fix, 8 for Int/Fix, 16 for Dis/Var, 24 for
Int/Var,
and 255 for programs. <br>
<b>RECLEN </b>is the record length (irrelevant for programs). <br>
<b>WRITEPT </b>is the position of the write pointer, i.e. the current
size
of the file. For "program" and "variable" files the
size is given in bytes. For "fixed" files it is a number of records,
so you must multiply it with RECLEN to obtain the number of bytes. <br>
<b>READPT </b>is the current position of the read pointer, in the same
units at WRITEPT. </p>
<p>If the Mini-memory was initialized (either from its menu, or from
Basic
with a CALL INIT), you will find 165 in FLAG1 and 90 in FLAG2 when
PEEKing
at 28672, rather than the other way around. If so, you absolutely
cannot
use the MINIMEM file since the Mini-memory RAM is needed by the loader
to place its data, including the symbol table. </p>
<p>As for the memory expansion, you can check the loader's pointer at
&gt;7022
and &gt;7026 with: </p>
<pre>100 CALL PEEK(28706,A1,A2,B1,B2,C1,C2,D1,D2)<br>110 FSTHI=A1*256+A2<br>120 LSTHI=B1*256+B2<br>110 FSTLO=C1*256+C2<br>120 LSTLO=D1*256+D2</pre>
<p><b>FSTHI </b>is the first free address in the high memory
expansion.
If it's -24576, nothing was loaded yet. <br>
<b>LSTHI </b>is the last address that can be used by the loader in the
high memory expansion. <br>
<b>FSTLO </b>is the first free address in the low memory expansion. If
it is 8192 nothing was loaded yet. <br>
<b>LSTLO </b>is the last address available for assembly language in
the
low memory expansion <br>
If a couple of values reads as two zeros, it means that loading was
disabled
in the corresponding area, most probably because we are already using
EXPMEM1
or EXPMEM2. </p>
<p>Incidently, you can get the same info for assembly programs loaded
in
the Minimemory RAM, by performing a similar CALL PEAK at &gt;701C: </p>
<pre>100 CALL PEEK(28700,A1,A2,B1,B2)<br>110 FSTMOD=A1*256+A2<br>120 LSTMOD=B1*256+B2</pre>
<p>If you are interested in these issues, you can download <a
 href="memmodck.zip">MEMMODCK.TI</a>,
a Basic program by Paul Schippnick that is included here with his
permission.
This program reports on the memory in your system. It works with the
Mini-memory
module, but also with Editor-Assembler and Extended Basic. To transfer
it to your TI-99/4A, see the instructions on my <a href="download.htm">download
</a>page. </p>
<h4><br>
<a name="DSR &amp; INIT"></a>Using the DSRs with CALL INIT</h4>
<p>Doing a CALL INIT with DSR files presents in memory will have
catastrophic
results for MINIMEM. The file will be completely wiped out, each and
every
byte zeroed even before the loader is installed. Note that the opposite
is also true: MINIMEM overwrites the loader's private data and
eventually
any assembly program loaded in the Mini-memory RAM. </p>
<p>EXPMEM2 also seems to disappear, but the file is actually still
there.
What hapenned is that CALL INIT checks for the presence of the memory
expansion
by inverting the byte at &gt;A000 and cannot be bothered to restore it
afterwards. So we'll have to do it ourselves to recover the file: </p>
<pre>CALL LOAD(-24576,90)</pre>
<p>There is no such problem with accessing an existing file in EXPMEM1
after a CALL INIT. </p>
<p>However, it is extremely tricky to create new files after the
Mini-memory
has been initialized. The problem likely originated when TI programmers
decided to integrate these DSRs and make them compatible with the CALL
LOAD assembly loader. They wrote a quick hack to this effect and
obviously
never really tested it. Unfortunately, they managed to leave two very
nasty
bugs within 10 lines of GPL! As a result, EXPMEM1 and EXPMEM2 will not
work properly when creating new files (with either SAVE or OPEN) after
the Mini-memory was initialized. Although, if you really need to do
this,
there is a way around the bugs. </p>
<h4><br>
<a name="Bug"></a>The DSR bugs</h4>
<p>In an attempt to make the DSRs compatible with the assembly loader,
TI programmers introduced two modifications: </p>
<ul>
  <li>When creating a new file, SAVE and OPEN call a routine that
installs
the file header into the relevant memory area. This routine was
modified
so that it will also clear the loader's pointers for this memory area,
so that no assembly will be placed in there.</li>
  <li>The DELETE opcode restores the loader's pointers to their
original
values.</li>
</ul>
<p>Unfortunately, the first modification includes two very annoying
bugs.
If you are curious, have a look at the<a href="mmg.txt"> mmg.txt</a>
file:
the bugs are highlighted with *** marks. </p>
<p>The first bug results from a stupid typo in a single byte, that ends
up incrementing the wrong data word: &gt;835A instead of &gt;834A. This
bug has two deleterious effects, wich only occur when the Mini-memory
was
initialized and you create a new EXPMEM1 file (with either SAVE or OPEN
in output mode, or OPEN in update mode if the file does not already
exist).
</p>
<ul>
  <li>Instead of preventing the loader from loading assembly in the low
memory
expansion, the bug actually disables loading in the HIGH memory
expansion.</li>
  <li>The file header for EXPMEM1 is placed at &gt;2004 instead of
&gt;2000.
This is very unfortunate, because all other opcodes expect the header
to
lie at &gt;2000 and will cause a file error when called under these
conditions.
As a result, we can create a file but not use it! Note however, that a
file created before the CALL INIT can still be accessed normally.</li>
</ul>
<p>The second bug was harder to catch. It results from the fact that
the
programmer loaded a word pointer in &gt;834A, which will automatically
overwrite &gt;834B...that was supposed to contain the file type! As a
result,
any file created in EXPMEM1 or EXPMEM2 is registered as Dis/Fix. Which
means that, once you have closed the file, you cannot open it again
unless
it was indeed a Dis/Fix file. There is no such problem with SAVE
however,
because SAVE does not get the file type from &gt;834B. </p>
<p>The best way to overcome these bugs is to trick the program into
thinking
that the Mini-memory was not initialized, so the buggy routine will not
be called. This means that we will have to handle the loader's pointers
ourselves, but that's no big deal. A simple way to do this is to clear
the flag at &gt;7000: </p>
<pre>100 CALL LOAD(28672,0)<br>110 OPEN #1:"EXPMEM1",whatever<br>120 CALL LOAD(28672,165)<br>130 CALL LOAD(28710,0,0,0,0)</pre>
<p>Line 100 clears the "initialized" flag and line 120 restores
it. Thie latter is required because CALL LINK checks for this flag and
returns an error if it did not find it. Note that there is nothing
wrong
with delaying this restauration until just before the CALL LINK. </p>
<p>Line 130 clears the loader's pointers for the low memory expansion
(at
&gt;7026), which EXPMEM1 will be using. This is required so that
further
CALL LOAD("filename") statements will not load assembly language
programs into the low memory expansion. For EXPMEM2, you would use
address
28706 instead. You only need to do this once for EXPMEM1 and once for
EXPMEM2.
Unless you subsequently perform a DELETE on either EXPMEM1 or EXPMEM2,
in which case the corresponding loader pointers will be automatically
restored.
If you change your mind and want to open or save a new file after a
delete,
you will again need to clear the corresponding loader's pointers. </p>
<p>A more sophisticated way would be to reserve some room for your
files
and tell the loader to place assembly afterwards. This can be done be
loading
a value between &gt;A000 and &gt;FFE0 (i.e 160,0 and 255,240) into
28706
and a value between &gt;2000 and &gt;3FFE (i.e. 32,0 ad 63,254) into
28710.
You could either choose an arbitrary value for this border or fetch the
current size of the DSR file (see <tt>WRITEPT </tt>in the previous
section)
and use it to place assembly just after the end of the file. All this
is
a bit dangerous though, because nothing will prevent you from
overwriting
assembly by increasing the size of the file in EXPMEM1 or EXPMEM2. You
just have to know what you are doing... <br>
&nbsp; <br>
&nbsp; </p>
<address>Revision 1. 7/18/99 Ok to release</address>
<address>Revision 2. 7/12/01 Correctedtypos, CRU address, added memory
checks, bugs discussion.</address>
<address>Revision 3. 8/26/01 Added link to picture page.</address>
<center>
<p><a href="titechpages.htm">Back to the TI-99/4A Tech Pages</a>
</p>
</center>
</body>
</html>
