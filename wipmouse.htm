<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
  <title></title>
  <meta name="Author" content="">
  <meta name="GENERATOR"
 content="User-Agent: Mozilla/3.04Gold (Macintosh; I; PPC)">
</head>
<body>
<h1 align="center"><a
 href="http://www.nouspikel.com/ti99/titechpages.htm"><img
 src="logo.jpg" style="border: 0px solid ; height: 33px; width: 95px;"
 title="Back to main index" alt=""></a></h1>
<h1>The WiPo mouse 99</h1>
<p>This mouse was produded around 1986 by:</p>
<address>Softpoint Electronic, GmbH<br>
Balanstr. 285 8000 Munchen 90<br>
Germany</address>
<p><a href="#hardware">Hardware description</a></p>
<p><b>Software issues<br>
</b><a href="#software">CRU map<br>
</a><a href="#driver">Mouse driver<br>
</a><a href="#text%20mode">Text mode</a></p>
<h2><br>
<a name="hardware"></a>Hardware</h2>
<p>The hardware consists in a small 6-chip adapter board that is
plugged
in the side port of the console, in between the console and the PE-Box
cable connector. This design serves two functions: first the board can
draw its power supply from the side port. Second, it can access the
LOAD*
line to issue non-maskable interrupts when the mouse is moved. An
easily
accessible switch allows the user to open this connection and to
prevent
interrupt from being sent when the mouse driver is not installed.</p>
<p>In addition, the board has a 9-wire connection cable to the joystick
port. This enables the software to read the status of the two mouse
buttons,
and of the two motion detectors (left/right and up/down). The
circuitery
on board provides an extra signal that the software can use to
determine
whether the latest detected motion (that triggered the interrupt) was
vertical
or horizontal. These signals can be accessed by reading keyboard column
7, i.e. joystick 2.</p>
<p>Reading keyboard column 6 (joystick 1) temporarily prevents the
emission
of LOAD* interrupts. This avoids the re-entrancy problems due to two
interrupts
issued too close from each other (see my page on <a
 href="ints.htm#UISR">interrupts</a>
for more details). It also resets the vertical/horizontal flip-flop.</p>
<p>The mouse itself is a "no name" device made in Taiwan. It
has a long cable with a 9-hole plug at the end, just like the joystick
port. A corresponding male socket is provided on the adapter board.</p>
<table bgcolor="#cdcde6">
  <tbody>
    <tr>
      <td>
      <pre>      74LS121           74LS74    M3     74LS123<br>      +------+         +------+   v      +------+    2K<br>J7&gt;---|A1*  R|-+5V +5V-|D     |   |  Gnd-|A*  CR|-+--WWW--+5V<br>  +5V-|A2*   |     +5V-|Pr*   |   |      |      | = 333<br>  +5V-|B    C|-,       |   Clk|---+------|B   C |-'<br>      |      | = 0.1uF |      |          |      | <br>      |    CR|-'       |      |      +5V-|Clr*  |<br>      |    Q*|----+----|Clr* Q|--,       |    Q*|--,<br>      +------+    |    +------+  |       +------+  |      74LS04<br>                  |              |   Gnd-|A*  Q*|--==|)---|&gt;o---, 74LS08  Switch<br>                  |              |   +5V-|B     |  74LS08      ,==|)--|&gt;o--/ o---&gt; LOAD* <br>                  |              |       |    C |-,            |     74LS04<br>                  |              | M1&gt;---|Clr*  | = 333        |<br>                  |              |       |    CR|-+--WWW--+5V  |   <br>                  |              |       +------+    2K        |<br>                  '--------------|-----------------------------'     <br>             74LS367             |<br>           +--------+            |<br> J2&gt;----+--|1OE* 2A2|------------'            <br>        '--|2OE* 2Y2|-----&gt;J8          +5V----M7<br>           |        |                  Gnd----M8              ___________<br> M4&gt;-------|1A1  2A1|-----&lt;M2            nc --M5             ( 1 2 3 4 5 )<br> J9&lt;-------|1Y1  2Y1|-----&gt;J3                                 \<u> 6 7 8 9 </u>/<br>           |        |  <br> M6&gt;-------|1A2  1A4|-----&lt;M9            nc --J1            M1-M9: Mouse plug<br> J4&lt;-------|1Y2  1Y4|-----&gt;J3            nc --J6            J1-J9: Joystick port<br>           +--------+ <br>      </pre>
      </td>
    </tr>
  </tbody>
</table>
<p>A rising edge on mouse connections M3 (vertical motion) and M1
(horizontal
motion) triggers a short pulse in their respective half of the 74LS123
one-shot. The two Q* outputs are combined via an AND gate so that, if
at
least one pulse is occuring, the LOAD* line will be low. The second AND
gate is used to mask out this signal: when joystick 1 is accessed, it
triggers
a longer pulse on the 74LS121 one-shot. The resulting low signal on the
Q* output prevents the LOAD* line from going low, no matter what
happened
to the mouse.</p>
<p>Accessing joystick 2 enables the 74LS373 tri-state buffer and allows
for reading the four mouse signals through the joystick return lines.
The
fifth line is connected to the Q output of a 74LS74 flip-flop: it is
used
to determine whether a vertical motion was detected or not. A rising
edge
on M3 brings the Q output high, it can only be reset by accessing
joystick
1.<br>
</p>
<h2><br>
<a name="software"></a>Software</h2>
<p>The mouse came with a companion disk containing completely useless
demo
software and very meager explanations on how to write a mouse driver. I
had to experiment quite a bit in order to figure out how to access the
mouse!</p>
<h4>CRU map</h4>
<table border="1">
  <tbody>
    <tr>
      <th>R12 address</th>
      <th>Bit</th>
      <th>Meaning</th>
    </tr>
    <tr>
      <td>&gt;0006</td>
      <td>3</td>
      <td>Left button. 0: down 1: up</td>
    </tr>
    <tr>
      <td>&gt;0008</td>
      <td>4</td>
      <td>Right button. 0: down 1: up</td>
    </tr>
    <tr>
      <td>&gt;000A</td>
      <td>5</td>
      <td>Vertical motion. 0: down 1:up</td>
    </tr>
    <tr>
      <td>&gt;000C</td>
      <td>6</td>
      <td>Motion detector. 0: horizontal 1: vertical </td>
    </tr>
    <tr>
      <td>&gt;000E</td>
      <td>7</td>
      <td>Horizontal motion. 0: right 1: left</td>
    </tr>
    <tr>
      <td>&gt;0024<br>
&gt;0026<br>
&gt;0028</td>
      <td>18<br>
19<br>
20</td>
      <td>1 1 1: read mouse values in bits 3-7<br>
0 1 1: temporarily disable LOAD*&nbsp;interrupts<br>
and reset bit 6.</td>
    </tr>
  </tbody>
</table>
<h4><br>
<a name="driver"></a>Mouse driver</h4>
<p>The software must hook the non-maskable interrupt vector at
&gt;FFFC-FFFF
to trap any interrupt generated by the mouse. The interrupt service
routine
can then read CRU bits 4-6 to determine what kind of motion caused the
interrupt and update the vertical and horizontal position buffers. </p>
<p>The value of these counters can then be used by the program to
display
a mouse cursor on screen. A good way to do this is to hook the VDP
interrupts
that occur 60 times per second (50 in Europe) and update the position
of
a sprite according to the moves of the mouse.</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre>*======================================================================<br>* Demo driver for the WiPo mouse 99<br>* ---------------------------------<br>* It moves a sprite on screen according to the moves of the mouse<br>* (without checking for screen boundaries).<br>* The left mouse button changes the sprite pattern (crosshair/arrow).<br>* The right button changes the sprite color (black/white).<br>*======================================================================<br>       DEF  START<br>*<br>START  LI   R0,&gt;0400       initialize sprite patterns<br>       LI   R1,PATS<br>       LI   R2,16          2 chars: crosshair and arrow<br>       BL   @VMBW<br>       LI   R0,&gt;0300       initialize sprite 0 attributes<br>       LI   R1,SPRITE<br>       LI   R2,5<br>       BL   @VMBW<br> <br>       LI   R0,INTER       hook the VDP interrupt routine<br>       MOV  R0,@&gt;83C4<br> <br>       CLR  @WREGS+18      reset motion counters (R9 and R10 in WREGS)<br>       CLR  @WREGS+20<br> <br>       MOV  @YSWR,@&gt;FFFC   hook the LOAD* interrupt vectors<br>       MOV  @YSPG,@&gt;FFFE<br> <br>EVER   LIMI 2              enable VDP interrupts<br>       LIMI 0              disable them<br>       JMP  EVER           wait forever (Fctn= is active)<br><br>*-------------------------------------------<br>* Unmaskable LOAD* interrupt service routine<br>*-------------------------------------------<br>CHECK  MOV  @NOWR,@&gt;FFFC   change WS to allow 1 re-entrancy<br>       LIMI 0              disable VDP interrupts<br>       LWPI WREGS          our workspace<br>       MOV  @NOPG,@&gt;FFFE   prevents re-entrancy (this points to a RTWP)<br> <br>       CLR  R12            CRU address of the TMS9901<br>       SBO  18             keyboard column 7 (joystick 2) to read mouse param<br>       SBO  19<br>       SBO  20<br> <br>       TB   6              vertical or horizontal interrupt?<br>       JNE  SK1            horizontal<br>       INC  R9             vertical: increment counter<br>       TB   5              up or down?<br>       JEQ  SK2            up: we are done<br>       DECT R9             down: we should have decremented the counter<br>       JMP  SK2<br> <br>SK1    INC  R10            horizontal motion: increment the counter<br>       TB   7              left or right?<br>       JEQ  SK2            right: we are done<br>       DECT R10            left: we should have decremented the counter<br> <br>SK2    SBZ  18             reset bit 6, disable LOAD* interrupts for a while<br>       MOV  @YSWR,@&gt;FFFC   restore the LOAD* vectors<br>       MOV  @YSPG,@&gt;FFFE   no interrupt should occur here!<br>RET    RTWP<br> <br>*-------------------------------------------<br>* Display routine, hooked to the VDP interrupt service routine<br>*-------------------------------------------<br>INTER  LIMI 0              disable interrupts (just in case)<br>       LWPI WREGS          our workspace<br>       LI   R0,&gt;0300       read sprite 0 attributes<br>       LI   R1,BUF<br>       LI   R2,4<br>       BL   @VMBR1<br> <br>       LI   R1,BUF         update the position<br>       SLA  R9,8           to slow the sprite: SLA R9,7 To speed it up: SLA R9,9 <br>       AB   R9,*R1+        add the vertical motion<br>       SLA  R10,8<br>       AB   R10,*R1+       add the horizontal motion<br> <br>       CLR  R12            CRU address of the TMS9901<br>       SBO  18             keyboard column 7: access mouse params<br>       SBO  19<br>       SBO  20<br> <br>       LI   R0,&gt;8000       sprite pattern # 128 (crosshair)<br>       TB   3              test left button<br>       JEQ  SK3            up<br>       AI   R0,&gt;0100       down: change for pattern # 129 (arrow)<br>SK3    MOVB R0,*R1+        write it back<br> <br>       LI   R0,&gt;0100       color = black<br>       TB   4              test right button<br>       JEQ  SK4            up<br>       LI   R0,&gt;0F00       down: change color to white<br>SK4    MOVB R0,*1+         write it back<br> <br>       SBZ  18             reset bit 6, temporarily disable LOAD*<br>       LI   R0,&gt;0300       write back sprite parameters<br>       LI   R1,BUF<br>       LI   R2,4<br>       BL   @VMBW1<br> <br>       CLR  R9             reset counters<br>       CLR  R10<br>       LWPI &gt;83E0          back to interrupt service routine workspace<br>       B    *R11           return to it<br> <br>*-------------------------------------------<br>* Subroutines used by the above<br>*-------------------------------------------<br>VMBR1  SWPB R0             read several bytes from the VDP<br>       MOVB R0,@&gt;8C02      -------------------------------<br>       SWPB R0             address in R0<br>       MOVB R0,@&gt;8C02<br>LP3    MOVB @&gt;8800,*R1+    data pointer in R1<br>       DEC  R2             number of bytes in R2<br>       JH   LP3<br>       B    *R11<br>*<br>VMBW1  ORI  R0,&gt;4000       write several bytes to the VDP<br>       SWPB R0             ------------------------------<br>       MOVB R0,@&gt;8C02      address in R0<br>       SWPB R0<br>       MOVB R0,@&gt;8C02<br>LP2    MOVB *R1+,@&gt;8C00    pointer in R1<br>       DEC  R2             number of bytes in R2<br>       JH   LP2<br>       B    *R11<br> <br>*-------------------------------------------<br>* Data<br>*-------------------------------------------<br>WREGS  BSS  18                our main workspace<br>WREG1  DATA 0,0               temporary workspace for re-entrancy<br>       BSS  28<br>BUF    BSS  4                 buffer for sprite data<br> <br>YSWR   DATA WREGS             LOAD* interrupt vectors<br>YSPG   DATA CHECK<br>NOWR   DATA WREG1             vectors in use while processing the LOAD* interrupt <br>NOPG   DATA RET<br>SPRITE DATA &gt;6080,&gt;8001,&gt;D000        sprite 0 attributes<br>PATS   DATA &gt;1010,&gt;10FE,&gt;1010,&gt;1000  crosshair pattern<br>       DATA &gt;0000,&gt;001E,&gt;1814,&gt;1201  arrow pattern<br> <br>       END<br></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4><br>
<a name="text mode"></a>Text mode</h4>
<p>Things are more complicated in text mode, as no sprite can be
displayed.
We must therefore superimpose the mouse cursor to the pattern of the
characters
it overlaps. This implies to</p>
<li>Determine the position of the cursor in terms of characters.</li>
<li>Read a 2x2 characters box around this position.</li>
<li>Read the patterns of these chars into a buffer.</li>
<li>Superimpose the cursor pattern after due shifting up/down and
left/right
to point to the correct pixel.</li>
<li>Assign these patterns to 4 unused characters (e.g. characters 26 to
29).</li>
<li>Write these 4 characters into the 2x2 box.</li>
<li>When the cursor moves, restore the initial 2x2 characters and
repeat
the whole process.</li>
<p><br>
</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre>*=====================================================================<br>* Demo on how to displays a cursor pattern in text mode<br>* Assume SPROW and SPCOL were set by a routine similar to INTER above<br>*=====================================================================<br><br>* These routines set the VDP address for a write/read respectively <br>VWR    ORI  R0,&gt;4000     address in R0<br>VRD    SWPB R0<br>       LI   R14,&gt;8C02           <br>       MOVB R0,*R14      set address<br>       SWPB R0<br>       MOVB R0,*R14<br>       DECT R14          R14 is &gt;8C00: VDP write port<br>       LI   R13,&gt;8800    R13 is &gt;8800: VDP read port<br>       B    *R11<br><br>* This routine reads several bytes from the VDP<br>VMBR1  MOV  R11,R8       address in R0<br>       BL   @VRD<br>LP3    MOVB *R13,*R1+    data pointer in R1<br>       DEC  R2           number of bytes in R2<br>       JH   LP3<br>       B    *R8<br><br>* This routine writes several bytes to the VDP<br>VMBW1  MOV  R11,R8       address in R0<br>       BL   @VWR<br>LP2    MOVB *R1+,*R14    data pointer in R1<br>       DEC  R2           number of bytes in R2<br>       JH   LP2<br>       B    *R8<br><br>* This routine saves a character definition into a buffer<br>* Input: R0msb = char number<br>SAVPAT SRL  R0,8<br>       SLA  R0,3         8 bytes per char<br>       AI   R0,&gt;0800     address of pattern table<br>       LI   R2,8<br>       JMP&nbsp; VMBR1<br><br>* This routine calculates the screen position of the mouse cursor<br>* Inputs: SPROW = pixel row, SPCOL = pixel column<br>* Outputs: R0 = screen address (0-3BF), R1 = char column (0-39)<br>FPOS   MOV  @SPROW,R1    get pixel row<br>       SRL  R1,3         chars are 8-pixel high: divide by 8 <br>       MPY  @H0028,R1    40 columns in text mode<br>       MOV  @SPCOL,R1    get pixel column<br>       CLR  R0<br>       DIV  @H0006,R0    characters are 6-pixel wide<br>       MOV  R0,R1        R1 = character column<br>       A    R2,R0          <br>       MOV  R0,@SCPOS    R0 = screen address<br>       B    *11          <br><br>* This routine sets a 2x2 character box at the cursor position<br>* Inputs: R0 = screen address, R1 = 4-char buffer <br>PUT4CH MOV  R11,R10       save return address<br>       BL   @VWR         set VDP to write<br>       MOVB *R1+,*R14    write 2 chars<br>       MOVB *R1+,*R14<br>       AI   R0,40        next line<br>       BL   @VWR         set VDP to write<br>       MOVB *R1+,*R14    write two chars<br>       MOVB *R1+,*R14<br>SKRD   B    *R2</pre>
      <pre>* This routine reads a 2x2 character box at the cursor position<br>* Inputs: R0 = screen address, R1 = 4-char buffer  <br>GET4CH MOV  R11,R10<br>       LI   1,BUF1       read 4 chars<br>       BL   @VRD         set VDP to read<br>       MOVB *13,*1+      read two chars<br>       MOVB *13,*1+<br>       AI   0,40         next line<br>       BL   @VRD         set VDP to read<br>       MOVB *13,*1+      read 2 chars<br>       MOVB *13,*1+<br>       B    *R10</pre>
      <pre>* This routine displays the cursor pattern on screen<br>* Inputs: pixel row in SPROW, pixel column in SPCOL<br>PUTCUR MOV  R11,R9       save return point<br>       BL   @NOCUR       erase existing cursor, if any<br>       BL   @FPOS        find new cursor position<br>       BL   @GET4CH      read a 2x2 box into a buffer<br>       LI   R3,BUF1      copy char patterns into another buffer<br>       MOVB *R3,R0       get char 1<br>       LI   R1,BUF2      pattern buffer<br>       BL   @SAVPAT      save char pattern<br>       MOVB @2(R3),R0    ditto for char 3 (watch the order!)<br>       BL   @SAVPAT<br>       MOVB @1(R3),R0    ditto for char 2<br>       BL   @SAVPAT<br>       MOVB @3(R3),R0    ditto for char 4<br>       BL   @SAVPAT<br><br>       MOV  @SPCOL,R1     Now add cursor pattern. Get pixel column<br>       CLR  R0<br>       DIV  @H0006,R0     chars are 6-pixels wide<br>       MOV  R1,R0         pixel column inside character<br>       MOV  @SPROW,R1     get pixel row<br>       ANDI R1,&gt;0007      pixel line in character<br>       AI   R1,BUF2+16    pattern for char 2, at appropriate pixel line<br>       LI   R2,PATRN      cursor pattern<br>       LI   R3,8          cursor is 8-pixel high<br>LHH0   CLR  R5<br>       MOVB *R2+,R5       get 1 line from the cursor pattern <br>       SRC  R5,0          shift it to begin at appropriate pixel column <br>       SOCB R5,@-16(R1)   superimpose it on char 1 (or 3)<br>       SLA  R5,6          the remainder will be on char 2 (or 4)<br>       SOCB R5,*R1+       superimpose it on char 2 (or 4)<br>       DEC  R3<br>       JNE  LHH0<br><br>       LI   R0,&gt;08D0      address of pattern for char 26-29<br>       LI   R1,BUF2<br>       LI   R2,32<br>       BL   @VMBW1        set their patterns<br>       MOV  @SCPOS,R0     display char 26-29 at cursor position<br>       LI   R1,SPCH<br>       BL   @PUT4CH<br>       B    *R9          </pre>
      <pre>* This routine erases the cursor displayed by the above<br>NOCUR  MOV  R11,R9<br>       MOV  SCPOS,R0      screen position of the cursor<br>       LI   R1,BUF1       buffer where the 4 chars were saved<br>       MOV  *R1,*R1       but were they?<br>       JEQ  SK1           not yet: no cursor on screen<br>       BL   @PUT4CH       restore them<br>       CLR  @BUF1         flag: no cursor on screen<br>SK1    B    *R9</pre>
      <pre>SCPOS  DATA 0             current screen address of the cursor<br>SPROW  DATA 0             pixel row for the cursor<br>SPCOL  DATA&nbsp;0             pixel column for the cursor<br>BUF1   DATA 0,0           buffer for 4 chars<br>BUF2   BSS  32            buffer for 4 char patterns</pre>
      <pre>SPCH   BYTE 26,28,27,29   characters that make up the cursor<br>PATRN  DATA &gt;2020,&gt;F820,&gt;2000,&gt;0000  cursor pattern<br>H0028  DATA&nbsp;&gt;0028         constant: 40 columns<br>H0006  DATA &gt;0006         constant: 6 pixels</pre>
      </td>
    </tr>
  </tbody>
</table>
<address><br>
Revision 1. 6/20/99. Ok to release</address>
<center>
<p><a href="titechpages.htm">Back to the TI-99/4A Tech Pages</a></p>
</center>
</body>
</html>
