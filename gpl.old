<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
  <title></title>
  <meta name="Author" content="">
  <meta name="GENERATOR"
 content="Mozilla/3.04Gold (Win95; U) [Netscape]">
</head>
<body>
<h1 align="center"><a
 href="http://www.nouspikel.com/ti99/titechpages.htm"><img
 src="logo.jpg" style="border: 0px solid ; height: 33px; width: 95px;"
 title="" alt=""></a></h1>
<h1>GPL: Graphic Programming Language</h1>
<p><a href="#pad">Scratch-pad usage<br>
</a><a href="#status">Status byte<br>
</a><a href="#stacks">Stacks<br>
</a><a href="#operands">Operands<br>
</a><a href="#opcodes%20table">Standard opcodes<br>
</a><a href="#fmt%20table">Fmt opcodes<br>
</a><a href="#instr%20table">Common assembly instructions</a></p>
<p><a href="gpl2.htm">Using the XML instruction<br>
</a><a href="gpl2.htm#IO">Using the I/O instruction<br>
</a><a href="gpl2.htm#COIN">Using the COIN instruction<br>
</a><a href="gpl2.htm#Dealing%20with%20sprites">Using sprites</a></p>
<p><a href="gpl2.htm#PAD%20basic">Scratch-pad dedicated addresses<br>
</a><a href="gpl2.htm#GROM%20subroutines">GPL routines in console GROMs<br>
</a><a href="gpl2.htm#GROM%20data">Usefull data in console GROMs</a></p>
<h2><br>
Introduction</h2>
<p>GPL is the language of the GROMs. Since these map at a single byte
in
CPU memory they are obviously not suitable to contain assembly
language.
Texas Instruments thus designed a special, low-level interpreted
language
they called GPL, for "Graphic Programming Language".</p>
<p>GPL is an 8-bit language: instructions are 1-byte long (not counting
the operands), and they deal with bytes. But since the TI-99/4A is a
16-bit
machine, GPL was designed so that most instructions can also handle 2
bytes
at a time. However, there is no requirement for these two bytes to be
aligned
at a word boundary, on an even address, as is the case in assembly.</p>
<p>As its name suggests, GPL is mainly screen-oriented. Accessing the
VDP
memory is very easy: <tt>CLR V@&gt;0020</tt> will clear a byte in VDP
memory
at address &gt;0020. No need to pass the address to the VDP: this is
taken
care of by the interpreter. Furthermore, the GPL instruction FMT will
put
the interpreter in a special mode where every instruction deals with
screen
ouput.</p>
<p>Finally, GPL is more compact than assembly language: a two-byte GPL
instruction can do the job of a whole assembly subroutine (because it
calls
such a routine in the interpreter). This is slightly less obvious when
dealing with CPU memory: the prefered target memory is the scratch-pad,
i.e. a 16-bit memory located at addresses &gt;8300-83FF. Although GPL
can
access the whole memory range, addresses out of the scratch-pad take
more
room in the program and thus slow its execution.</p>
<p>There is a drawback though (there always is): GPL is slow when
compared
to assembly language. This is of course because assembly language is
executed
directly by the TMS9900 microprocessor, whereas GPL must be interpreted
by an assembly program located in the console ROMs. In fact, most of
the
ROM in the TI-99/4A is dedicated to the GPL interpreter.</p>
<p>Nevertheless, GPL is a nice language to learn. If you already know
assembly,
you'll master it in a couple hours. And if you don't know assembly, GPL
is a more gentle, user-friendly way to approach low-level languages. Of
course, if you want to program in GPL, you'll nee two things:</p>
<ul>
  <li>A GRAM device, into which you can place your GPL programs to test
them.
There are ways around it, programs that will let you execute GPL from
cpu
memory, but you'd better go for the real thing.</li>
  <li>A GPL assembler, i.e. a program that translates the human
managable
opcodes and operands into the serie of bytes that constitutes a GPL
program.
There are several such assemblers around. Unfortunately, information on
GPL was initially hard to find (to say the least: personnally I had to
disassemble the interpreter to figure out the meaning of some opcodes),
so the programmers often adopted different names for the same
instruction:
    <tt>MUL </tt>vs <tt>MPY </tt>for multiply, etc. </li>
</ul>
<p>Amoug the first GPL assemblers was that of Michael Weiand: it had
its
limitations but it set a standard. A more recent one is the RAG
macro-assembler:
as usual with R.A. Green, this is a finely chiseled piece of software
(I
shouldn't praise a competitor but had I been aware of this assembler
earlier,
I woud never have written mine...). Finally, there is one in my GPL
package,
that you can <a href="download.htm#gplassm">download </a>from this
site.</p>
<p><br>
And now let's see some basic notions on GPL:</p>
<p>A GPL instruction consists in a short mnemonic, called <b>opcode </b>(operation
code), optionally followed by one or two <b>operands</b>. The opcode
defines
the operation to be performed: add, substract, scan the keyboard, call
a subroutine, etc. The operand(s) tell the GPL interpreter where to
find
the data for this operation: e.g. add what to what.</p>
<p>Most assembler let you place a <b>label </b>left of the opcode.
This
is a convenient way to branch at a given place in your program, without
having to calculate at which memory address it corresponds. Instead of
typing <tt>BR @&gt;6086</tt>, you would type <tt>BR @PLACE1</tt>
where
PLACE1 is a label you placed in your program. You could also define
labels
that correspond to constants, or to addresses in CPU or VDP memory, but
this requires a special instruction (generally <tt><a href="#EQU">EQU</a></tt>).</p>
<p>Finally, most assemblers allow you to place <b>comments </b>after
the
last operand. Programs written in low-level languages can be fairly
hard
to understand, even when it's your program, that you set aside for a
few
months. Therefore it is critical that you comment almost every line,
explaining
to yourself what you are doing.</p>
<p>A GPL <b>source file</b> consists in a series of GPL instructions,
one
per line, and possibly of some assembly-time instructions (i.e.
commands
for the assembler). The GPL assembler reads this file and uses it to
create
a <b>code file</b>, that contains the numeric equivalent of your
program:
an opcode is translated into a single byte, operands may require one or
more bytes. A GPL loader then places this program in your GRAM device
where
it can be executed. Finally, you could dump the content of your GRAM
device
into a <b>memory-image file</b>, so that it can be quickly reloaded
without
the loader having to process the code file again.</p>
<h2><br>
<br>
<a name="pad"></a>Scratch-pad usage</h2>
<p>The GPL interpreter makes a heavy use of the scratch-pad memory at
addresses
&gt;8300-&gt;83FF. Many bytes have a <a href="gpl2.htm#PAD%20general">special
function</a> and/or are directly used by the interpreter (for instance,
&gt;83E0-83FF are the workspace registers of the interpreter). Others
are
free for you to use: mainly, these are adresses from &gt;8300 to
&gt;836D.
You've much less choice withTI-Basic or Extended Basic that reserve <a
 href="gpl2.htm#PAD%20basic">most
of these</a> for their own use.</p>
<h2><br>
<a name="status"></a>Status byte</h2>
<p>The GPL interpreter does not use the status register in the TMS9900
CPU, instead is uses a status byte located in the scratch-pad at
address
&gt;837C. Its stucture is the following:</p>
<table border="1">
  <tbody>
    <tr>
      <td>High</td>
      <td>Grt</td>
      <td>Cnd</td>
      <td>Car</td>
      <td>Ovf</td>
      <td>n.u.</td>
      <td>n.u.</td>
      <td>n.u.</td>
    </tr>
  </tbody>
</table>
<p><b>High </b>means logically higher, i.e. &gt;FF is higher than
&gt;01.<br>
<b>Grt </b>means greater than for signed operations, i.e &gt;01 is
greater
than &gt;FF (-1).<br>
<b>Car </b>means carry.<br>
<b>Ovf </b>means overflow.<br>
<b>Cnd </b>stands for condition: this bit is tested by conditional
branch
instructions (BR and BS).<br>
The last 3 bits are not used.</p>
<p>The status byte may or may not be affected by GPL instructions:</p>
<ul>
  <li>Status unchanged with: <tt>ABS NEG CLR INV FETC CASE PUSH MPY ST
EX
SRA SRL SLL SRC RND BACK ALL FMT XML CONT EXEC RTB MOVE</tt> and fmt
opcodes
  </li>
  <li>Cnd bit reset with: <tt>B BR BSS CALL EXIT RTGR RTN SWGR</tt></li>
  <li>Cnd modified with: <tt>CAR CEQ CGT CGTE CH CHE CLOG COIN GT HIGH
OVF
RTNC SCAN </tt></li>
  <li>Status modified with: <tt>ADD AND CZ DEC DECT DIV INC INCT SUB
OR XOR
    </tt></li>
</ul>
<p>The Cnd bit can be tested with the <tt>BR </tt>and <tt>BS </tt>instructions.
The other bits can transfered into the Cnd bit with dedicated opcodes (<tt>HIGH,
GT, CAR, OVF</tt>) and then tested with <tt>BR </tt>or <tt>BS</tt>.
This
transfer is implicit with some opcodes (e.g. <tt>CGT </tt>sets Cnd if
the
source operand is greater that the second operand)</p>
<h2><br>
<a name="stacks"></a>GPL Stacks</h2>
<p>GPL uses two stacks, located in the scratch-pad memory: the
subroutine
stack and the data stack. </p>
<h4>Subroutine stack</h4>
<p>The first one serves to store the return address of procedures
called
with <tt>CALL</tt>. The address will be retrieved from the stack by a <tt>RTN
</tt>or <tt>RTNC </tt>instruction and used to return to the calling
point.
<tt>SWGR </tt>and <tt>RTGR </tt>also make use of this stack but
store the
GROM base in addition to the return address.</p>
<p>The stack pointer is found in byte &gt;8373. It points to the
current
return address, i.e. <tt>CALL </tt>must increment it by two before to
save
a new return address, whereas <tt>RTN </tt>reads the address directly
and
decrement &gt;8373 by two afterwards. </p>
<p>The subroutine stack normally grows upwards from &gt;8380, but this
is not an absolute requirement: theoretically it could be located
anywhere
in the scratch-pad. Note that the GPL interpreter does not check for
stack
overflow, nor for empty stack: a long serie of nested <tt>CALL </tt>may
therefore crash the interpreter...</p>
<h4><br>
Data stack</h4>
<p>This stack is meant for use by the programmer. Its pointer is to be
found in byte &gt;8372 and the user can push a byte on it with the GPL
opcode <tt>PUSH</tt>. Here also, &gt;8372 points at the current byte,
i.e.
the pointer is incremented (by one) before saving the byte. For some
strange
reason, the symetrical <tt>POP </tt>instruction does not exist
(although
my assembler simulates it). You'll have to retrieve the byte "manually"
with <tt>ST *&gt;8372,<i>dest</i></tt><i> </i>and then decrement the
pointer
with <tt>DEC @&gt;8372</tt>.</p>
<p>This stack is normally located at &gt;83A0 and grows upwards with no
check for overflow. Be carefull with that one: bytes &gt;83C4-C5
contain
the interrupt routine hook. Placing a non-zero value in there will
cause
the interrupt service routine to branch at the corresponding address in
CPU memory (now there's an idea...). Again, it is possible to relocate
this stack by just changing the value of the pointer in &gt;8372, but
it
has to be in the scratch-pad since the pointer is a byte.</p>
<h2><br>
<a name="operands"></a>Operands</h2>
<p>Most GPL opcodes can use a source and a destination arguments, the
major
difference between these two being that a source argument can be
immediate,
whereas a destination cannot.</p>
<p>There are many types of arguments, each consist in several symbols
indicating
the argument type (@,*,V@,V*, etc) followed by an expression.</p>
<h4>Symbolic: @&gt;8342</h4>
<p>Specified address in cpu memory.</p>
<p>Uses 1 byte if the address is between &gt;8300 and &gt;837F, two
bytes
if it's between &gt;8380 and &gt;91FF, three bytes otherwise.</p>
<pre>Example:<br>       CLR  @&gt;8300       Clears byte &gt;8300</pre>
<h4><br>
Indirect: *&gt;8342 </h4>
<p>Scratch-pad address whose least significant byte is found at the
specified
address.Note that the final address <i>must </i>be in the scratch pad.</p>
<p>Uses 2 bytes if the specified address is between &gt;8300 and
&gt;81FF,
3 bytes otherwise.</p>
<pre>Example: If &gt;8342 contains &gt;56, then<br>       CLR  *&gt;8342       clears byte &gt;8356. <br></pre>
<h4><br>
<br>
Indexed symbolic: @&gt;0005(@&gt;8342)</h4>
<p>Address calculated by adding the symbolic value (5 in the example)
to
the content of the index address (in our example &gt;8342-8343).</p>
<p>The index address <i>must </i>be in the scratch-pad, and can
therefore
be abreviated as (@&gt;42) with some assemblers.</p>
<p>Uses 3 or 4 bytes, according if the symbolic value is between
&gt;8300
and &gt;91FF or not.</p>
<pre>Example: if &gt;8342-8343 contain the value &gt;8300, then<br>       CLR  @5(@&gt;42)       clears byte &gt;8305 (i.e. &gt;8300 + &gt;0005).</pre>
<h4><br>
Indexed indirect: *&gt;0005(@&gt;42)</h4>
<p>Scratch-pad address whose least significant byte is to be found at
the
address calculated by adding the symbolic value (here &gt;0005) to the
content of the index address (here &gt;8342, the &gt;83 being optional
for indexes).</p>
<p>Uses 3 or 4 bytes, according to symbolic value.</p>
<pre>Example: if &gt;8342-8343 contains &gt;8300, and &gt;8305 contains &gt;12, then<br>       CLR  *5(@&gt;42)        is equivalent to <br>       CLR  *&gt;8305          which clears byte &gt;8312</pre>
<h4><br>
VDP symbolic: V@&gt;0128</h4>
<p>Specified address in VDP memory (here &gt;0128).</p>
<p>Uses 2 bytes if below &gt;0F00, 3 bytes otherwise.</p>
<pre>Example:<br>       CLR  V@&gt;0123       clears VDP byte &gt;0123</pre>
<h4><br>
VDP indirect: V*&gt;8301</h4>
<p>VDP address to be found in scratch-pad, at the specified address
(here
&gt;8301-8302).</p>
<p>Uses 2 bytes if specified address is between &gt;8300 and &gt;91FF,
3 bytes otherwise.</p>
<pre>Example: if &gt;8301-02 contains &gt;0123, then<br>       CLR  V*&gt;8301       clears VDP byte &gt;0123</pre>
<h4><br>
VDP indexed symbolic: V@&gt;1111(@&gt;8301)</h4>
<p>VDP address calculated by adding the symbolic value to the content
of
the index. </p>
<p>Uses 3 or 4 bytes, according if the symbolic value is below &gt;0F00
or not.</p>
<pre>Example: if &gt;8301-8302 contain &gt;2222, then<br>       CLR  V@&gt;1111(@&gt;01)       clears VDP byte &gt;3333</pre>
<h4><br>
VDP indexed indirect: V*&gt;8344(@&gt;01)</h4>
<p>VDP address to be found in the scratch-pad address calculated by
adding
the symbolic value to the content of the index. </p>
<p>Uses 3 or 4 bytes, according to the symbolic value.</p>
<pre>Example: If &gt;8301-8302 contain &gt;0010, and &gt;8354-8355 contain &gt;1000, then<br>       CLR  V*&gt;8344(@&gt;01)       is equivalent to <br>       CLR  V*&gt;8354             which clears VDP byte &gt;1000</pre>
<h4><br>
Immediate value: &gt;1234</h4>
<p>This may be a byte or a word value, according if the opcode is
Doubled
or not. This type of argument cannot be used for destination arguments.</p>
<pre>Examples:<br>       ST    &gt;14,@&gt;8300        Stores the value &gt;14 in byte &gt;8300<br>       DST  &gt;1234,@&gt;8300       Stores the value &gt;1234 in bytes &gt;8300-8301</pre>
<h4><br>
Grom address: G@&gt;0010</h4>
<p>Some opcodes require an address in GROM/GRAM memory as an operand.
These
are:</p>
<li>the branching instructions: <tt>B, BR, BS, CALL</tt>, and <tt>SWGR</tt>.</li>
<li>the <tt>LOOP </tt>instruction in FMT mode.</li>
<li>the <tt>FETC </tt>instruction (used by subroutines to fetch data
bytes
following the <tt>CALL</tt>)</li>
<li>the <tt>MOVE </tt>instruction.</li>
<p>In principle, the syntax is G@<i>address</i>, however since these
these
instuction have no other possible address mode (except for <tt>MOVE</tt>),
some assemblers will let you ommit the G or even the G@.</p>
<h4><br>
Move arguments</h4>
<p>The <tt>MOVE </tt>opcode can use special argument types, to access
G
memory or VDP registers. See the <a href="#MOVE">MOVE </a>opcode for
more
details.</p>
<h2><br>
<a name="opcodes table"></a>GPL OPCODES</h2>
<table border="1">
  <tbody>
    <tr>
      <th>Opcode</th>
      <th>Arguments</th>
      <th>Dob</th>
      <th>Stat</th>
      <th>Meaning</th>
    </tr>
    <tr>
      <td><a href="#ABS">ABS</a></td>
      <td><i>dest</i></td>
      <td>D</td>
      <td>=</td>
      <td>Absolute value of <i>destination</i></td>
    </tr>
    <tr>
      <td><a href="#ADD">ADD</a></td>
      <td><i>source,dest</i></td>
      <td>D</td>
      <td>S</td>
      <td>Addition of <i>source </i>to <i>destination </i>(a.k.a. A)</td>
    </tr>
    <tr>
      <td><a href="#ALL">ALL</a></td>
      <td><i>byte</i></td>
      <td>.</td>
      <td>=</td>
      <td>Fills screen with <i>byte </i>(&gt;000-2FF in VDP memory)</td>
    </tr>
    <tr>
      <td><a href="#AND">AND</a></td>
      <td><i>source,dest</i></td>
      <td>D</td>
      <td>S</td>
      <td>Bitwise "and" of <i>source </i>and <i>destination </i>operands</td>
    </tr>
    <tr>
      <td><a href="#B">B</a></td>
      <td><i>address</i></td>
      <td>.</td>
      <td>0</td>
      <td>Imperative branch to <i>address </i>in GROM</td>
    </tr>
    <tr>
      <td><a href="#BACK">BACK</a></td>
      <td><i>byte</i></td>
      <td>.</td>
      <td>=</td>
      <td>Set text/screen colors: <i>byte </i>= &gt;TS</td>
    </tr>
    <tr>
      <td><a href="#BR">BR</a></td>
      <td><i>address</i></td>
      <td>.</td>
      <td>0</td>
      <td>Branch to <i>address </i>in same GROM if cnd=0</td>
    </tr>
    <tr>
      <td><a href="#BS">BS</a></td>
      <td><i>address</i></td>
      <td>.</td>
      <td>0</td>
      <td>Branch to <i>address </i>in same GROM if cnd=1</td>
    </tr>
    <tr>
      <td><a href="#CALL">CALL</a></td>
      <td><i>address</i></td>
      <td>.</td>
      <td>0</td>
      <td>Call subprogram at <i>address</i></td>
    </tr>
    <tr>
      <td><a href="#CAR">CAR</a></td>
      <td>.</td>
      <td>.</td>
      <td>c</td>
      <td>Transfer carry bit in cnd (a.k.a. CARR)</td>
    </tr>
    <tr>
      <td><a href="#CASE">CASE</a></td>
      <td><i>dest</i></td>
      <td>D</td>
      <td>=</td>
      <td>Skip <i>dest </i>words in program</td>
    </tr>
    <tr>
      <td><a href="#CEQ">CEQ</a></td>
      <td><i>source,dest</i></td>
      <td>D</td>
      <td>c</td>
      <td>Are <i>source </i>and <i>dest </i>equal?</td>
    </tr>
    <tr>
      <td><a href="#CGT">CGT</a></td>
      <td><i>source,dest</i></td>
      <td>D</td>
      <td>c</td>
      <td>Is <i>source </i>greater than <i>dest</i>?</td>
    </tr>
    <tr>
      <td><a href="#CGTE">CGTE</a></td>
      <td><i>source,dest</i></td>
      <td>D</td>
      <td>c</td>
      <td>Is <i>source </i>greater or equal to dest (a.k.a. CGE)</td>
    </tr>
    <tr>
      <td><a href="#CH">CH</a></td>
      <td><i>source,dest</i></td>
      <td>D</td>
      <td>c</td>
      <td>Is <i>source </i>higher than <i>dest</i>?</td>
    </tr>
    <tr>
      <td><a href="#CHE">CHE</a></td>
      <td><i>source,dest</i></td>
      <td>D</td>
      <td>c</td>
      <td>Is <i>source </i>higher or equal to <i>dest</i>?</td>
    </tr>
    <tr>
      <td><a href="#CLOG">CLOG</a></td>
      <td><i>source,dest</i></td>
      <td>D</td>
      <td>c</td>
      <td>Set cnd if <i>source "</i>and" <i>dest </i>= 0</td>
    </tr>
    <tr>
      <td><a href="#CLR">CLR</a></td>
      <td><i>dest</i></td>
      <td>D</td>
      <td>=</td>
      <td>Clear <i>dest</i></td>
    </tr>
    <tr>
      <td><a href="#COIN">COIN</a></td>
      <td><i>source,dest</i></td>
      <td>D</td>
      <td>c</td>
      <td>Check for screen objects coincidence</td>
    </tr>
    <tr>
      <td><a href="#CONT">CONT</a></td>
      <td>.</td>
      <td>.</td>
      <td>=</td>
      <td>Continue Basic execution</td>
    </tr>
    <tr>
      <td><a href="#CZ">CZ</a></td>
      <td><i>dest</i></td>
      <td>D</td>
      <td>c</td>
      <td>Compare <i>dest </i>to zero</td>
    </tr>
    <tr>
      <td><a href="#DEC">DEC</a></td>
      <td><i>dest</i></td>
      <td>D</td>
      <td>S</td>
      <td>Decrement <i>dest</i></td>
    </tr>
    <tr>
      <td><a href="#DECT">DECT</a></td>
      <td><i>dest</i></td>
      <td>D</td>
      <td>S</td>
      <td>Decrement <i>dest </i>by two</td>
    </tr>
    <tr>
      <td><a href="#DIV">DIV</a></td>
      <td><i>source,dest</i></td>
      <td>D</td>
      <td>S</td>
      <td>Divides <i>dest </i>by <i>source</i></td>
    </tr>
    <tr>
      <td><a href="#EX">EX</a></td>
      <td><i>source,dest</i></td>
      <td>D</td>
      <td>=</td>
      <td>Exchanges <i>source </i>and <i>dest</i></td>
    </tr>
    <tr>
      <td><a href="#EXEC">EXEC</a></td>
      <td>.</td>
      <td>.</td>
      <td>=</td>
      <td>Begins execution of Basic</td>
    </tr>
    <tr>
      <td><a href="#EXIT">EXIT</a></td>
      <td>.</td>
      <td>.</td>
      <td>0</td>
      <td>System reset</td>
    </tr>
    <tr>
      <td><a href="#FETC">FETC</a></td>
      <td><i>dest</i></td>
      <td>D</td>
      <td>=</td>
      <td>Fetch next GRAM byte into <i>dest</i></td>
    </tr>
    <tr>
      <td><a href="#FMT">FMT</a></td>
      <td>.</td>
      <td>.</td>
      <td>=</td>
      <td>Enter Format sub-interpreter</td>
    </tr>
    <tr>
      <td><a href="#GT">GT</a></td>
      <td>.</td>
      <td>.</td>
      <td>c</td>
      <td>Transfer gt bit in cnd</td>
    </tr>
    <tr>
      <td><a href="#HIGH">HIGH</a></td>
      <td>.</td>
      <td>.</td>
      <td>c</td>
      <td>Transfer high bit in cnd (= H)</td>
    </tr>
    <tr>
      <td><a href="#INC">INC</a></td>
      <td><i>dest</i></td>
      <td>D</td>
      <td>S</td>
      <td>Increment <i>dest</i></td>
    </tr>
    <tr>
      <td><a href="#INCT">INCT</a></td>
      <td><i>dest</i></td>
      <td>D</td>
      <td>S</td>
      <td>Increment <i>dest </i>by two</td>
    </tr>
    <tr>
      <td><a href="#INV">INV</a></td>
      <td><i>dest</i></td>
      <td>D</td>
      <td>=</td>
      <td>Invert <i>dest</i></td>
    </tr>
    <tr>
      <td><a href="#I/O">I/O</a></td>
      <td><i>source,dest</i></td>
      <td>D</td>
      <td>=</td>
      <td>Special operation <i>source</i>, operands in <i>dest</i></td>
    </tr>
    <tr>
      <td><a href="#MOVE">MOVE</a></td>
      <td><i>source,msrc,mdest </i></td>
      <td>.</td>
      <td>.</td>
      <td>Moves <i>source </i>bytes from <i>msrc </i>to <i>mdest </i>(may
be
G or Vreg)</td>
    </tr>
    <tr>
      <td><a href="#MPY">MPY</a></td>
      <td><i>source,dest</i></td>
      <td>D</td>
      <td>=</td>
      <td>Multiply <i>dest </i>by <i>source </i>(a.k.a. MUL a.k.a.
M)</td>
    </tr>
    <tr>
      <td><a href="#OR">OR</a></td>
      <td><i>source,dest</i></td>
      <td>D</td>
      <td>S</td>
      <td>Bitwise "or" of <i>source </i>and <i>dest</i></td>
    </tr>
    <tr>
      <td><a href="#OVF">OVF</a></td>
      <td>.</td>
      <td>.</td>
      <td>c</td>
      <td>Transfer overflow bit in cnd</td>
    </tr>
    <tr>
      <td><a href="#PARS">PARS</a></td>
      <td><i>byte</i></td>
      <td>.</td>
      <td>.</td>
      <td>Parse basic statement until token <i>byte </i>is encountered</td>
    </tr>
    <tr>
      <td><a href="#PUSH">PUSH</a></td>
      <td><i>dest</i></td>
      <td>.</td>
      <td>=</td>
      <td>Save <i>dest </i>on VDP stack</td>
    </tr>
    <tr>
      <td><a href="#RND">RAND</a></td>
      <td><i>byte</i></td>
      <td>.</td>
      <td>=</td>
      <td>Get random number from 0 to <i>byte </i>(a.k.a.RND)</td>
    </tr>
    <tr>
      <td><a href="#RTGR">RTGR</a></td>
      <td>.</td>
      <td>.</td>
      <td>0</td>
      <td>Return from a SWGR</td>
    </tr>
    <tr>
      <td><a href="#RTN">RTN</a></td>
      <td>.</td>
      <td>.</td>
      <td>0</td>
      <td>Return from a CALL with cnd cleared</td>
    </tr>
    <tr>
      <td><a href="#RTNC">RTNC</a></td>
      <td>.</td>
      <td>.</td>
      <td>=</td>
      <td>Return from a CALL with cnd intact</td>
    </tr>
    <tr>
      <td><a href="#SCAN">SCAN</a></td>
      <td>.</td>
      <td>.</td>
      <td>c</td>
      <td>Keybord scan</td>
    </tr>
    <tr>
      <td><a href="#SLA">SLA</a></td>
      <td><i>source,dest</i></td>
      <td>D</td>
      <td>=</td>
      <td>Shift <i>dest </i>left by <i>source </i>bits (a.k.a. SLL)</td>
    </tr>
    <tr>
      <td><a href="#SRA">SRA</a></td>
      <td><i>source,dest</i></td>
      <td>D</td>
      <td>=</td>
      <td>Shift <i>dest </i>right arithmetically, by <i>source </i>bits</td>
    </tr>
    <tr>
      <td><a href="#SRC">SRC</a></td>
      <td><i>source,dest</i></td>
      <td>D</td>
      <td>=</td>
      <td>Shift <i>dest </i>right circular, by <i>source </i>bits</td>
    </tr>
    <tr>
      <td><a href="#SRL">SRL</a></td>
      <td><i>source,dest</i></td>
      <td>D</td>
      <td>=</td>
      <td>Shift <i>dest </i>right logically, by <i>source </i>bits</td>
    </tr>
    <tr>
      <td><a href="#ST">ST</a></td>
      <td><i>source,dest</i></td>
      <td>D</td>
      <td>=</td>
      <td>Copy <i>source </i>in <i>dest</i></td>
    </tr>
    <tr>
      <td><a href="#SUB">SUB</a></td>
      <td><i>source,dest</i></td>
      <td>D</td>
      <td>S</td>
      <td>Substract <i>source </i>to <i>dest </i>(a.k.a. S)</td>
    </tr>
    <tr>
      <td><a href="#SWGR">SWGR</a></td>
      <td><i>source,dest</i></td>
      <td>D</td>
      <td>0</td>
      <td>Branch to address in <i>dest</i>, using GROM port in <i>source</i></td>
    </tr>
    <tr>
      <td><a href="#XG0-3">XG-0 to XG-3</a></td>
      <td><i>dest</i></td>
      <td>D</td>
      <td>?</td>
      <td>Extended GPL. Do not use</td>
    </tr>
    <tr>
      <td><a href="#XG4-E">XG-4 to XG-E</a></td>
      <td>?</td>
      <td>D</td>
      <td>?</td>
      <td>Extended GPL. Do not use</td>
    </tr>
    <tr>
      <td><a href="#XG-F">XG-F or XG-G</a> </td>
      <td><i>source,dest</i></td>
      <td>D</td>
      <td>?</td>
      <td>Extended GPL. Do not use</td>
    </tr>
    <tr>
      <td><a href="#XG-$">XG-$</a></td>
      <td>.</td>
      <td>.</td>
      <td>?</td>
      <td>Extended GPL, special entry point. Do not use</td>
    </tr>
    <tr>
      <td><a href="#XML">XML</a></td>
      <td><i>byte</i></td>
      <td>.</td>
      <td>=</td>
      <td>Execute machine language procedure</td>
    </tr>
    <tr>
      <td><a href="#XOR">XOR</a></td>
      <td><i>source,dest</i></td>
      <td>D</td>
      <td>S</td>
      <td>Bitwise "exclusive or" between <i>source </i>and <i>dest</i></td>
    </tr>
  </tbody>
</table>
<p><b>Status<br>
</b>= Status not affected<br>
S Status modified<br>
c Cnd bit modified<br>
0 Cnd bit reset<br>
? Unknown</p>
<p><b>Dob<br>
</b>D opcodes can affect 2 bytes if a leading D is added (e.g. DINC
instead
of INC).</p>
<h3><br>
<br>
<a name="fmt table"></a>FMT subinterpreter opcodes</h3>
<p>These opcodes become active once a FMT instruction has been executed
and remain so until a FEND is encoutered. During this time all the
regular
opcodes become invalid. The interpreter thus enters a special mode that
deals exclusively with screen access.</p>
<table border="1">
  <tbody>
    <tr>
      <th>Opcode</th>
      <th>Argument</th>
      <th>Mode</th>
      <th>Meaning</th>
    </tr>
    <tr>
      <td><a href="#COL">COL</a></td>
      <td><i>value</i></td>
      <td>Std</td>
      <td>Set column pointer</td>
    </tr>
    <tr>
      <td><a href="#COL=">COL=</a></td>
      <td><i>value</i></td>
      <td>Std</td>
      <td>Adjust column pointer *</td>
    </tr>
    <tr>
      <td><a href="#FEND">FEND</a></td>
      <td>.</td>
      <td>Both</td>
      <td>Exit format sub-interpreter</td>
    </tr>
    <tr>
      <td><a href="#RPTB">FOR</a></td>
      <td><i>value</i></td>
      <td>Both</td>
      <td>Repeat block of instructions <i>value </i>times (a.k.a.
RPTB)</td>
    </tr>
    <tr>
      <td><a href="#HCHA">HCHA</a></td>
      <td><i>value,char</i></td>
      <td>Both</td>
      <td>Display <i>value </i>occurences of <i>char</i></td>
    </tr>
    <tr>
      <td><a href="#HTEX">HSTR</a></td>
      <td><i>value,dest</i></td>
      <td>Both</td>
      <td>Display <i>value </i>chars from <i>dest </i>(a.k.a. HTEX
value,dest)</td>
    </tr>
    <tr>
      <td><a href="#HTEX">HTEX</a></td>
      <td><i>string</i></td>
      <td>Both</td>
      <td>Display <i>string</i></td>
    </tr>
    <tr>
      <td><a href="#HTEX">HTEX</a></td>
      <td><i>value,dest</i></td>
      <td>Both</td>
      <td>Display <i>value </i>chars from <i>destination </i>operand</td>
    </tr>
    <tr>
      <td><a href="#COL+">ICOL</a></td>
      <td><i>value</i></td>
      <td>Both</td>
      <td>Increment column pointer by <i>value </i>(a.k.a. COL+)</td>
    </tr>
    <tr>
      <td><a href="#ROW+">IROW</a></td>
      <td><i>value</i></td>
      <td>Std</td>
      <td>Increment row pointer by <i>value </i>(a.k.a. ROW+)</td>
    </tr>
    <tr>
      <td><a href="#LOOP">LOOP</a></td>
      <td>[<i>address</i>]</td>
      <td>Both</td>
      <td>End of a RPTB loop. Loop to <i>address </i>(a.k.a. NEXT) </td>
    </tr>
    <tr>
      <td><a href="#LOOP">NEXT</a></td>
      <td>[<i>address</i>]</td>
      <td>Both</td>
      <td>End of a FOR loop. Loop to <i>address </i>(a.k.a. LOOP)</td>
    </tr>
    <tr>
      <td><a href="#ROW">ROW</a></td>
      <td><i>value</i></td>
      <td>Std</td>
      <td>Set row pointer to <i>value</i></td>
    </tr>
    <tr>
      <td><a href="#ROW=">ROW=</a></td>
      <td><i>value</i></td>
      <td>Std</td>
      <td>Adjust row pointer to <i>value </i>*</td>
    </tr>
    <tr>
      <td><a href="#RPTB">RPTB</a></td>
      <td><i>value</i></td>
      <td>Both</td>
      <td>Repeat block of instructions <i>value </i>times (a.k.a. FOR)</td>
    </tr>
    <tr>
      <td><a href="#SCRO">SCRO</a></td>
      <td><i>byte</i></td>
      <td>Both</td>
      <td>Set screen offset as <i>byte</i></td>
    </tr>
    <tr>
      <td><a href="#SCRO">SCRO</a></td>
      <td><i>dest</i></td>
      <td>Both</td>
      <td>Set screen offset from <i>destination </i>operand</td>
    </tr>
    <tr>
      <td><a href="#TCOL">TCOL</a></td>
      <td><i>value</i></td>
      <td>Text</td>
      <td>Adjust column pointer to <i>value </i>*</td>
    </tr>
    <tr>
      <td><a href="#TPOS">TPOS</a></td>
      <td><i>value1,value2</i></td>
      <td>Text</td>
      <td>Set row and column pointers to <i>value1 </i>and <i>value2
      </i>*</td>
    </tr>
    <tr>
      <td><a href="#TROW">TROW</a></td>
      <td><i>value</i></td>
      <td>Text</td>
      <td>Increment row pointer by <i>value </i>*</td>
    </tr>
    <tr>
      <td><a href="#VCHA">VCHA</a></td>
      <td><i>value,char</i></td>
      <td>Both</td>
      <td>Display vertically <i>value </i>occurences of <i>char</i></td>
    </tr>
    <tr>
      <td><a href="#VTEX">VTEX</a></td>
      <td><i>string</i></td>
      <td>Both</td>
      <td>Display <i>string </i>vertically</td>
    </tr>
  </tbody>
</table>
<p><b>Mode<br>
</b>Std: Standard mode or multicolor mode<br>
Text: 40-columns text mode</p>
<p><b>*</b> Only valid with my GPL assembler, version II.</p>
<h3><br>
<a name="instr table"></a>Typical assembly-time instructions</h3>
<table border="1">
  <tbody>
    <tr>
      <th>Instruction</th>
      <th>Arguments</th>
      <th>Usage</th>
    </tr>
    <tr>
      <td><a href="#AORG">AORG</a></td>
      <td><i>address</i></td>
      <td>Defines the absolute <i>address </i>of the program in GRAM </td>
    </tr>
    <tr>
      <td><a href="#BYTE">BYTE</a></td>
      <td><i>byte[,byte...]</i></td>
      <td>Inserts one or more <i>bytes </i>of data in GRAM</td>
    </tr>
    <tr>
      <td><a href="#COPY">COPY</a></td>
      <td><i>quoted_string</i></td>
      <td>Switches to source file named in <i>quoted_string </i></td>
    </tr>
    <tr>
      <td><a href="#END">END</a></td>
      <td>.</td>
      <td>Signals the end of the program</td>
    </tr>
    <tr>
      <td><a href="#EQU">EQU</a></td>
      <td><i>value</i></td>
      <td>Defines an assembly-time constant as a label equal to <i>value</i></td>
    </tr>
    <tr>
      <td><a href="#STRI">STRI</a></td>
      <td><i>quoted_string</i></td>
      <td>Places an ASCII <i>string</i>, with length byte, in GRAM</td>
    </tr>
    <tr>
      <td><a href="#TEXT">TEXT</a></td>
      <td><i>quoted_string</i></td>
      <td>Ditto, without length byte.</td>
    </tr>
  </tbody>
</table>
<p>
</p>
<hr width="100%">
<p></p>
<h3>Simple opcodes</h3>
<h4><a name="RTN"></a>ReTurN</h4>
<p>Syntax:</p>
<p>[label] RTN [comment]</p>
<p>Use: </p>
<p>Exits a procedure called by CALL and returns to the caller. The
return
address is fetched from subroutine stack (pointed at by &gt;8373).</p>
<p>Status byte: cond bit reset.</p>
<p>Opcode: &gt;00</p>
<h4><br>
<a name="RTNC"></a>ReTurN with Cnd bit</h4>
<p>Syntax:</p>
<p>[label] RTNC [comment]</p>
<p>Use:</p>
<p>Exits a procedure called by CALL and returns to the caller, keeping
status byte value unchanged. The return address is fetched from
suroutine
stack (pointed at by &gt;8373).</p>
<p>Status byte: unchanged.</p>
<p>Opcode: &gt;01</p>
<h4><br>
<a name="RND"></a>RANDom</h4>
<p>Syntax:</p>
<p>[label] RND expression [comment]</p>
<p>[label] RAND expression [comment]</p>
<p>Use:</p>
<p>Generates a random number between 0 and the value of expression.
This
number is placed at @&gt;8378.</p>
<p>Status byte: unchanged.</p>
<p>Opcode: &gt;02</p>
<pre>Example:<br>DICE   RND  5          Generates a random number between 0 and 5<br>       INC  @&gt;8378     Makes it a number between 1 and 6 (to emulate a dice)</pre>
<h4><br>
<a name="SCAN"></a>SCAN keyboard</h4>
<p>Syntax:</p>
<p>[label] SCAN [comment]</p>
<p>Use:</p>
<p>Scans keyboard in mode found in &gt;8374. If a key is pressed, or
hold
down, its code is placed in &gt;8375 (otherwise it contains &gt;FF).
Joystick
values (&gt;04, &gt;00 and &gt;FC) are placed in &gt;8376 and &gt;8377
for the horizontal and vertical displacement respectively.</p>
<p>Status byte: cnd set if a NEW key has been detected.</p>
<p>Opcode: &gt;03</p>
<pre>Example:<br>       ST   &gt;03,@&gt;8374        Keyboard type 3<br>       CLR  @&gt;83C8            To enable repeats<br>L1     SCAN                   Scan keyboard<br>       BR   L1                No new key pressed<br>       ST   @&gt;8375,V*&gt;8304    Key pressed: pass it to VDP address in &gt;8304-05</pre>
<h4><br>
<a name="BACK"></a>BACKground color</h4>
<p>Syntax:</p>
<p>[label] BACK expression [comment]</p>
<p>Use:</p>
<p>Set screen color (and text background in text mode). The color value
(0 to 15) is defined in the expression.</p>
<p>Status byte: unchanged.</p>
<p>Opcode: &gt;04</p>
<pre>Example:<br>       BACK 7       cyan<br>       BACK 5       light blue</pre>
<h4><br>
<a name="B"></a>Branch</h4>
<p>Syntax:</p>
<p>[label] B G@expression [comment]</p>
<p>Use:</p>
<p>Branches to the address specified in expression. The correct syntax
uses G@ to indicate GROM memory, but since B always branches to this
memory,
the G and even the @ may be ommited with my GPL assembler.</p>
<p>Status byte: cnd bit reset.</p>
<p>Opcode: &gt;05</p>
<pre>Examples:<br>       B    G@&gt;A026<br>       B    @THERE<br>       B    L1</pre>
<h4><br>
<a name="CALL"></a>CALL</h4>
<p>Syntax:</p>
<p>[label] CALL G@expression [comment]</p>
<p>Use:</p>
<p>Branches to the address specified in expression, saving current
address
on the subroutine stack (pointed at by &gt;8373) for return with RTN,
RTNC
or RTNS.</p>
<p>Since addresses always represent GRAM memory, the G and the @ are
dispensable.</p>
<p>Status byte: cnd bit reset.</p>
<p>Opcode: &gt;06</p>
<pre>Example:<br>      CALL G@DISP       Calls routine "DISP"<br>      CALL &gt;0010        Calls routine located at &gt;0010 in GROM</pre>
<h4><br>
<a name="ALL"></a>ALL screen</h4>
<p>Syntax:</p>
<p>[label] ALL expression [comment]</p>
<p>Use:</p>
<p>Fills the whole screen with the character specified in expression,
by
copying it &gt;0300 times in VDP memory, starting at V@&gt;0000.</p>
<p>Status byte: unchanged.</p>
<p>Opcode: &gt;07</p>
<pre>Example:<br>CLSC  ALL 32        Clears screen by filling it with spaces</pre>
<h4><br>
<a name="FMT"></a>ForMaT sub-interpreter</h4>
<p>Syntax:</p>
<p>[label] FMT [comment]</p>
<p>Use:</p>
<p>Enters the format sub-interpreter: from that point on the regular
GPL
opcodes become invalid and are replaced with Fmt opcodes, until an FEND
is encoutered. Interrupts are disabled to avoid troubles with VDP
access.</p>
<p>The Format sub-interpreter is designed for easy screen handling, and
is <a href="#FMT%20sub-interpreter">described </a>at the end of this
section.
The commands are summarized in <a href="#fmt%20table">this table</a>.</p>
<p>Status byte: unchanged.</p>
<p>Opcode: &gt;08</p>
<pre>Example:<br>      FMT                       Enter sub-interpreter<br>      HTEX 'Hello, world'       Displays horizontal text<br>      FEND                      Exits sub-interpreter</pre>
<h4><br>
<a name="HIGH"></a>HIGHer than</h4>
<p>Syntax:</p>
<p>[label] HIGH [comment]</p>
<p>[label] H [comment]</p>
<p>Use:</p>
<p>Copies the content of the 'high' bit (logically higher) into cnd bit.</p>
<p>Status byte: high --&gt; cnd.</p>
<p>Opcode: &gt;09</p>
<pre>Example:<br>       DEC  @&gt;8300         Decrement this byte<br>       HIGH                Thansfer the "High" bit in the "Cnd" bit<br>       BS   G@NOZERO       Branch if "Cnd" is set, i.e. it &gt;8300 is higher than 0.</pre>
<h4><br>
<a name="GT"></a>Greater Than</h4>
<p>Syntax:</p>
<p>[label] GT [comment]</p>
<p>Use:</p>
<p>Copies the content of the 'gt' bit (arithmetically greater than)
into
the cnd bit.</p>
<p>Status byte: gt -&gt; cnd.</p>
<p>Opcode: &gt;0A</p>
<pre>Example:<br>       DADD  @COUNT,@TOTAL      Adds these two word variables<br>       GT                       Transfer the "GT" bit into the "Cnd" bit<br>       BR    SK21               Branches is "Cnd" is 0, i.e. if Total is not greater than 0.</pre>
<h4><br>
<a name="EXIT"></a>EXIT gpl</h4>
<p>Syntax:</p>
<p>[label] EXIT [comment]</p>
<p>Use:</p>
<p>Exits GPL program and resets the computer. This is similar to
pressing
the 'quit' key.</p>
<p>Status byte: cnd bit reset.</p>
<p>Opcode: &gt;0B</p>
<pre>Example:<br>BYEBYE  EXIT       End of my program</pre>
<h4><br>
<a name="CAR"></a>CARry bit</h4>
<p>Syntax:</p>
<p>[label] CAR [comment]</p>
<p>[label] CARR [comment]</p>
<p>Use:</p>
<p>Copies the content of the carry bit into the cnd bit.</p>
<p>Status byte: car -&gt; cnd.</p>
<p>Opcode: &gt;0C</p>
<pre>Example:<br>       INC  *&gt;8300       Increments the byte whose address is found in byte &gt;8300<br>       CAR               Tansfer the "Carry" bit into the "Cnd" bit<br>       BS  G@TOOBIG      Branch if "Cnd" = 1, i.e if there was a carry</pre>
<h4><br>
<a name="OVF"></a>OVerFlow</h4>
<p>Syntax:</p>
<p>[label] OVF [comment]</p>
<p>Use:</p>
<p>Copies the content of the overflow bit into the cnd bit.</p>
<p>Status byte: ovf -&gt; cnd.</p>
<p>Opcode: &gt;0D</p>
<pre>Example:<br>      DDIV  12,@&gt;834A        Divides &gt;834A-4B by 12<br>      OVF                    Transfer the "Ovf" bit into the "Cnd" bit<br>      BS    G@ERR12          Branch if "Cnd" is set, i.e. if there was an overflow</pre>
<h4><br>
<a name="PARS"></a>PARSe </h4>
<p>Syntax:</p>
<p>[label] PARS expression [comment]</p>
<p>Use:</p>
<p>Processes the current basic statement until a 'token' value smaller
than expression, or a comma, is encoutered.</p>
<p>Opcode: &gt;0E</p>
<pre>Example:<br>       PARS   &gt;B6         Parse expression. Stops of a ")" is encountered (token &gt;B6)</pre>
<h4><br>
<a name="XML"></a>eXecute Machine Language</h4>
<p>Syntax:</p>
<p>[label] XML expression [comment]</p>
<p>Use:</p>
<p>Calls a machine language routine. <i>Expression </i>should be a
byte
value: the first nibble is the table number, the second nibble is the
number
of the procedure in this table. See table locations and content in <a
 href="gpl2.htm#XML">here</a>.</p>
<p>Status byte: unchanged, unless modified by the assembly routine.</p>
<p>Opcode: &gt;0F</p>
<pre>Example:<br>       XML   &gt;10             convert string to number<br>       DST   &gt;A012,@&gt;A000    store address &gt;A012 in word &gt;A000<br>       XML   &gt;B0             branch to routine, at address found in &gt;A000 (i.e to &gt;A012)</pre>
<h4><br>
<a name="CONT"></a>CONTinue</h4>
<p>Syntax:</p>
<p>[label] CONT [comment]</p>
<p>Use:</p>
<p>Exits a Basic subroutine and continues execution of the main basic
program.</p>
<p>Status byte: unchanged.</p>
<p>Opcode: &gt;10</p>
<pre>Example:<br>       CONT</pre>
<h4><br>
<a name="EXEC"></a>EXECute</h4>
<p>Syntax:</p>
<p>[label] EXEC [comment]</p>
<p>Use:</p>
<p>Begins execution of a Basic program.</p>
<p>Status byte: unchanged.</p>
<p>Opcode: &gt;11</p>
<pre>Example:<br>MYPG  EXEC</pre>
<h4><br>
<a name="RTNB"></a>ReTurN to Basic</h4>
<p>Syntax:</p>
<p>[label] RTNB [comment]</p>
<p>[label] RTB [comment]</p>
<p>Use:</p>
<p>Exits a GPL subroutine and returns to Basic program, fetching return
address (in ROM or GROM) from the subroutine stack. For ROM routines,
add
2 to the address, for GROM routines (address bit 0 set) add 1 to the
address.</p>
<p>Status byte: unchanged.</p>
<p>Opcode: &gt;12</p>
<pre>Example:<br>       RTNB       We are done</pre>
<h4><br>
<a name="RTGR"></a>ReTurn to GRom</h4>
<p>Syntax:</p>
<p>[label] RTGR [comment]</p>
<p>Use:</p>
<p>This is used to return from a SWGR call, retrieving base and address
from the stack. </p>
<p>CAUTION: due to the original GROM design, a read/write instruction
must
precede address setup. Assuming that there will never be such things as
GRAMs, Texas Instruments programmers used a <i>write </i>instructions
inside
RTGR (and a read inside SWGR, but that's no problem). Thus, each time
you
use RTGR, you will erase one byte, at the address corresponding to the
base value (i.e. at G@&gt;9800 for base &gt;9800, etc). I know it's a
drag,
but there's no way around it! Just make sure that the given byte does
not
contain anything important (but a RTN opcode, that turns out to be
&gt;00).
</p>
<h4><br>
<a name="XG4-E"></a>eXtended Gpl: XG-4 to XG-E</h4>
<p>Syntax:</p>
<p>[label] XG-x [unknown operand type] [comment] </p>
<p>Use:</p>
<p>These opcodes were reserved for future extension: calling them
results
in turning on a putative peripheral card installed at CRU &gt;1B00 and
branching to address &gt;4020 in its ROM memory. Such a card does not
exist
(to my knowledge) and branching to this address will screw up the
system,
since the interpreter does not check for the presence of the card!</p>
<p>However, now that we have cards, such as Horizon Ramdisk, that do
have
available RAM at &gt;4000, may be somebody will volunteer to design
XGPL
(I won't).</p>
<p>Status byte: ?</p>
<p>Opcode: &gt;14 to &gt;1E</p>
<pre>Example: You better not use these!</pre>
<h4><br>
<a name="XG-$"></a>eXtended Gpl Special entry point</h4>
<p>Syntax:</p>
<p>[label] XG-$ [comment]</p>
<p>Use:</p>
<p>This works as the above, but branches to address &gt;401C in the
card
ROM.</p>
<p>Status byte: ?</p>
<p>Opcode: &gt;1F</p>
<pre>Example: Avoid that one, too!</pre>
<h4><br>
<a name="MOVE"></a>MOVE</h4>
<p>Syntax:</p>
<p>[label] MOVE source,move_source,move_dest [comment]</p>
<p>Use:</p>
<p>Copies the number of bytes specified in the first operand(source),
from
move_source to move_destination. Move_source and move_dest can be the
regular
destination argument types (@, *, V@ ,V* with or without index) or any
of the following special types: </p>
<p>- <b>G@&gt;A123</b> GROM/GRAM address specified in the expression
(here
&gt;A123)</p>
<p>- <b>G@&gt;0012(@&gt;834C)</b> Address specified (&gt;0012), plus
the
value found in the index word (&gt;834C-4D).</p>
<p>- <b>G*&gt;834A</b> is a shortcut for G@&gt;0000(@&gt;834A) with my
assembler.</p>
<p>- <b>#2</b> Destination is the VDP register specified (legal
values:
0 to 7). Can't be used as a source operand.</p>
<p>- <b>R@2 </b>is an alternative syntax for the above VDP register
addressing..</p>
<p>Status byte: unchanged.</p>
<p>Opcode: &gt;20 to &gt;3F according to arguments types.</p>
<pre>Example:<br>       ST    &gt;80,V@&gt;0000                    char 32 in Basic (biased by &gt;60)<br>       MOVE  &gt;0300,V@&gt;0000,V@&gt;0001          clear screen<br>       MOVE  @&gt;8300,G@PROMPT(@&gt;02),V@&gt;8304  display text found at PROMPT plus the value of &gt;8302<br>                                            at VDP address found in &gt;834A</pre>
<p>Notes: </p>
<li>With surprising insight, the TI designers allowed G@ as a
destination
operand. Did they foresee the apparition of GRAM devices?</li>
<li>The VDP registers being write-only registers, R@ cannot be used as
a source operand. Therefore GPL assemblers won't let you do it (unless
you force it with a BYTE instruction, which produces interesting
results...)..<br>
</li>
<h4><br>
<br>
<a name="BR"></a>Branch if Reset</h4>
<p>Syntax:</p>
<p>[label] BR G@expression [comment]</p>
<p>Use:</p>
<p>Branches to the address specified in expression, if cnd bit is
reset.
The G@ is more correct, but may be dispensed with when using my
assembler.</p>
<p>Since many opcodes reset the cnd bit, BR is often identical to B,
excepts
that it only requires 2 bytes of memory (versus 3 for B). The drawback
is that the address should not trespass GROM boundaries (0 to &gt;1FFF,
&gt;2000 to &gt;3FFF, etc).</p>
<p>Status byte: cnd bit reset</p>
<p>Opcode: &gt;40 to &gt;5F according to address most significant byte.</p>
<pre>Example:<br>      CZ   @&gt;8300           Compare byte &gt;8300 to zero<br>      BR   G@ZERO           Branch if it's zero, else reset the "Cnd" bit<br>      BR   G@NOZERO         Branch anyhow since "Cnd" has been reset</pre>
<h4><br>
<a name="BS"></a>Branch if Set</h4>
<p>Syntax:</p>
<p>[label] BS G@expression [comment]</p>
<p>Use:</p>
<p>Branches to the address specified in expression, if cnd bit is set.
The G@ is more correct, but may be dispensed with.The address should
not
trespass GROM boundaries (0 to &gt;1FFF, &gt;2000 to &gt;3FFF, etc).</p>
<p>Status byte: cnd bit reset.</p>
<p>Opcode: &gt;60 to &gt;7F according to address most significant byte.</p>
<pre>Example:<br>      CEQ  @&gt;834A,@&gt;8304      Compare byte &gt;834A and &gt;8304<br>      BS   L12                Branch if they are equal</pre>
<p>
</p>
<hr width="100%">
<p></p>
<h3>Dobble opcodes</h3>
<p>The following opcodes deal with bytes, however by adding a leading D
one can create equivalent opcodes that deal with two consecutive bytes
(irrespective of wich of the two has an even address). For instance, <tt>NEG
@&gt;8301</tt> negates &gt;8301, whereas <tt>DNEG @&gt;8301</tt>
negates
&gt;8301 and &gt;8302.</p>
<p>These opcodes can be divided in two groups: those that have an
unique
destination operand, and those that have two operands: source and
destination.
In this case, the source operand can be an immediate value (i.e. a
constant
embedded in the program).</p>
<h4><a name="ABS"></a>ABSolute value</h4>
<p>Syntax:</p>
<p>[label] ABS destination [comment]</p>
<p>Use:</p>
<p>Replaces the content of destination with its absolute value (i.e.
negative
numbers become positive).</p>
<p>Status byte: unchanged.</p>
<p>Opcode: &gt;80 and &gt;81</p>
<pre>Example:<br>       ABS   @&gt;8300         Absolute value of byte &gt;8300<br>       DABS  V*&gt;8304        Absolute values of 2 VDP bytes which addess is in &gt;8304-05</pre>
<h4><br>
<a name="NEG"></a>NEGate</h4>
<p>Syntax:</p>
<p>[label] NEG destination [comment]</p>
<p>Use:</p>
<p>Negates the content of destination (i.e. sign changes).</p>
<p>Status byte: unchanged.</p>
<p>Opcode: &gt;82 and &gt;83</p>
<pre>Example:<br>       ST    1,V@&gt;1000<br>       NEG   V@&gt;1000              result is &gt;FF (-1)<br>       DCLR  V@&gt;1000(@&gt;02)<br>       DNEG  V@&gt;1000(@&gt;02)        result is 0</pre>
<h4><br>
<a name="INV"></a>INVert</h4>
<p>Syntax:</p>
<p>[label] INV destination [comment]</p>
<p>Use:</p>
<p>Inverts each bit in destination (1-&gt;0 and 0-&gt;1).</p>
<p>Status byte: unchanged.</p>
<p>Opcode: &gt;84 and &gt;85</p>
<pre>Example:<br>       ST   1,V@&gt;1000<br>       NEG  V@&gt;1000          result is &gt;FE (-2)<br>       DCLR V@&gt;1000(@&gt;02)<br>       DNEG V@&gt;1000(@&gt;02)    result is &gt;FFFF (-1)</pre>
<h4><br>
<a name="CLR"></a>CLeaR</h4>
<p>Syntax:</p>
<p>[label] CLR destination [comment]</p>
<p>Use:</p>
<p>Clears the content of destination (i.e. puts 0 in it).</p>
<p>Status byte: unchanged.</p>
<p>Opcode: &gt;88</p>
<pre>Example:<br>       CLR  *2(@&gt;8303)<br>       DCLR @COUNT        clears COUNT and COUNT+1</pre>
<h4><br>
<a name="FETC"></a>FETCh</h4>
<p>Syntax:</p>
<p>[label] FETC destination [comment]</p>
<p>Use:</p>
<p>Fetches the data byte immediately following the previous CALL
statement
and puts in into destination. The return address is incremented by one.
This is used to pass parameters to subroutines.</p>
<p>NB: Although it is accepted by some assemblers DFETC is not properly
interpreted (the left byte is always 0, the right byte is the only one
fetched): to fetch 2 bytes, use 2 FETC statements. You could use DFETC
to substitute for FETC and DSRL 8, but that's risky: there may be
versions
of the GPL-interpreter that have this bug fixed.</p>
<p>Status byte: unchanged.</p>
<p>Opcode: &gt;88</p>
<pre>Example:<br>       CALL  G@SUBR         this is the caller<br>       BYTE  &gt;02,'T'        it has 2 bytes of data after the call</pre>
<pre>**                          this is the called subroutine<br>SUBR   FETC  @&gt;8300         fetch first byte: &gt;8300 will contain &gt;02<br>       FETC  @&gt;8301         ftech second byte: &gt;8301 will contain 'T'</pre>
<h4><br>
<a name="CASE"></a>CASE jump</h4>
<p>Syntax:</p>
<p>[label] CASE destination [comment]</p>
<p>Use:</p>
<p>Skips several 2-bytes long instructions, according to the value of
destination.
These instructions are generally BR statements.</p>
<p>Status byte: unchanged.</p>
<p>Opcode: &gt;8A and &gt;8B</p>
<pre>Example:<br>       ST    2,@&gt;8300<br>       CASE  @&gt;8300<br>       BR    G@ONE             this statement is skipped<br>       BR    G@TWO             this branch is taken<br>       BR    G@THREE</pre>
<h4><br>
<a name="PUSH"></a>PUSH on stack</h4>
<p>Syntax:</p>
<p>[label] PUSH destination [comment]</p>
<p>Use:</p>
<p>Increments data stack pointer (&gt;8372) and puts the content of
destination
on the stack. This byte can be read back by using *&gt;8372 as source
operand
(generally, you will also <tt>DEC @&gt;8372</tt> afterward.</p>
<p>NB: Although accepted by most assemblers DPUSH is not interpreted
correctly:
only the least significant byte of destination is pushed. To push a
word
on stack, use two PUSH statements.</p>
<p>Status byte: unchanged.</p>
<p>Opcode: &gt;8C</p>
<pre>Example:<br>       PUSH  @VALUE<br>       PUSH  @VALUE+1</pre>
<h4><br>
<a name="CZ"></a>Compare to Zero</h4>
<p>Syntax:</p>
<p>[label] CZ destination [comment]</p>
<p>Use:</p>
<p>Compares the content of destination to 0 and return result of the
comparison
into the status byte. The cnd bit can be immediately used by BR and BS,
other bits are first to be transfered into cnd with the GT and HIGH
instructions.</p>
<p>Status byte: modified.</p>
<p>Opcode: &gt;8E and &gt;8F</p>
<pre>Example:<br>       CZ    @&gt;8300<br>       DCZ   V*&gt;8300(@&gt;03)</pre>
<h4><br>
<a name="INC"></a>INCrement by one</h4>
<p>Syntax:</p>
<p>[label] INC destination [comment]</p>
<p>Use:</p>
<p>Adds 1 to the content of destination. The result is automatically
compared
to 0</p>
<p>Status byte: modified.</p>
<p>Opcode: &gt;90 and &gt;91</p>
<pre>Example:<br>       INC   @&gt;8301            Increment &gt;8301. If it becomes 0...<br>       BS    G@ZERO            this branch is taken</pre>
<h4><br>
<a name="DEC"></a>DECrement by one</h4>
<p>Syntax:</p>
<p>[label] DEC destination [comment]</p>
<p>Use:</p>
<p>Substracts 1 from the content of destination. The result is
automatically
compared to zero.</p>
<p>Status byte: modified.</p>
<p>Opcode: &gt;92 and &gt;93</p>
<pre>Example:<br>       DEC   @&gt;A000<br>       DDEC  @DELAY(@TIMER)</pre>
<h4><br>
<a name="INCT"></a>INCrement by Two</h4>
<p>Syntax:</p>
<p>[label] INCT destination [comment]</p>
<p>Use:</p>
<p>Adds 2 to the content of destination. The result is automatically
compared
to 0</p>
<p>Status byte: modified.</p>
<p>Opcode: &gt;94 and &gt;95</p>
<pre>Example:<br>       INCT  @&gt;834A          Increment byte &gt;834A by two<br>       DINCT @&gt;2004          Increment word &gt;8304-05 by two</pre>
<h4><br>
<a name="DECT"></a>DECrement by Two</h4>
<p>Syntax:</p>
<p>[label] DECT destination [comment]</p>
<p>Use:</p>
<p>Substracts 2 from the content of destination. The result is
automatically
compared to zero.</p>
<p>Status byte: modified.</p>
<p>Opcode: &gt;96 and &gt;97</p>
<pre>Example:<br>L1     DEC   @COUTER<br>       BR    L1                 repeat until COUTER equals 0</pre>
<h4><br>
<a name="XG0-3"></a>eXtended Gpl XG-0 to XG-3</h4>
<p>Syntax:</p>
<p><br>
[label] XG-n destination [comment]</p>
<p>Use:</p>
<p>These opcodes were intended for use with a GPL expansion card that
was
never released. Using them will result in locking the system, since the
interpreter doesn't check for the presence of the card before branching
to it.</p>
<p>Opcode: &gt;98 and &gt;99 to &gt;9E and &gt;9F</p>
<pre>Example:<br>       Don't use these! Most assemblers don't accept them anyhow (mine does). </pre>
<p>
</p>
<hr width="100%">Opcodes with 2 operands.
<p></p>
<h4><a name="ADD"></a>ADDition</h4>
<p>Syntax:</p>
<p>[label] ADD source,destination [comment]</p>
<p>[label] A source,destination [comment]</p>
<p>Use:</p>
<p>Adds the content of source to the content of destination and
compares
the result to zero.</p>
<p>Status byte: modified.</p>
<p>Opcode: &gt;A0 to &gt;A3</p>
<pre>Example:<br>       ADD   12,@&gt;8300<br>       DADD  @&gt;8300,V*&gt;834A</pre>
<h4><br>
<a name="SUB"></a>SUBstract</h4>
<p>Syntax:</p>
<p>[label] SUB source,destination [comment]</p>
<p>[label] S source,destination [comment]</p>
<p>Use:</p>
<p>Substracts the content of source to the content of destination and
compares
the result to zero.</p>
<p>Status byte: modified.</p>
<p>Opcode: &gt;A4 to &gt;A7</p>
<pre>Example:<br>       SUB   10,@TIMER<br>       BS    G@DONE                branch is taken if TIMER is now 0<br>       DSUB  @&gt;8300,@&gt;8302</pre>
<h4><br>
<a name="MPY"></a>MULtiply</h4>
<p>Syntax:</p>
<p>[label] MPY source,destination [comment]</p>
<p>[label] MUL source,destination [comment]</p>
<p>[label] M source,destination [comment]</p>
<p>Use:</p>
<p>Multiplies the content of source and destination and puts the result
in destination and the following byte (or byte<u>s</u> for DMPY).</p>
<p>Status byte: unchanged.</p>
<p>Opcode: &gt;A8 to &gt;AB</p>
<pre>Example:<br>       MPY   10,@NUMBER<br>       DST   @NUMBER,@RESULT<br>       DMPY  10,@NUMBER<br>       DST   @NUMBER+2,@RESULT</pre>
<h4><br>
<a name="DIV"></a>DIVide</h4>
<p>Syntax:</p>
<p>[label] DIV source,destination [comment]</p>
<p>Use:</p>
<p>Divides the content of destination and the following byte (or byte<u>s</u>
for DDIV) by the content of source. If no overflow occured, the result
is placed into destination and the remainder into the next byte(s).</p>
<p>Status byte: unchanged (ovf set if overflow occured).</p>
<p>Opcode: &gt;AC and &gt;AD</p>
<pre>Example:<br>       DIV   24,@LINES<br>       ST    @LINES+1,@&gt;8300<br>       DDIV  &gt;0016,@LINES<br>       DST   @LINES,@PAGES</pre>
<h4><br>
<a name="AND"></a>AND operation</h4>
<p>Syntax:</p>
<p>[label] AND source,destination [comment]</p>
<p>Use:</p>
<p>Performes a bitwise and (0a0=0, 0a1=0, 1a0=0, 1a1=1) with the
contents
of source and destination. The result is placed into destination and
compared
to zero.</p>
<p>Status byte: modified.</p>
<p>Opcode: &gt;B0 to &gt;B3</p>
<pre>Example:<br>       ST    &gt;37,@&gt;8300<br>       AND   &gt;F1,@&gt;8300                 result is &gt;31</pre>
<h4><br>
<a name="OR"></a>OR operation</h4>
<p>Syntax:</p>
<p>[label] OR source,destination [comment]</p>
<p>Use:</p>
<p>Performes a bitwise or (0o0=0, 0o1=1, 1o0=1, 1o1=1) with the
contents
of source and destination. The result is places into destination and
compared
to zero.</p>
<p>Status byte: modified.</p>
<p>Opcode: &gt;B4 to &gt;B7</p>
<pre>Example:<br>       DST   &gt;0037,@&gt;8300<br>       DOR   &gt;4512,@&gt;8300            the result is &gt;4537</pre>
<h4><br>
<a name="XOR"></a>eXclusive OR operation</h4>
<p>Syntax:</p>
<p>[label] XOR source,destination [comment]</p>
<p>Use:</p>
<p>Performs a bitwise xor operation (0x0=0, 0x1=1, 1x0=1, 1x1=0) with
the
contents of source and destination. The result is placed into
destination
and compared to zero.</p>
<p>Status byte: modified.</p>
<p>Opcode: &gt;B8 to &gt;BB</p>
<pre>Example:<br>       DST   &gt;0037,@&gt;8300<br>       DXOR  &gt;4512,@&gt;8300             the result is &gt;4525</pre>
<h4><br>
<a name="ST"></a>STore</h4>
<p>Syntax:</p>
<p>[label] ST source,destination [comment]</p>
<p>Use:</p>
<p>Copies the content of source into destination.</p>
<p>Status byte: unchanged.</p>
<p>Opcode: &gt;BC to &gt;BF</p>
<pre>Example:<br>       ST    @&gt;8300,@&gt;2240<br>       DST   'GO',V@&gt;0202</pre>
<h4><br>
<a name="EX"></a>EXchange</h4>
<p>Syntax:</p>
<p>[label] EX source,destination [comment]</p>
<p>Use:</p>
<p>Exchanges the contents of source and destination.</p>
<p>NB: source should not be immediate, since nothing will be written in
it!</p>
<p>Status byte: unchanged.</p>
<p>Opcode: &gt;C0 to &gt;C3</p>
<pre>Example:<br>       DST   &gt;0102,@&gt;8300           This puts &gt;01 in &gt;8300 and &gt;02 in &gt;8301<br>       EX    @&gt;8300,@&gt;8301          Now &gt;8300 = &gt;02 and &gt;8301 = &gt;01</pre>
<h4><br>
<a name="CH"></a>Compare High</h4>
<p>Syntax:</p>
<p>[label] CH source,destination [comment]</p>
<p>Use:</p>
<p>Sets cnd bit if source is logically greater than destination.</p>
<p>Status byte: cnd modified</p>
<p>Opcode: &gt;C4 to &gt;C7</p>
<pre>Example:<br>       ST    &gt;45,@&gt;8300<br>       CH    &gt;FF,@&gt;8300               cnd=1<br>       CH    &gt;03,@&gt;8300               cnd=0</pre>
<h4><br>
<a name="CHE"></a>Compare High or Equal</h4>
<p>Syntax:</p>
<p>[label] CHE source,destination [comment]</p>
<p>Use:</p>
<p>Sets cnd bit if source is logically higher or equal to destination.</p>
<p>Status byte: cnd modified</p>
<p>Opcode: &gt;C8 to &gt;CB</p>
<pre>Example:<br>       ST    &gt;45,@&gt;8300<br>       CHE   &gt;FF,@&gt;8300            cnd=1<br>       CHE   &gt;03,@&gt;8300            cnd=0</pre>
<h4><br>
<a name="CGT"></a>Compare Greater Than</h4>
<p>Syntax:</p>
<p>[label] CGT source,destination [comment]</p>
<p>Use:</p>
<p>Sets cnd bit if source is arithmetically greater than destination.</p>
<p>Status byte: cnd modified.</p>
<p>Opcode: &gt;CC to &gt;CF</p>
<pre>Example:<br>       ST    &gt;45,@&gt;8300<br>       CGT   &gt;FF,@&gt;8300          cnd=0 (&gt;FF is -1)<br>       CGT   &gt;65,@&gt;8300          cnd=1</pre>
<h4><br>
<a name="CGTE"></a>Compare Greater Than or Equal</h4>
<p>Syntax:</p>
<p>[label] CGTE source,destination [comment]</p>
<p>[label] CGE source,destination [comment]</p>
<p>Use:</p>
<p>Sets cnd bit if source is arithmetically greater or equal to
destination.</p>
<p>Status byte: cnd modified</p>
<p>Opcode: &gt;D0 to &gt;D3</p>
<pre>Example:<br>       CGTE  '3',@KEY<br>       BS    SK2</pre>
<h4><br>
<a name="CEQ"></a>Compare EQual</h4>
<p>Syntax:</p>
<p>[label] CEQ source,destination [comment]</p>
<p>Use:</p>
<p>Sets cnd bit if source equals destination.</p>
<p>Status byte: cnd modified</p>
<p>Opcode: &gt;D4 to &gt;D7</p>
<pre>Example:<br>       DCEQ  &gt;AA55,@&gt;2000</pre>
<h4><br>
<a name="CLOG"></a>Compare LOGical</h4>
<p>Syntax:</p>
<p>[label] CLOG source,destination [comment]</p>
<p>Use:</p>
<p>Performs a bitwise "and" with the contents of source and destination
(leaving destination unchanged) and sets cnd bit if the result is zero.</p>
<p>Another way to put it is to say that cnd is set if all bits that are
"1" in source are "0" in destination. </p>
<p>Status byte: cnd modified</p>
<p>Opcode: &gt;D8 to DB</p>
<pre>Example:<br>       ST    &gt;82,@&gt;8300<br>       CLOG  &gt;80,@&gt;8300        cnd =0<br>       BR    J1                branches if first bit is set in &gt;8300 (it is)<br>       CLOG  &gt;41,@&gt;8300        cnd =1</pre>
<h4><br>
<a name="SRA"></a>Shift Right Arithmetic</h4>
<p>Syntax:</p>
<p>[label] SRA source,destination [comment]</p>
<p>Use:</p>
<p>Shifts the content of destination to the right by the number of bits
specified in source, padding the left bits with copies of the sign bit
(first bit).</p>
<p>Status byte: unchanged.</p>
<p>Opcode: &gt;DC to &gt;DF</p>
<pre>Example:<br>       ST    &gt;80,@&gt;8300       i.e. 1000 0000 binary<br>       SRA    2,@&gt;8300        The result is &gt;E0, i.e. 1110 0000</pre>
<h4><br>
<a name="SLA"></a>Shift Left Logical or Shift Left Arithmetic</h4>
<p>Syntax:</p>
<p>[label] SLL source,destination [comment]</p>
<p>[label] SLA source,destination [comment]</p>
<p>Shifts the content of destination to the left by the number of bits
specified in source, padding the right bits with 0.</p>
<p>NB: SLA is identical to SLL some assembler may accept only one of
these.</p>
<p>Status byte: unchanged.</p>
<p>Opcode: &gt;E0 to &gt;E3</p>
<pre>Example:<br>       ST    &gt;10,@&gt;8300      i.e. 0001 0000 binary<br>       SLA   2,@&gt;8300        The result is &gt;40, i.e. 0100 0000<br>       SLL   @&gt;8304,@&gt;8300</pre>
<h4><br>
<a name="SRL"></a>Shift Right Logical</h4>
<p>Syntax:</p>
<p>[label] SRL source,destination [comment]</p>
<p>Shifts the content of destination to the right by the number of bits
specified in source, padding the left bits with 0.</p>
<p>Status byte: unchanged.</p>
<p>Opcode: &gt;E4 to &gt;E7</p>
<pre>Example:<br>       ST    &gt;80,@&gt;8300      i.e. 1000 0000 binary<br>       SRL   2,@&gt;8300        The result is &gt;20, i.e. 0010 0000</pre>
<h4><br>
<a name="SRC"></a>Shift Right Circular</h4>
<p>Syntax:</p>
<p>[label] SRC source,destination [comment]</p>
<p>Shifts the content of destination to the right by the number of bits
specified in source, padding the left bits with the bits deleted to the
right.</p>
<p>NB: there is no shift left circular, but the equivalent of SLC x is
SRC 16-x.</p>
<p>Status byte: unchanged.</p>
<p>Opcode: &gt;E8 to &gt;EF</p>
<pre>Example:<br>       ST    &gt;81,@&gt;8300      i.e. 1000 0001 binary<br>       SRC   2,@&gt;8300        The result is &gt;60, i.e. 0110 0000<br>       SRC   14,@&gt;8300       Now it became &gt;81 again (equals SLC 2,@&gt;8300)</pre>
<h4><br>
<a name="COIN"></a>COINcidence</h4>
<p>Syntax:</p>
<p>[label] COIN source,destination [comment]</p>
<p>BYTE map</p>
<p>DATA table</p>
<p>Use:</p>
<p>Checks for screen objects coincidence. Source and destination
contain
the coordinates of two objects (row/column). The COIN statement must be
followed by three bytes of data: the first contain the mapping value
(0:
perfect match, 1: 2 by 2 pixels, 2: 4 by 4 pixels), the next two bytes
contain the address of the coincidence table. This is a table that you
provide, with all possible positions of the two touching/overlapping
objects,
and for each position a bit indicating if you consider it coincident or
not.</p>
<p>For more details and examples on how to use this complicated but
usefull
instruction, click <a href="gpl2.htm#COIN">here</a>.</p>
<p>Since arguments must contain 2 bytes each, only DCOIN is adequate.
However
my assembler is smart enough to accept COIN, and considers it as DCOIN.</p>
<p>Status byte: cnd modified</p>
<p>Opcode: &gt;EC to &gt;EF</p>
<h4><br>
<a name="XG-F"></a>eXtended Gpl XG-F and XG-G</h4>
<p>Syntax:</p>
<p>[label] XG-n source,destination [comment]</p>
<p>Use:</p>
<p>These opcodes were intented for use with a never released GPL
expansion
board. They should not be used since the interpreter does not check for
the presence of the card before branching to it, resulting in lock-ups.</p>
<p>Opcode: &gt;F0 to &gt;F4 and &gt;FC to &gt;FF</p>
<pre>Example: Don't use these, chaps!</pre>
<h4><br>
<a name="I/O"></a>Input/Ouput</h4>
<p>Syntax:</p>
<p>[label] I/O source,destination [comment]</p>
<p>Use:</p>
<p>Source contains a number from 0 to 6 indicating the type of i/o
operation:</p>
<ul>
  <li>0: play sound list, from GROM.</li>
  <li>1: play sound list, from VDP. For these two, the destination
operand
contains two bytes:</li>
  <ul>
    <li>1+2 contain the address of the sound list. Note that the
address is
passed as a word (assembly MOV), so the destination operand must be
even
(for once word boundaries do matter).</li>
  </ul>
  <li>2: CRU input </li>
  <li>3: CRU output For these two, the destination operand contains a
list
of 4 bytes: </li>
  <ul>
    <li>1+2 contain the CRU address divided by 2 (e.g. &gt;0820 for
&gt;1400)</li>
    <li>3 the number of bits to transfer</li>
    <li>4 the scratch-pad address of the data byte(s).</li>
  </ul>
  <li>4: cassette write </li>
  <li>5: cassette read </li>
  <li>6: cassette verify For these three, the destination contains a
list
of 4 bytes: </li>
  <ul>
    <li>1+2 contain the number of data bytes</li>
    <li>3+4 the address of these bytes in VDP memory. Cnd bit will be
set if
an error occurs.<br>
N.B. the cassette motor must be turned on/off from GPL by writing 1 or
0 to CRU bits 22 (CS1) or 23 (CS2).</li>
  </ul>
</ul>
<p>DI/O is identical to I/O (except that the operation number should be
&gt;0000 to &gt;0006) since destination, being larger than 2 bytes, is
fetched by pointer rather than by using the standard interpreter data
fetching
routine.</p>
<p>Follow these links for more detailed information on <a
 href="gpl2.htm#sound">sound</a>,
<a href="gpl2.htm#cru">CRU handling</a> and <a href="gpl2.htm#cassette">cassette
tape routines</a>.</p>
<p>Status byte: cnd set upon cassette read or verify error.</p>
<p>Opcode: &gt;F4 to F7</p>
<pre>Example:</pre>
<pre>       DST   22,@&gt;834A        CRU bit 22: address &gt;002C divided by 2.<br>       ST    1,@&gt;834C         1 bit to be transfered<br>       ST    &gt;04,@&gt;834D       from/to &gt;8304<br>       ST    &gt;FF,@&gt;8304       data: all bits "1"<br>       I/O   3,@&gt;834D         write 1 bit (CS1 motor on)</pre>
<pre>       DST   &gt;0100,@&gt;8300     256 bytes<br>       DST   &gt;1000,@&gt;8302     located at &gt;1000 in VDP mem<br>       I/O   4,@&gt;8300         to be written to cassette</pre>
<pre>       CLR   @&gt;8304           change data: all bits "0"<br>       I/O   3,@&gt;834D         write 1 bit (CS1 motor off)</pre>
<h4><br>
<a name="SWGR"></a>SWitch GRoms</h4>
<p>Syntax:</p>
<p>[label] SWGR source,destination [comment]</p>
<p>Use:</p>
<p>Branches to the address found in destination, changing grom base to
the value found in source. The return address and current bases are
pushed
on the subroutine stack to allow returns via the RTGR opcode.</p>
<p>Be carefull: source should contain a valid port value: no checking
is
done and wrong values result in lock-ups!</p>
<p>Theoretically, SWGR (as opposed to DSWGR) cannot be used since the
most
significant byte of the port value would be &gt;00 (or &gt;FF).
However,
my assembler is smart enough to assume that if you say SWGR, you
actually
meant DSWGR and it 'appends' the missing D.</p>
<p>Status byte: cnd bit cleared.</p>
<p>Opcode: &gt;F8 to &gt;FB</p>
<pre>Example:<br>       DST   &gt;604A,@&gt;8300          Address where to branch<br>       DSWRG &gt;9804,@&gt;8300          Branch at &gt;604A using GROM port &gt;9804</pre>
<h2><br>
<hr width="100%"><a name="FMT sub-interpreter"></a>The FMT
sub-interpreter</h2>
<p>When then opcode FMT is encountered, all the regular GPL opcodes
become
invalid and are replaced by special opcodes, intended for easy screen
handling.
One of these is the FEND opcodes, that quits the ForMaT mode and
returns
to regular GPL. </p>
<p>Two screen pointers are used by the display instructions, a current
column pointer (&gt;837F) and a current row pointer (&gt;837E). These
two
pointers are updated after each display instruction, in order to point
at the next available screen position, but neither can be greater than
31. The content of the current screen position, can be retrieved at
&gt;837D
(current character).</p>
<p>Notes: </p>
<ul>
  <li>The FMT sub-interpreter assumes that the screen image table is
located
between 0 and &gt;0300 in VDP mem. Although it is able to write up to
&gt;03FF,
addresses comprised between &gt;0300 and &gt;031F are interpreted as
&gt;0000
to &gt;001F, which is a big problem in text mode, but unfortunately
unavoidable
(use a MOVE statement to write on text-line 19).</li>
  <li>The multicolor mode is supported.</li>
  <li>Interrupts are disabled, while in FMT mode.</li>
  <li>Status byte is never affected.</li>
  <li>Some assembly instructions are valid in both modes, some are GPL
specific
and some FMT specific.</li>
</ul>
<h4><br>
<a name="HTEX"></a>Horizontal TEXt</h4>
<p>Syntax:</p>
<p>[label] HTEX quoted_string [comment]</p>
<p>or</p>
<p>[label] HTEX defined_expr,source [comment]</p>
<p>[label] HSTR defined_expr,source [comment]</p>
<p>Use:</p>
<p>Displays the content of quoted_string (1 to 32 characters) to the
current
screen position. Or displays the number of characters specified in
defined_expression
(from 1 to 28) and read from source.</p>
<p>Opcode: &gt;00 to &gt;1F (quoted string) and &gt;E0 to &gt;FB
(source).</p>
<pre>Example:<br>       HTEX  'Hello, world'<br>       HTEX   32,@ NAME</pre>
<h4><br>
<a name="VTEX"></a>Vertical TEXt</h4>
<p>Syntax:</p>
<p>[label] VTEX quoted_string [comment]</p>
<p>Use:</p>
<p>Displays vertically the content of quoted_string (1 to 32
characters)
on screen, strarting from current screen position.</p>
<p>Opcode: &gt;20 to &gt;3F</p>
<pre>Example:<br>       VTEX   'Ordinate'</pre>
<h4><br>
<a name="HCHA"></a>Horizontal CHAracters</h4>
<p>Syntax:</p>
<p>[label] HCHA defined_expression,expression [comment]</p>
<p>Use:</p>
<p>Repeats horizontally the character specified in expression, the
number
of times specified in defined_expression (from 1 to 32).</p>
<p>Opcode: &gt;40 to &gt;5F</p>
<pre>Example:<br>       HCHA   12,'*'<br>       HCHA   32,&gt;40</pre>
<h4><br>
<a name="VCHA"></a>Vertical CHAracters</h4>
<p>Syntax:</p>
<p>[label] VCHA defined_expression,expression [comment]</p>
<p>Use:</p>
<p>Repeats vertically the cahracter specified in expression, the number
of times specified in defined_expression (from 1 to 32).</p>
<p>Opcode: &gt;60 to &gt;7F</p>
<pre>Example:<br>       VCHA   24,'!'</pre>
<h4><br>
<a name="COL+"></a>COLumn increment</h4>
<p>Syntax:</p>
<p>[label] COL+ expression [comment]</p>
<p>[label] ICOL expression [comment]</p>
<p>Use:</p>
<p>Increments the column pointer by the content of expression (1 to
32).
This may result in incrementing the row pointer by one, if end of line
is reached.</p>
<p>Opcode: &gt;80 to &gt;9F</p>
<pre>Example:<br>       COL+  4</pre>
<h4><br>
<a name="ROW+"></a>ROW increment</h4>
<p>Syntax:</p>
<p>[label] ROW+ expression [comment]</p>
<p>[label] IROW expression [comment]</p>
<p>Use:</p>
<p>Increments the row pointer by the content of expression (1 to 32).</p>
<p>Opcode: &gt;A0 to &gt;BF</p>
<pre>Example:<br>       ROW+  1</pre>
<h4><br>
<a name="RPTB"></a>RePeaT Block</h4>
<p>Syntax:</p>
<p>[label] RPTB defined_expr [comment]</p>
<p>[label] FOR defined_expr [comment]</p>
<p>Use:</p>
<p>Repeats the display instructions comprised between the RPTB/FOR and
the next LOOP/NEXT intructions, for the number of times specified in
defined_expr.
The number of repeats that remain to be executed is stored on the
subroutine
stack (pointed at by &gt;8373).</p>
<p>Opcode: &gt;C0 to &gt;DF</p>
<pre>Example:<br>       RPTB  8       to erase a 8x8 window<br>       HCHA  8,' '<br>       COL+  1<br>       NEXT          loop back above</pre>
<h4><br>
<a name="LOOP"></a>LOOP</h4>
<p>Syntax:</p>
<p>[label] LOOP [G@ expression] [;comment]</p>
<p>[label] NEXT [G@ expression] [;comment]</p>
<p>Use:</p>
<p>Ends a RPTB loop. Normally the operand field should contain the
address
were to branch, but most of the time this is the address immediately
following
the RPTB, thus my assembler keeps track of 16 nested RPTB and provides
the right address if none was specified. However, if you would like to
branch to a different address, or to nest more than 16 RPTB (not very
likely
to work anyway, since subroutine stack will overflow) you should
provide
the required G address.</p>
<p>Opcode: &gt;FB (after RPTB)</p>
<pre>Example:<br>       RPTB  5<br>       HTEX  'TITLE'       this is not repeated<br>L1     COL+  27            but all this is<br>       HCHA  '.....'<br>       LOOP  L1</pre>
<h4><br>
<a name="FEND"></a>Fmt END</h4>
<p>Syntax:</p>
<p>[label] FEND [comment]</p>
<p>Use:</p>
<p>Exits the FMT sub-interpreter, and returns to regular GPL opcodes.</p>
<p>Opcode: &gt;FB</p>
<pre>Example:<br>       FMT<br>       HTEX  'HELP!'<br>       FEND</pre>
<h4><br>
<a name="SCRO"></a>SCReen Offset</h4>
<p>Syntax:</p>
<p>[label] SCRO defined_expr [comment]</p>
<p>or</p>
<p>[label] SCRO source</p>
<p>Use:</p>
<p>A byte value (0 to 255) taken either from defined_expr, or from a
source
argument, will be added to any byte displayed by the FMT statements.
This
screen offset is automatically set to 0 when entering the FMT
sub-interpreter.</p>
<p>It is mostly usefull in Basic, where there is a screen bias of
&gt;60.</p>
<p>Opcode: &gt;FC (defined_expr) or &gt;FD (source).</p>
<pre>Example:<br>       FMT<br>       SCRO &gt;60         basic bias<br>       HTEX 'TI-BASIC READY'<br>       FEND</pre>
<h4><br>
<a name="ROW"></a>ROW set</h4>
<p>Syntax:</p>
<p>[label] ROW expression [comment]</p>
<p>Use:</p>
<p>Sets the current row pointer to the byte value contained in
expression
(0 to 31). This uses two bytes of G memory, whereas ROW+ only requires
one...</p>
<p>Opcode: &gt;FE</p>
<pre>Example:<br>       ROW   5</pre>
<h4><br>
<a name="COL"></a>COLumn set</h4>
<p>Syntax:</p>
<p>[label] COL expression [comment]</p>
<p>Use:</p>
<p>Sets the current column pointer to the value contained in expression
(0 to 32). The row pointer in not affected. This requires two bytes of
G memory, whereas COL+ only requires one.</p>
<p>Opcode: &gt;FF</p>
<pre>Example:<br>       FMT<br>       ROW 1<br>       COL 3<br>       HTEX   'MAIN MENU'<br>       COL=   3<br>       HCHA   9,'='            underline<br>       FEND</pre>
<h4><br>
<a name="COL="></a>COLumn equal</h4>
<p>Syntax:</p>
<p>[label] COL= expression [comment]</p>
<p>Use:</p>
<p>Actually this is not an opcode but an assembly-time instruction used
with my GPL assembler to issue a COL+ statement, bringing the cursor in
the column specified in expression. If the specified column is inferior
or equal to the current one, the cursor gets down one line.</p>
<p>The advantage on a COL statement is that it only takes one byte, the
advantage on a COL+ statement is that it saves you the burden of
calculating
the current cursor position.</p>
<p>However be aware that the assembler calculates cursor position in
order
of appearance of the FMT statements, thus you should not use COL=
inside,
or after RPTB-LOOPs, nor should you assume its value will be retained
from
a FMT-FEND block to another (although it may be, if they are executed
in
the same order they are assembled).</p>
<pre>Example:<br>       ROW  2<br>       COL  5<br>       HTEX 'Last name:'<br>       COL= 5                 brings cursor back on column 5, on next line<br>       HTEX 'First name:'     In this example COL= 5 is assembled as COL+ 22</pre>
<h3><br>
Text mode</h3>
<p>The FMT sub-interpreter is essentially meant for use in basic mode
(32
columns). In text mode (40 columns) some instructions don't work
properly,
these are COL, COL=, ROW and ROW+ that all assume there is 32
characters
per line.</p>
<p>To provide you with a support for text mode, some pseudo-opcodes
have
been created. These actually are assembly-time instructions, that are
assembled
into a serie of regular opcodes. They can only be used with my GPL
assembler.</p>
<p>Notes: </p>
<li>To toggle text mode on, you should modify VDP register 1 with a
MOVE
instruction. For instance set it as &gt;F0. Text and background colors
are determined by VDP register 7.</li>
<li>Remember that line 19 is not accessible by the Fmt sub-interpreter
(it's echoed to line 0), so you'll have to use a MOVE statement to
write
to that line.</li>
<h4><br>
<a name="TPOS"></a>Text POSition</h4>
<p>Syntax:</p>
<p>[label] TPOS defined_expr1,defined_expr2 [comment]</p>
<p>Use:</p>
<p>This is the equivalent of a ROW and a COL statements: defined_expr1
should contain screen row and defined_expr2 screen column to set the
pointer
to.</p>
<p>This statement is assembled as a ROW and a COL statements, taking
into
account the fact that there are now 40 characters per line.</p>
<pre>Example:<br>       TPOS   5,1          text row 5, column 1<br>                           Assembled as ROW 6, column 9 (6*32 + 9 = 5*40 + 1)</pre>
<h4><br>
<a name="TROW"></a>Text ROW</h4>
<p>Syntax:</p>
<p>[label] TROW defined_expr [comment]</p>
<p>Use:</p>
<p>This is the text mode equivalent of the ROW+ opcode. It is assembled
as a ROW+ and a COL+ statement.</p>
<p>N.B. COL+ itself works normally in text mode, but is limited to 32
characters.</p>
<pre>Example:<br>       TROW  3        gets down 3 lines (of 40 chars)<br>                      Assembled as ROW+ 3, COL+ 24 (3*32 + 24 = 3*40)</pre>
<h4><br>
<a name="TCOL"></a>Text COLumn</h4>
<p>Syntax:</p>
<p>[label] TCOL expression [comment]</p>
<p>Use:</p>
<p>This is the text mode equivalent of the COL= opcode. It calculates
the
current cursor position and issues two COL+ statements to bring the
cursor
to the column specified in expression.</p>
<p>If the specified column is inferior or equal to the current position
of the cursor PLUS ONE, the cursor gets down one line.</p>
<p>See COL= for restrictions of use.</p>
<pre>Example:<br>       TPOS  5,1<br>       HTEX  'Input file name:'      (16 characters)<br>       TCOL  1                       One line down, column 1<br>       HCHA  10,'_'                  <br>* In this example, TCOL 1 is assembled as COL+ 10 and COL+ 14 <br>* (16 characters plus 24 columns = 40, i.e. next line).</pre>
<h2><br>
<br>
<hr width="100%"><a name="Instructions"></a>Assembly-time instructions</h2>
<p>Any GPL assembler will provide you with some more instructions that
may or may not issue code, but control the function of the assembler.
As
they are assembler-specific I can't describe them here (have a look at
the doc included in my GPL package for instructions controlling my GPL
assembler). There are some constants however that you will almost
always
encounter:</p>
<h4><a name="BYTE"></a>BYTE</h4>
<p>Syntax:</p>
<p>[label] BYTE expression [comment]</p>
<p>Use:</p>
<p>Lets you insert one or more bytes of data into your GPL program</p>
<pre>Example:<br>      CALL  @MYSUB         call a subroutine<br>      BYTE  &gt;12,'T',&gt;00    3 bytes of data that MYSUB can read with FETC</pre>
<h4><br>
<a name="TEXT"></a>TEXT</h4>
<p>Syntax:</p>
<p>[label] TEXT quoted_string [comment]</p>
<p>Use:</p>
<p>Lets you enter an ascii string as data inside the GROM memory.
Single
or dobble quotes may be used, depending on the assembler (mine use
double
quote to cause a bias to be added).</p>
<pre>Example:<br>       TEXT  'This is a test'</pre>
<h4><br>
<a name="STRI"></a>STRIng</h4>
<p>Syntax:</p>
<p>[label] STRI quoted_string [comment]</p>
<p>Use:</p>
<p>Lets you enter an ascii string, preceded with a length byte, as data
inside the GROM memory. Single or dobble quotes may be used, depending
on the assembler (mine use double quote to cause a bias to be added).</p>
<pre>Example:<br>       STRI  'This is a test'       is equivalent to:<br>       BYTE  14                     string length<br>       TEXT  'This is a test'       string</pre>
<h4><br>
<br>
<a name="EQU"></a>EQUate</h4>
<p>Syntax:</p>
<p>label EQU defined_expression [comment]</p>
<p>Use:</p>
<p>Defines an assembly-time constant, i.e. a label that you will be
able
to use within your program, but that the assembler will replace with
the
value specified in defined_expression. This is one of the rare cases
when
a label is absolutely required.</p>
<pre>Example:<br>KEY    EQU   &gt;8375        defines "KEY" as number &gt;8375<br>       SCAN               scan keyboard<br>       ST    KEY,@&gt;8301   stores &gt;8375 (key value) in @&gt;8301</pre>
<h4><br>
<a name="AORG"></a>Absolute ORiGin</h4>
<p>Syntax:</p>
<p>[label] AORG address [comment]</p>
<p>[label] GROM address [comment]</p>
<p>Use:</p>
<p>Tells the assembler (and the loader) where the program will be
located
in GRAM memory. Should generally appear at the top of the program, but
may also be used to skip a large blank space.</p>
<pre>Example:<br>       AORG  &gt;6000             begins a GRAM address &gt;6000</pre>
<h4><br>
<br>
<a name="COPY"></a>COPY file</h4>
<p>Syntax:</p>
<p>[label] COPY quoted_string [comment]</p>
<p>Use:</p>
<p>If your source file gets very long, it can be a problem to load it
into
a text editor. This instruction causes the assembler to switch to the
source
file specified in the quoted string. Single or double quotes may be
used
according to the assembler. Generally, assembly will resume with the
current
file once the "copied" file has been completely processed. Some
assemblers may allow nested COPY whithin copied files, but that's not
always
the case.</p>
<pre>Example:<br>       COPY  'DSK1.TEST-C'      </pre>
<h4><br>
<br>
<a name="END"></a>END of program</h4>
<p>Syntax:</p>
<p>[label] END [comment]</p>
<p>Use:</p>
<p>Marks the end of the program and instructs the assembler to ignore
whatever
follows.</p>
<p>
</p>
<hr width="100%">
<p></p>
<p><a href="gpl2.htm">Next page</a></p>
<address>Revision 1. 6/5/99 Preliminary. Adapted from the doc in my GPL
package.<br>
Revision 2. 6/12/99 Polished</address>
<center>
<p><br>
<a href="titechpages.htm">Back to the TI-99/4A Tech Pages</a></p>
</center>
</body>
</html>
