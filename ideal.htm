<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.79 [en] (WinNT; U) [Netscape]">
</head>
<body>

<center>
<h1>
<a href="http://www.nouspikel.com/ti99/titechpages.htm"><img SRC="logo.jpg" ALT="" style="border: 0px solid ; height: 33px; width: 95px;" title="" ></a></h1></center>

<h1>
IDEAL 1.1</h1>

<h3>
Introduction</h3>
The <a href="ide.htm">IDE card</a> operating system loaded inside the SRAM
is called IDEAL for "IDE Access Layer". It contains all the routines that
let you access the IDE drives, the clock, the card SRAM and even configure
IDEAL itself.
<p>IDEAL turns your hard disk into a huge collection of "virtual floppies"
that can either be accessed by name, or by "inserting" them into 8 virtual
drives. It is fully compatible with the TI floppy disk format, and therefore
has the same limitations: only 1440 sectors and 127 files per disk, at
most 76 clusters per file, 256 byte per sector, etc.
<p>You'll find some improvements on the TI format though. First of all,
I integrated most of the new features introduced in the Horizon Ramdisk
operating system (a good part of my code is shamelessly lifted from ROS
8.14 and from the TI-controller card ROMs, but why re-invent the wheel?).
Thus, you'll find extra opcodes to delete a record, to load an assembly,
Basic or cartridge file, an autostart feature, and the possibility to place
a file data buffer in CPU memory instead of VDP memory.
<p>IDEAL lets you create directories and subdirectories. In fact, a directory
is nothing more than an empty file that points to another virtual floppy.
This lets you organise your virtual floppies in a hierarchical manner,
while remaining compatible with a floppy disk controller (although of course,
directories won't be more than empty files if you copy them to a real floppy).
<p>IDEAL provides you with the possibility to encrypt a file, or a whole
virtual floppy, using the Blowfish algorithm. You also have a direct access
to the encryption engine, so you can encrypt your own data.
<p>Optionally, IDEAL will time-stamp each file and/or disk with a creation
date and a date of last modification. You can also access the clock directly
to set the time or an alarm, and to retrieve the current date and time,
either as numbers or as pre-formatted text strings. IDEAL version 1.1 through
1.3 support the RTC65271 and the bq4847 clocks. It should also work for
the bq4842 and bq4852 but I haven't tested these. (Version 1.0 was meant
for my prototype card, it only supports the RTC65271 and the bytes in the
IDE data bus are inverted with respect to version 1.1).
<p>The standard catalog function works just as with the TI floppy controller,
but an extended catalog is also provided that returns extra information
on the files (such as the time stamps) and lets you perform some file management
functions. It also lets you edit a floppy sector-wise from Basic.
<p>Finally, IDEAL has the capability of configuring itself, so you can
tailor it to your needs and preferences.
<p><a href="#Loading%20IDEAL">Getting started</a>
<br><a href="#Overview">Overview</a>
<br><a href="#Subdirectories">Subdirectories</a>
<br><a href="#Encryption">Encryption</a>
<br><a href="#Catalog">Extended catalog</a>
<br><a href="#Sector%20access">Sector-wise access</a>
<br><a href="#Collection">Editing the floppy collection</a>
<br><a href="#clock">Accessing the clock</a>
<br><a href="#Configuration">System configuration</a>
<br><a href="#Drive%20ID">Drive configuration</a>
<br><a href="#hard-drive%20access">Direct hard-drive access</a>
<p><a href="#DSRs">DSRs</a>
<br><a href="#DSRs">Subprograms</a>
<br><a href="#New%20format">Modifications to the TI format</a>
<h2>
<a NAME="Loading IDEAL"></a>Getting started</h2>
This section discusses how to instal IDEAL in your IDE card and how to
configure it for the first time. When reading this document for the first
time you can just jump ahead to the <a href="#Overview">Overview</a> chapter.
<p>Installing IDEAL involves the following steps
<ol>
<li>
Download the program: <a href="ideal.zip">IDEAL11.ZIP</a> (~200 kB) and
expand it on your PC.</li>

<li>
Follow the instructcions in the README.TXT file to transfer the proper
.DSK file to your TI-99/4A.</li>

<li>
Load IDEAL into the SRAM. Optionally load a bootstrap into the RTC65271
clock RAM.</li>

<li>
Set the proper time and date, using the TI-Basic program <tt>SETDATE</tt>..</li>

<li>
In TI-Basic, run <tt>NEWCFG </tt>(after <tt>CALL FILES(1)</tt> ) to configure
the system as you wish.</li>

<li>
Copy the IDEAL/x files to your hard-drive, for the bootstrap to load them
at power-up time (optional).</li>
</ol>

<h4>
Version number</h4>
The ZIP file contains several versions of IDEAL, each in the form of a
TI-99/4A single-side, single-density disk image. Make sure to pick the
right one, as they are not cross-compatible:
<ul>
<li>
IDEAL10.DSK This is version 1.0, meant for my point-to-point soldered proto-board,
which used the RTC56271 clock. It's also the only version working with
the MESS emulator, as faras I know.</li>

<li>
IDEAL11.DSK This is version 1.1 It's the same as version 1.0, except that
it takes into account the byte swapping of the IDE data bus. To be used
with the new IDE card PCB, with the RTC65271 clock.</li>

<li>
IDEAL12.DSK This is version 1.2 Same as v1.1, but adapted for use with
the bq4847 clock.</li>

<li>
IDEAL13.DSK This is version 1.3 Same as v1.1, but adapted for use with
the bq4842 and bq4852 clocks.</li>
</ul>

<h4>
<br>
Files to be found in the ".DSK" disk image file</h4>

<pre><u>File&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Type&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Usage&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</u>IDEAL/A ... IDEAL/M Program&nbsp;&nbsp;&nbsp; IDEAL operating system to be loaded into the SRAM
IDEAL/Z&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Program&nbsp;&nbsp;&nbsp; Bootstrap (resides in the RTC65271 clock RAM)
IDELOAD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Program&nbsp;&nbsp;&nbsp; System loader (loads IDEAL + boostrap + config)
IDE-LD2/O&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DF80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Patch for the above, for non-standard cards
IDE-LD2/S&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DV80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Source for the patch
IDEAL/GK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Program&nbsp;&nbsp;&nbsp; German 128K Gram-Karte access routine
IDEAL/PG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Program&nbsp;&nbsp;&nbsp; P-Gram+ card access routine
IDE_GC/S&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DV80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Demo: sources for IDEAL/GK and IDEAL/PG
NEWCFG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TI-Basic&nbsp;&nbsp; Configures IDEAL (Do CALL FILES(1) before OLD)
SETIME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TI-Basic&nbsp;&nbsp; Sets the time and date
NOLOAD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Program&nbsp;&nbsp;&nbsp; Placeholder file for Mini-IDEAL
IDEDIAG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Program&nbsp;&nbsp;&nbsp; Hardware diagnostic program (see <a href="idediag.htm">manual</a> for details)
CONFIG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TI-Basic&nbsp;&nbsp; Demo: Reads the system configuration
FLOP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TI-Basic&nbsp;&nbsp; Demo: Embryonic virtual-floppy manager
TRASH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TI-Basic&nbsp;&nbsp; Demo: Recovers deleted floppies
CAT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TI-Basic&nbsp;&nbsp; Demo: Extended disk catalog
BLOW&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TI-Basic&nbsp;&nbsp; Demo: Direct access to the encryption engine
CLOCK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TI-Basic&nbsp;&nbsp; Demo: Access the real-time-clock DSR
INTS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TI-Basic&nbsp;&nbsp; Demo: Setting clock interrupts
SECTORS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TI-Basic&nbsp;&nbsp; Demo: Direct access to hard-drive sectors
RESTORECFG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TI-Basic&nbsp;&nbsp; Demo: Restoring a lost configuration
VAR2FIX&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TI-Basic&nbsp;&nbsp; To copy a DV80 file into a DF80 (for IDE-LD2/O)</pre>
NB Don't try to run the <tt>IDEAL/x</tt> files with an EA5 loader: they
must be loaded into the card SRAM and only <tt>IDELOAD</tt> knows how to
do this properly.
<p><b>Installing the IDE card</b>
<p>First pick up a CRU address for the card. There should not be any other
card with this CRU in your system. A convenient CRU to use is >1000, so
that the IDE card will be scanned before the floppy disk controller (whose
CRU is >1100). If you don't know what CRU addresses are available in your
system, you can load my <a href="download.htm#modexp">Module Explorer</a>
program, press Ctrl-7, then Fctn-3 to enter the Header Analyser. The arrow
keys let you travel among the installed cards and their subprograms, DSRs,
etc.
<p>Note: if you're planning to use the "autostart" feature to launch a
program at power-up time, you should pick a CRU address higher than that
of any card that has a power-up routine in its DSRs. Otherwise, because
IDEAL will abort the power up sequence when launching the desired program,
the other cards may not be initialized properly. Exemple of such cards
are the floppy disk controller card (CRU >1100), the RS232 card (CRU >1300),
the German Gram-Karte (selectable CRU), and my USB-SM card (selectable
CRU).
<p>Once you decided on the CRU address, set its second digit on the rotary
that's at the bottom left of the card. For instance, if you picked CRU
>1200, you would set the encoder on '2'.
<p>Below the encoder, you'll find a 4-switches DIP switch. It is meant
for use with the RTC65271 clock chip:
<ul>
<li>
The top switch lets you decide whether the RAM inside the RTC65271 or the
SRAM should appear at >4000 when the power is first turned on. If you have
a battery-backed SRAM open the switch, otherwise close it and load the
bootstrap into the clock. If you have any other clock chip than the RTC65271,
leave the switch open.</li>

<li>
The second switch lets you decide whether the RTC65271 should be reset
upon power-up, which will clear any pending interrupt. This will prevent
lockups in case an interrupt occured while power was off, and is detected
before the system is installed. The switch doesn't affect other clock chips.</li>

<li>
The remaining 2 switches are reserved for future expansions.</li>
</ul>
Make sure the main switch at the back of the card is off (all the way to
the front), so any garbage in the SRAM (or clock RAM) won't prevent the
system from booting. Place the "machine selection" switch in the middle
of the card to "T" if you're using a TI-99/4A, or to "G" if you have a
Geneve.
<p>Connect your hard drive(s) to the card via a standard IDE cable. Then
carefully insert the card in the PE-box. If your drive doesn't have its
own power supply, you can connect it to the floppy disk power supply. However,
I noticed that there is not enough power to support both my floppy drive
and my hard drive: when the floppy kicks in, the hard drive stops spinning!
Thus, it may be better to remove the floppy drive altogether. Another possibility
is to modify the PE-box power supply, so that it provides more current.
But this is another endeavour...
<p>Now, power-up the system: first the PE-box (and hard-drive), then the
console. If your drive takes a few seconds to spin up, it's a good practice
to wait till it's ready before you turn the console on. Then flip the main
switch on the card, so that it becomes active. With a TI-99/4A, pull it
all the way back, with a Geneve use the middle position.
<h4>
Loading IDEAL into the SRAM</h4>
The first thing to do is to load the system into the SRAM so you can access
the hard disk. You can also load a bootstrap into the clock RAM.
<p>N.B. If you have a Gram device, you may want to first replace the file
<tt>IDEAL/G</tt>
with the one corresponding to your Gram card: just rename
<tt>IDEAL/GK</tt>
for the german 128K Gram Karte, or <tt>IDEAL/PG</tt> for the PGram card.
The original <tt>IDEAL/G</tt> file contains both routines, but calls the
one for the Gram Karte. If you have a different Gram device, you will need
to write a custom routine if you want IDEAL to handle it (which is optional
anyhow). See <a href="#Gcard%20routine">below</a> for a description of
the required routine.
<p>Now load the program <tt>IDELOAD</tt> using Editor/Assembler option
5, or with a similar loader (such as Funnelweb). The program first prompts
you for the CRU of your IDE card. Enter the value that you set with the
endoder on the card, i.e. the second digit of the CRU address. Provided
the card is found and the hard-drive answers properly (you <b>must </b>have
a drive plugged in at that time), <tt>IDELOAD</tt> will ask whether you
want to load IDEAL, the bootstrap and/or the configuration. Finally, you
must enter the number of the drive where the files are to be found (normally,
this will be <tt>DSK1</tt>). At any time, you can press F9 (back) to go
back to the previous step. Loading begins after you entered the drive number.
<p>If you elected to load the configuration, or if you loaded IDEAL, <tt>IDELOAD
</tt>will
check the RTC65271 clock memory (if you have this clock chip, that is)
for valid configuration data, and ask you whether you want to keep it.
If you decline, or if none was found, the program checks a reserved area
on the hard drive, where a backup of the configuration is kept. If a valid
configuration is found there, you again have the choice to use it or not.
If you don't, or if none was found, the programs asks you if you want to
load the configuration from the file <tt>IDEAL/M</tt>. The latter option
is not offered if you have just loaded IDEAL, since in this case the configuration
has already been loaded from file anyhow.
<p>The bootstrap is the file <tt>IDEAL/Z</tt>. It's a small program that
resides into the clock memory and loads IDEAL from your hard drive when
you power-up your system. Of course, this implies that you have copied
(or intend to copy) IDEAL on your hard-drive. Loading the boostrap into
the clock is only meaninfull with the RTC65271 clock.
<p>Once loading is completed you have the option to leave the bootstrap
in control. This means that the next time you hit &lt;quit>, the bootstrap
will attempt to load IDEAL from the hard drive. Obviously, you should only
select this option if you have already copied IDEAL on the hard drive (i.e.
if you are reinstalling the system). Answer by Y or N to exit, or press
&lt;back> to return to the drive number prompt. If you are using the Editor/Assembler
cartridge, you may get an "Error 00" message after exiting the program.
Just ignore it: I forgot to clear the GPL status byte before exiting. You
won't see this message with Funnelweb.
<p><u>Technical note</u>
<p>If you made changes to my schematics and are using different CRU bits,
you will need to patch <tt>IDELOAD </tt>so that it modifies the system
accordingly. See <a href="#non-standard">below</a> for details.
<h4>
Setting the time and date</h4>
At this point, you may want to open the <tt>CLOCK </tt>DSR and set up the
correct time and date. Refer to the clock section <a href="#clock">below</a>.
<p>Alternatively, you can run the TI-Basic program <tt>SETIME </tt>that
will walk you through the process.
<h4>
Copying IDEAL on the hard disk</h4>
If you are installing IDEAL for the first time, it's a good idea to make
a copy of it on the hard drive. This will make possible for the bootstrap
to automatically load IDEAL when the system powers up. It is not required
if you have another clock chip, but it won't hurt to do it anyhow.
<p>Create a new virtual floppy either with a disk manager "format" command
or by using the <tt>IDE.FLOPPIES</tt> pseudo-file:
<pre>OPEN #1:"IDE.FLOPPIES", INTERNAL, FIXED 128, APPEND
PRINT #1:"IDEAL",360
CLOSE #1
CALL CD.5..IDEAL</pre>
N.B. The <tt>CALL </tt>loads the virtual floppy into a virtual drive called
<tt>DSK5</tt>
(by default IDEAL comes with drives DSK4, 5, 6, 7, 8, 9, A and B installed).
<p>Now use a disk manager to copy the IDEAL disk to <tt>DSK5</tt>.
<p>IDEAL will be automatically reloaded in the following circumstances:
<li>
If DIP-switch 1 is closed and a valid copy of IDEAL is not present in the
SRAM when you power-up the TI-99/4A, the bootstrap will load IDEAL from
the hard drive. This only works with the RTC65271 clock chip.</li>

<li>
When you reset the TI-99/4A, IDEAL checks itself for integrity (so as not
to slow down the reset, only a small part of page 0 is tested). If any
corruption is detected, the boostrap is called and IDEAL is reloaded from
disk. If no boostrap is present in the clock memory, or if you have a different
clock chip, IDEAL makes itself invisible to the system by clearing word
>4000 in the SRAM.</li>

<li>
You can force a reload by holding down Ctrl-Enter while the TI-99/4A is
restarting.</li>

<h4>
Configuring your system</h4>
The TI-Basic program called <tt>NEWCFG </tt>can be used to set your system
configuration after you installed it. Note that you must perform
<tt>CALL
FILES(1)</tt> before you load this program (it's big and slow...). The
program starts by asking for a password: for the moment being just hit
&lt;enter>. Later on you can use option 6 to set your own password. The
other options let you configure IDEAL.
<p>Alternatively, you can update the configuration yourself via the file
<tt>IDE.CONFIG</tt>,
which is what <tt>NEWCFG </tt>is doing anyway. Refer to the corresponding
section <a href="#Configuration">below</a>.
<p>In any case, the parameters that you should set are:
<li>
Hardware description (if non-standard)</li>

<li>
User options</li>

<li>
Name of the virtual drives</li>

<li>
Location of the system files</li>

<li>
Optionally: autostart program, location of the Extended Basic cartridge.</li>

<p><br>Now you are ready to roll... A few more technical details follow,
but on first reading you can just skip ahead to the "<a href="#Overview">Overview</a>"
section.
<h4>
Backup issues</h4>
In addition to the above options, IDEAL also retains some important internal
pointers, such as the root of your floppy disk collection (arranged as
an <a href="avltrees.htm">AVL tree</a>) or pointers to each trash list
(arranged as double-linked lists). Obviously, you can't afford loosing
this information, so several layers of backup have been implemented into
IDEAL:
<p>1) If you have a battery-backed SRAM, the configuration info should
be safe at any time, even when the PE-box is turned off. Unless of course
the battery runs out...
<p>2) If you're using the RTC765271 clock chip, the configuration will
automatically be saved into it after any change. When you reload IDEAL
(either with <tt>IDELOAD</tt>, or through the boostrap), the configuration
is copied from the clock memory into the SRAM. This level of backup is
not available with the other clock chips (but those battery-back the SRAM
instead).
<p>3) An additional backup is maintained on the hard-drive itself, in a
reserved area that is not part of your virtual floppy collection (namely,
hard-drive sector 0). This backup is updated each time you <tt>CLOSE </tt>the
file <tt>IDE.CONFIG </tt>after a modification. If you reset the computer
before closing the file, any change you made will be saved into the clock
RAM but not on disk!
<p>Note: With the RTC65271, this backup is only used if a valid configuration
cannot be found in the clock memory when IDEAL is loaded. To invalidate
it and use the disk backup instead, use the <tt>CLOCK </tt>DSR to alter
page 55 in the clock memory:
<pre>100 OPEN #1:"CLOCK", INTERNAL, FIXED 128, RELATIVE
110 PRINT #1, REC(100+55): "0123456789abcdef0123456789abcdef"
120 CLOSE #1</pre>
Then force a system reload by holding down Ctrl-Enter while you reset the
TI-99/4A.
<p>4) If you feel that you need an additional level of backup, you can
save the configuration present in the hard drive onto a floppy. This implies
that sector-wise access of the hard drive is enabled (you can always turn
it off later).
<pre>100 OPEN #1: "IDE.SECTORS", INTERNAL, FIXED 129, RELATIVE
110 PRINT #1, REC 0: 0,0
120 INPUT #1: PART1$
130 INPUT #1: PART2$
140 INPUT #1: PART3$
150 INPUT #1: PART4$
160 CLOSE #1
170 OPEN #2:"DSK1.BACKUP",INTERNAL, FIXED 129, OUTPUT
180 PRINT #2: PART1$
190 PRINT #2: PART2$
200 PRINT #2: PART3$
210 PRINT #2: PART4$
220 CLOSE #2</pre>
To restore a lost configuration from such a backup just reverse the process,
then invalidate the clock memory and force a reload as described above.
<p>5) If everything fails and you have lost your configuration without
any up-to-date backup, you will need to re-enter your favorite options
using the <tt>IDE.CONFIG</tt> pseudo-file. By accessing <a href="#config%20rec22">record
22</a> of the same file, you can also trigger a scanning routine that will
inspect your hard drive for virtual floppies and (hopefully) return your
collection root and trash lists endpoints. These values can then be passed
to <a href="#config%20rec5">record 5</a> to restore your configuration.
<h4>
<br>
Mini-IDEAL</h4>
IDEAL is quite a big program. Currently, it uses 10 pages in the SRAM,
for a total of about 50 Kbytes. That's not a problem if you have a 128K
or a 512K SRAM on your card, but if you went the cheap way and have only
32K you are in trouble. Not to worry though: there is a way to skim down
IDEAL, so it would fit in four pages. This may also be usefull if you want
to use a lot of RAMBO pages.
<p>Here are the SRAM pages used by IDEAL:
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Page 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Page 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Page 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

>4000+-----------------+&nbsp; +-----------------+&nbsp; +-----------------+
&nbsp;&nbsp;&nbsp;&nbsp; | Registers&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; | xxxxxxxxxxxxxxx |&nbsp; | xxxxxxxxxxxxxxx |
>4000+-----------------+&nbsp; +-----------------+&nbsp; +-----------------+
&nbsp;&nbsp;&nbsp;&nbsp; | Entry points&nbsp;&nbsp;&nbsp; |&nbsp; | CLOCK DSR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; | Char patterns&nbsp;&nbsp; |
&nbsp;&nbsp;&nbsp;&nbsp; | Config data&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; | RAMBO manager&nbsp;&nbsp; |&nbsp; | for LD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
&nbsp;&nbsp;&nbsp;&nbsp; | Common&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; | ISR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
&nbsp;&nbsp;&nbsp;&nbsp; | subroutines&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
>5000+-----------------+&nbsp; +-----------------+&nbsp; +-----------------+
&nbsp;&nbsp;&nbsp;&nbsp; | Sub >10 >14 >15 |&nbsp; | Opcodes 0 to 4&nbsp; |&nbsp; | Autostart&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
&nbsp;&nbsp;&nbsp;&nbsp; | Dir-files subs&nbsp; |&nbsp; | 8 and 9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; | LD DSR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; | Opcodes >A to >C|
&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; | Sub >11 >12 >13 |
&nbsp;&nbsp;&nbsp;&nbsp; | Buffers (>5B00) |&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; | Custom subs&nbsp;&nbsp;&nbsp;&nbsp; |
&nbsp;&nbsp;&nbsp;&nbsp; +-----------------+&nbsp; +-----------------+&nbsp; +-----------------+</pre>

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Page 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Page 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Page 5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Page 6

>4000+-----------------+&nbsp; +-----------------+&nbsp; +-----------------+&nbsp; +-----------------+
&nbsp;&nbsp;&nbsp;&nbsp; |xxxxxxxxxxxxxxx&nbsp; |&nbsp; | xxxxxxxxxxxxxxx |&nbsp; | xxxxxxxxxxxxxxx |&nbsp; | xxxxxxxxxxxxxxx |
>4100+-----------------+&nbsp; +-----------------+&nbsp; +-----------------+&nbsp; +-----------------+
&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; not used&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; | Number Pi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; | Encryption&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; |&nbsp;&nbsp;&nbsp; not used&nbsp;&nbsp;&nbsp;&nbsp; |
&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; | for Blowfish&nbsp;&nbsp;&nbsp; |&nbsp; | key&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
>5000+-----------------+&nbsp; +-----------------+&nbsp; +-----------------+&nbsp; +-----------------+
&nbsp;&nbsp;&nbsp;&nbsp; | Floppy collec&nbsp;&nbsp; |&nbsp; | Configuration&nbsp;&nbsp; |&nbsp; | Blowfish&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; | Trash management|
&nbsp;&nbsp;&nbsp;&nbsp; | management&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; | management&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; | encryption&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; | IDE.TRASHx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
&nbsp;&nbsp;&nbsp;&nbsp; | IDE.FLOPPIES&nbsp;&nbsp;&nbsp; |&nbsp; | Catalog&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; | IDE.BLOWxxx&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; | IDE.CONFIG rec22|
&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; | Extended cat&nbsp;&nbsp;&nbsp; |&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
&nbsp;&nbsp;&nbsp;&nbsp; | Buffers&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; | Buffers&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
&nbsp;&nbsp;&nbsp;&nbsp; +-----------------+&nbsp; +-----------------+&nbsp; +-----------------+&nbsp; +-----------------+</pre>

<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Next page&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Next page&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Next page&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

>4000+-----------------+&nbsp; +-----------------+&nbsp; +-----------------+
&nbsp;&nbsp;&nbsp;&nbsp; | xxxxxxxxxxxxxxx |&nbsp; | xxxxxxxxxxxxxxx |&nbsp; | xxxxxxxxxxxxxxx |
>4000+-----------------+&nbsp; +-----------------+&nbsp; +-----------------+
&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp; not used&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; |&nbsp;&nbsp;&nbsp; not used&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; |&nbsp;&nbsp;&nbsp; not used&nbsp;&nbsp;&nbsp;&nbsp; |
&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
>5000+-----------------+&nbsp; +-----------------+&nbsp; +-----------------+&nbsp;&nbsp; (more pages)
&nbsp;&nbsp;&nbsp;&nbsp; | Buffering subs&nbsp; |&nbsp; | Buffering subs&nbsp; |&nbsp; | Buffering subs&nbsp; |&nbsp;&nbsp; (if needed )
>5400+ Opened files&nbsp;&nbsp;&nbsp; |&nbsp; | Opened files&nbsp;&nbsp;&nbsp; |&nbsp; | Opened files&nbsp;&nbsp;&nbsp; |
&nbsp;&nbsp;&nbsp;&nbsp; | buffers&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; | buffers&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; | buffers&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
&nbsp;&nbsp;&nbsp;&nbsp; | (5 files)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; | (5 files)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; | (5 files)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
&nbsp;&nbsp;&nbsp;&nbsp; +-----------------+&nbsp; +-----------------+&nbsp; +-----------------+</pre>
<u>Notes</u>: Version 1.3 has nothing in page 1 below >5000. Instead, the
clock routines are in the last SRAM page. The low part of the page is used
to emulate XRAM pages, the high part contains the clock routines and the
clock registers (which map at >5FF0-5FFF).
<br>Due to lack of space in page 4, the code for record 22 of IDE.CONFIG
is at the end of page 6.
<p>As you can see, Blowfish encryption is the most memory-hungry feature.
So if you have no use for it, you can save a page and a half.
<p>If you decide that your floppy collection is complete for now, you can
remove the collection manager and the trash manager. This means that you
will not be able to rename a floppy since it would require rearranging
the collection.
<p>If you are satisfied with the current configuration and have no need
for the catalog function, you can also remove page 4.
<p>You can reclaim the lower part of page 1 if you don't use RAMBO mode,
nor call the <tt>CLOCK </tt>DSR (time stamping still works though). Similarly,
if you don't use <tt>LD </tt>nor the autostart feature (or only to launch
programs that set up their own character patterns) you can reclaim the
lower part of page 2.
<p>Finally, you can decrease the number of opened files, so as to use less
pages to buffer them. Opened files buffers are always in the pages immediately
following the system. There is room for 5 files per page.
<p>Once you have made up your mind as to what you want to keep, you can
remove some of the <tt>IDEAL/x</tt> files. Each time you remove such a
file, replace it with a copy of the file called <tt>NOLOAD</tt> renamed
as <tt>IDEAL/x</tt>. Here is the list of system files:
<pre>IDEAL/A&nbsp; Page 0 high (required)
IDEAL/B&nbsp; Page 1 low
IDEAL/C&nbsp; Page 1 high (required)
IDEAL/D&nbsp; Page 2 low
IDEAL/E&nbsp; Page 2 high (required)
IDEAL/F&nbsp; Page 3 high
IDEAL/G&nbsp; Gram Card-specific routines (in page 2)
IDEAL/H&nbsp; Page 4 low
IDEAL/I&nbsp; Page 4 high
IDEAL/J&nbsp; Page 5 high (page 5 low is filled on the fly)
IDEAL/K&nbsp; Page 6 high
IDEAL/L&nbsp; Buffer pages (required)
IDEAL/M&nbsp; Page 0 low (required, must be last file)</pre>
To avoid crashes, you should edit your system configuration and indicate
which features have been disabled (record 20 in <tt>IDE.CONFIG</tt>). Obviously,
if you disable the configuration feature, you should do this before removing
the file!
<p>If you ever need the full-fledge IDEAL, you can always load it from
a floppy with <tt>IDELOAD</tt>.
<h4>
<a NAME="non-standard"></a>Non-standard IDE card</h4>
If you did not build the IDE card according to specs, it is still possible
to use IDEAL but you must configure it correspondingly with the hardware
part of <tt>IDE.CONFIG</tt> (records 20 and 21, see <a href="#Configuration">below</a>).
The problem here is that, if you used different CRU bits than me, <tt>IDE.CONFIG</tt>
won't work. Thus you must patch <tt>IDELOAD </tt>so that it places the
proper CRU values in IDEAL and in the bootstrap.
<p>To this end, edit <tt>IDE-LD2/O</tt> with a text editor. It's a non-compressed
DF80 file, with all the parameters needed by <tt>IDELOAD</tt>. Modify them
according to your hardware. The file is commented for your convenience.
<p>Remember that CRU bits are off at power-up time, so any function that
you want to be the default should be active-low. For active-low bits, enter
the string:
<pre>9yyyyB1E0xB1D0xF</pre>
Where x is the bit number, >1D0x is the code for <tt>SBO </tt>and >1E0x
is the opcode for <tt>SBZ</tt>. (9yyyy is the loading address, leave it
unchanged).
<p>For active-high bits, just invert the two commands:
<pre>9yyyyB1D0xB1E0xF</pre>
If you did not implement a bit, replace both commands with NOPs (opcode
>1000):
<pre>9yyyyB1000B1000F</pre>
Once done, save the file back in DF80 format. If your text editor won't
let you do this (e.g. Funnelweb's), save it as DF80 and use the TI-Basic
program VAR2FIX to convert it to DF80.
<p>Alternatively, you can edit the source file <tt>IDE-LD2/S</tt> and assemble
it.
<p>In any case, once you have set up the proper bit values, the procedure
is the following:
<ul>
<li>
Load <tt>IDELOAD </tt>with Editor/Assembler option 5 (or equivalent).</li>

<li>
Press &lt;back> to exit immediately.</li>

<li>
Load <tt>IDE-LD2/O</tt> with Editor/Assembler option3 (or equivalent).
It will auto-start and take you to the main menu in <tt>IDELOAD</tt>.</li>

<li>
Proceed as above to load your system.</li>
</ul>
Yeah, I know it's complicated. That's what you get for not following the
specs...
<h2>
<br>
<a NAME="Overview"></a>Overview</h2>

<h4>
File access</h4>
All virtual floppies in your collection can be accessed by name with the
<b>DSK@</b>
device. For instance:
<p><tt>OLD DSK@.DISKNAME.FILENAME</tt>
<p>Note the similarity with the <tt>DSK.DISKNAME.FILENAME</tt> syntax used
by the floppy disk controller. In fact, the latter will also work with
the IDE card, but only if its CRU address is set as >1000. This is because
the floppy controller, which is the second card scanned (its CRU is >1100),
returns an error if it does not find <tt>DISKNAME </tt>in one of its drives.
Of course, if you don't have a floppy controller installed, there won't
be any problem with using <tt>DSK.DISKNAME.FILENAME</tt>, no matter what
the CRU of the IDE card is.
<p>Alternatively, a virtual floppy can be "inserted" into a virtual drive.
There are eight such drives, with names in the format <b>DSKn</b>, where
n is a number from 1 to 9, or a letter from A to Z. Once a virtual floppy
is inserted, it can be accessed as if it were in a real drive:
<pre>OPEN #1:"DSK9.FILENAME",INPUT</pre>
A difference with the standard TI floppy controller is that, if the file
already exists, you don't need to specify its type when opening it: if
the record size is 0 (which it will be in Basic if you do not specify a
record length), the size and file type are supplied from disk. Note however
that Basic requires a comma after the filename in <tt>OPEN</tt>, so you'll
need to supply at least one parameter (like <tt>INPUT </tt>in the example
above).
<p>Another difference is that you can now open fixed files in append mode.
<p>Inserting a floppy in a virtual drive is the only way you can make it
available to the standard sector-access subprograms (subprograms >10 to
>15). As most disk managers exclusively use these subprograms (e.g. DISKU),
this feature will come handy with them.
<h4>
<br>
Catalog access</h4>
You can catalog the floppy currently in a virtual drive just the way you
would with a real floppy:
<p><tt>OPEN #1:"DSK9.",INTERNAL, FIXED 38, INPUT</tt>
<p>or, using the disk name:
<p><tt>OPEN #1: "DSK@.DISKNAME.", INTERNAL, FIXED 38, INPUT</tt>
<p>In addition, IDEAL offers a more sophisticated catalog access, see <a href="#Catalog">below</a>.
<h4>
<br>
<br>
Inserting a virtual floppy into a virtual drive</h4>
To "insert" a virtual floppy into a virtual drive use the
<b>CD</b> subprogram.
It can be used in several ways:
<p>1) With the disk name:
<pre>CALL CD.9..DISKNAME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TI-Basic or Assembly

CALL CD".9..DISKNAME"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Extended-Basic

DELETE "CD.9..DISKNAME"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Any</pre>
The double-dot syntax tells the system that you are not trying to access
a file called <tt>DISKNAME </tt>on the floppy currently in <tt>DSK9</tt>,
but rather to insert the floppy called <tt>DISKNAME </tt>into the drive
<tt>DSK9</tt>.
<p>Note that CD can be considered both as a subprogram, called with <tt>CALL
</tt>from
Basic or <tt>DSRLNK</tt> with offset <tt>>000A</tt> from assembly, and
as a device, accessed with any file operation (such as <tt>DELETE</tt>)
in Basic or <tt>DSRLNK </tt>with offest <tt>>0008</tt> in assembly.
<p>The advantage of the later is that you can use string variables: <tt>DELETE
A$</tt> is legal in Basic, whereas <tt>CALL A$</tt> is not. In addition,
Extended Basic truncates the diskname at the first non-digit character
(the dot and the &lt; sign are ok, though), so to make it work you will
need to enclose the path in double quotes... which will not work in Basic!
The device solution always works.
<p>Note that any file operation will do, <tt>DELETE </tt>is just convenient
because it does not take any file number in Basic. And don't worry, nothing
will be deleted: no other action than inserting the floppy will be taken
whatever file operation you use.
<p>2) By following a directory path:
<p>If the virtual floppy currently in the virtual drive contains a <a href="#Subdirectories">directory
pointer file</a>, you can follow it to access the corresponding disk. This
will automatically insert the floppy the directory file is pointing at,
in place of the current floppy. For instance:
<pre>CALL CD.9.MYDIR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or

DELETE "CD.9.MYDIR"&nbsp;&nbsp;&nbsp;&nbsp; or

OPEN #1:"DSK9.MYDIR",INTERNAL,FIXED 1,INPUT</pre>
will insert into <tt>DSK9 </tt>the floppy pointed at by the file <tt>MYDIR,</tt>
currently in <tt>DSK9</tt>.
<p>3) Finally, how to insert a floppy into a virtual drive when working
within a disk manager program, like DISKU?
<p>The problem here is that DISKU does almost everything with the sector-access
subprogram >10, which does not take any filename. Exceptions are Viewing
and Deleting files. So here is the technique: 1) Create a file with the
name of the disk you want to insert, preceded with a dot (e.g. <tt>".MYDISK"</tt>).
2) Delete it. It won't be deleted (to do this you must rename it first),
but the drive will now contain the required disk.
<p>Alternatively, you can just follow a directory path by attempting to
View the corresponding directory file. DISKU will <tt>OPEN </tt>it, which
automatically inserts the target disk into the drive. You'll get an error
message because DISKU tries to <tt>READ</tt>, then <tt>CLOSE </tt>the file,
which cannot be found any more since the disk just changed. Acknowledge
the error and press &lt;redo> to update the listing: you should see the
content of the new disk.
<h4>
<br>
Removing a virtual floppy from a virtual drive</h4>
Do just as above, but with no diskname:
<pre><tt>CALL CD.Z..&nbsp; </tt>or&nbsp;

<tt>CALL CD.Z.&nbsp;&nbsp; or even

CALL CD.Z</tt></pre>
This will not delete anything: the virtual floppy remains in your collection.
It just means that it cannot be accessed via <tt>DSKZ </tt>any longer.
<p>In Extended Basic, these will only work if the drive number is a digit.
To make it work with a letter, you must type:
<pre><tt>CALL CD".Z.."&nbsp; </tt>or&nbsp;

<tt>CALL CD".Z."&nbsp;&nbsp; or

CALL CD".Z"</tt></pre>
A file operation can be used in the same manner:
<pre><tt>DELETE "CD.9.."&nbsp; or

DELETE "CD.9."&nbsp;&nbsp; or

DELETE "CD.9"</tt></pre>
Caution: if you have opened files in this drive, you must close them BEFORE
removing the floppy, otherwise the most recent changes may be lost (of
course, this may be precisely what you are trying to do).
<h4>
<br>
Adding a new virtual floppy to your collection</h4>
There are several methods:
<p>1) Use a disk manager to format a virtual drive: an empty virtual floppy
with the required size and name will be added to your collection. If there
was a floppy in this drive before, it is simply returned to the collection;
it won't be overwritten by the formatting operation.
<p>2) Edit your collection by opening the file <tt>IDE.FLOPPIES </tt>in
append mode, and create a new record containing the new disk name and its
size in sectors:
<p><tt>100 OPEN #1:"IDE.FLOPPIES", INTERNAL, VARIABLE 128, APPEND</tt>
<br><tt>110 PRINT #1:"DISKNAME",360</tt>
<br><tt>120 CLOSE #1</tt>
<p>3) Use the Basic program FLOP, which calls <tt>IDE.FLOPPIES</tt> for
you. Select "Add a floppy" from the menu and supply a unique name and a
size (360, 720 or 1440 sectors). Note that the "List floppies" option will
start after the newly created floppy, in alphabetical order. To start from
the beginning, press &lt;enter> to stop the listing and ask for the listing
again.
<h4>
<br>
Removing a virtual floppy from your collection</h4>
You could use the corresponding option in the Basic program FLOP, or do
it "manually" and edit your collection by opening the file
<tt>IDE.FLOPPIES</tt>
in update mode, locate the record of interest and overwrite it with an
empty name and a size of -1:
<p><tt>100 OPEN #1:"IDE.FLOPPIES", INTERNAL, VARIABLE 128, APPEND</tt>
<br><tt>110 I=1</tt>
<br><tt>120 INPUT #1, REC I:A$</tt>
<br><tt>130 IF A$="DISKNAME" THEN 200</tt>
<br><tt>140 I=I+1</tt>
<br><tt>150 GOTO 120</tt>
<br><tt>200 PRINT #1, REC I:"",-1</tt>
<br><tt>210 CLOSE #1</tt>
<p>NB. There is a faster way to locate the proper record, see <a href="#Collection">below</a>.
Also, there is a way to recover floppies deleted by mistake.
<h2>
<br>
<a NAME="Subdirectories"></a>Subdirectories</h2>
IDEAL provides a rudimentary implementation of subdirectories: it lets
you define files that do not contain any data, but rather point at another
virtual floppy. This second floppy can thus be considered as a subdirectory
of the first one. Note that, unlike PC folders, subdirectories don't need
to be arranged in a tree: a given floppy can be a subdirectory of many
others (there can even be circular references, so be carefull). In fact,
directories are more like Windows shortcuts, except that they point to
virtual floppies, not to files.
<p>To a regular disk manager, subdirectories appear as empty Int/Fix 1
or Int/Var 1 files. Only IDEAL recognizes them as directory pointers and
uses them accordingly.
<h4>
Accessing subdirectories</h4>
To access a file in a subdirectory of the floppy currently in a virtual
drive, use the following syntax:
<p><tt>OPEN #1: "DSK7.DIRECTORY.FILENAME"</tt>
<p>Where <tt>FILENAME </tt>is a file located in the virtual floppy pointed
at by the pointer file named <tt>DIRECTORY</tt>. To make things clearer,
I'd suggest that you always give your pointer files the same name as the
floppy they are pointing at. In fact IDEAL can do this automatically for
Int/Fix 1 directory files: whenever you rename a floppy, all the files
pointing to it are also renamed (unless a file with this name already exists,
in which case the pointer file becomes Int/Var 1). When you remove the
floppy from your collection, all pointer files leading to it are deleted
or, if protected, marked as invalid (they become Int/Fix 2 or Int/Var 2).
<p>If the target floppy itself contains pointer files, you can specify
a whole directory path:
<p><tt>SAVE DSK6.DIR.SUBDIR.SUBSUBDIR.FILENAME</tt>
<br>&nbsp;
<p>When you create a pointer file pointing to a floppy, this floppy remember
the current directory as its "parent" (if you create more than one pointer
to a given floppy, you can choose which one will be the parent). You can
walk back to the parent directory by using "&lt;" as a subdirectory name
(which means that "&lt;" is not a valid diskname in your collection):
<p><tt>OLD DSKA.&lt;.FILENAME</tt>
<p>This looks for the file "filename" in the parent of the disk currently
in drive <tt>DSKA, </tt>i.e. a disk that contains a pointer file pointing
at the current disk.
<p>And of course, you can combine all these in fairly cryptic pathes like
this one:
<p><tt>DELETE "DSK@.DISKNAME.&lt;.&lt;.DIRECTORY.SUBDIR.FILENAME"</tt>
<p>Let's see; this will delete the file <tt>FILENAME</tt>, in the virtual
floppy pointed at by <tt>SUBDIR</tt>, which is a pointer file located on
a floppy pointed at by <tt>DIRECTORY</tt>, which itself is located on the
grand-parent of the floppy named <tt>DISKNAME</tt>. I'd be quite careful
before I start using such a complicated path though...
<h4>
<br>
Changing directories</h4>
To insert the floppy corresponding to a pointer file located in the current
drive you can use the subprogram CD:
<pre>CALL CD.7.DIRECTORY</pre>
This only works in Basic and Assembly. You need quote marks in Extended
Basic:
<pre>CALL CD".7.DIRECTORY"</pre>
Alternatively, you could use DELETE in the same way, in either language:
<pre>DELETE "CD.7.DIRECTORY"</pre>
Either will insert the floppy pointed at by <tt>DIRECTORY </tt>into
<tt>DSK7(</tt>and
<tt>n</tt>othing
will be deleted). The file
<tt>DIRECTORY
</tt>must be present in the virtual
floppy currently inserted in <tt>DSK7</tt>.
<p>Alternatively, you have the option of specifying the name of the floppy
to be inserted:
<pre>CALL CD.8..DISKNAME or

DELETE "CD.8..DISKNAME"</pre>
Note the double-dot syntax, it indicates that <tt>DISKNAME </tt>is a virtual
floppy, not a pointer file.
<p>Finally, you can make combinations:
<pre>CALL CD.B..DISKNAME.&lt;.DIRECTORY.SUBDIR</pre>
In the above example, &lt; indicates the parent directory of <tt>DISKNAME</tt>,
i.e. a virtual floppy that contains a pointer file pointing at <tt>DISKNAME</tt>.
On this parent disk should be another file called <tt>DIRECTORY </tt>pointing
at another disk. On that other disk should be a file called <tt>SUBDIR
</tt>pointing
at yet another disk, which is the one that will ultimately be inserted.
You don't have to make it so complicated though...
<h4>
<br>
Deleting directories</h4>
You should always use the official <tt>DELETE </tt>operation (opcode >07)
to delete a directory file (using the full DSKx drive name, not CD):
<pre>DELETE "DSKG.DIRFILE"</pre>
Don't worry, this will not delete the floppy pointed at, only the file
that points at it.
<p>Never attempt to delete pointer files "manually" with sector edition:
only the <tt>DELETE </tt>opcode knows how to maintain proper linking between
all directory files that point at the same disk. Beware of disk managers
that may try to do it in this waym rather than calling opcode >07.
<h4>
<br>
Creating directories</h4>
To create a new directory pointer, just create a new Int/Fix 1 or Int/Var
1 file, with the following syntax:
<pre>OPEN #1:"DSK5.FILENAME..DISKNAME", INTERNAL, FIXED 1, OUTPUT</pre>
Note the double-dot syntax: it tells IDEAL that you are not really trying
to create a regular IF1 file, but rather a pointer file that points to
the target floppy named <tt>DISKNAME</tt>. If you chose to make it a Fixed
file, IDEAL will automatically substitute <tt>DISKNAME </tt>for the filename
(which may cause an error if a file with this name already exists).
<p>It is not allowed to overwrite an existing directory, even to point
it at the very same disk. If the file you are creating already exists,
you will get a write protection error (code 1), even if the file was not
protected. To modify a pointer file, you must first delete it, then create
it anew.
<p>Opening the pointer file as <tt>OUTPUT </tt>will cause the disk it resides
on to become the parent directory of the target disk. If you open the file
as <tt>UPDATE </tt>(the default), and the target disk already has a parent,
it will keep it. Note that you can set an <a href="#user%20options">option</a>
while configuring IDEAL that forbids you to change the parent directory.
When this flag is set, a given disk can only have one Int/Fix 1 directory
file pointing at it: its parent. This forces you to arrange your disks
in a tree-wise manner, as on a PC, although no provision is made to avoid
circular references. You can define extra Int/Var pointer files pointing
at this disk, but only if automatic update has been disabled for Int/Var
files (see below).
<p>Finally, using <tt>SAVE </tt>instead of <tt>OPEN </tt>will also work
to create a pointer file, but only <tt>OPEN </tt>lets you specify file
options: if you use <tt>SAVE </tt>the default type is always Int/Fix 1,
and the parent directory will not be changed if it already exists.
<h4>
<br>
Dynamic directory update</h4>
Int/Fix 1 pointer files are automatically renamed when you change the name
of the floppy they point at. That is, provided there isn't already a file
with this name on the disk they reside on, in which case the file type
would be changed to Int/Var 1. Int/Var 1 pointer files are never renamed.
<p>If you remove the target floppy from your floppy collection, all pointer
files pointing at it will be deleted. If a pointer file is protected and
cannot be deleted, it is changed into a Int/Fix 2 file and unprotected.
This feature is mandatory for Int/Fix pointer files and optional for Int/Var
files: these may be automatically deleted or not, depending on an <a href="#user%20options">option</a>
flag that you set when configuring IDEAL.
<p>CAUTION: Dynamic update relies on the fact that a given pointer file
will always be at the same location on your hard drive. Therefore, do not
copy a pointer file from a disk to another: it could not be properly updated.
Instead, create another pointer on the second disk, using <tt>OPEN </tt>or
<tt>SAVE
</tt>as
described above. For the same reason, do not use a disk manager that rearranges
files on disk when making your safety backup: use a sector-copy program
instead. Always use <tt>DELETE </tt>to delete pointer files (rather than
poking sectors 0 and 1) and never, ever doctor the information you will
find at bytes >20-2D in the FDR of a pointer file.
<p>This becomes even more of a problem when a pointer file is located on
an encrypted floppy and you did not turn decryption on. This pointer file
won't be updated but, which is worse, it cannot even be read and prevents
IDEAL from walking the pointer chain any further. One way to avoid this
problem is to always turn encryption on before renaming/deleting disks
and/or pointer files. Another is not to place on an encrypted disk any
pointer file pointing to a non-encrypted disk .
<h2>
<br>
<a NAME="Encryption"></a>Encryption</h2>
IDEAL gives you the option to encrypt a floppy, or a file so that only
you can access it. Encryption is performed according to Blowfish, a very
secure algorithm that has never been cracked so far. The price to pay is
a slightly slower disk access.
<p>Any attempt to access encrypted files or floppies without enabling Blowfish
deciphering results in a file error. Using an incorrect password will return
gibberish and may even crash your program. Furthermore, if you write something
with an incorrect password, you'll never be able to read it again! So my
advise is: just after you enter your password, make an attempt to read
something that you know for sure was encoded with this password. If you
can't read it, you made a typo!
<h4>
Entering your password</h4>
Your password only needs to be entered once. It then remains active until
either you erase it or you turn the PE-box off. Caution: reseting the TI-99/4A
will not erase your password unless you set the appropriate
<a href="#user%20options">option</a>
while configuring IDEAL. Also, if you have a battery-backed SRAM on your
IDE card, turning the power off leaves the encryption key intact in memory.
(In such a case you should actively erase the key once you are done).
<p>To enter your password, type:
<pre>CALL IDE.BLOWON.PASSWORD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in Basic, or Assembly

CALL IDE".BLOWON.PASSWORD"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; in Extended Basic

DELETE "IDE.BLOWON.PASSWORD"&nbsp;&nbsp;&nbsp; in any language
</pre>
Any file operation will do, but <tt>DELETE </tt>is quite convenient because
it does not affect the file buffers in Basic. A <tt>CALL </tt>can also
be used, but the advantage of a file operation is that you can pass a string
variable: <tt>DELETE A$. </tt>Besides, the CALL syntax is different in
Extended Basic.
<p><tt>PASSWORD </tt>should be a string of upto 56 characters.
<p>The Blowfish routine will then create the encryption key from the number
Pi and your password, which will take about 3 seconds. From this point
on, Blowfish encryption is active. Any file or directory that was encrypted
will be automatically decrypted. Any new file (or virtual floppy) that
you create will be encrypted with the current password.
<p>If at any time you want to change passwords, just repeate the above
operation. Caution: make sure than any opened file has been closed before
you change password or erase your key. Otherwise, any data still in memory
cannot be saved back on disk.
<p>Note that, for proper security, your password should never be spelled
out in a Basic program as in the examples above (these assume interactive
keyboard entry). If you want to enable Blowfish encryption from a program,
use something like:
<pre>100 PRINT "ENTER YOUR PASSWORD"
110 INPUT PW$
120 DELETE "IDE.BLOWON."&amp;PW$
130 PW$=SEG$("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",1,LEN(PW$))</pre>
Line 130 serves to overwrite your password in the Basic string space, so
that a collegue cannot retrieve your password by peaking the VDP memory
while you went for a cup of coffee. It is not necessary if you reboot your
computer once you are done.
<h4>
Turning Blowfish on/off</h4>
You may turn encryption/decryption off without erasing your password by
calling
<pre>DELETE "IDE.BLOWOFF"&nbsp;&nbsp;&nbsp; or

CALL IDE.BLOWOFF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

</pre>
Alternatively, you can turn encryption off, but leave decryption on (i.e.
newly created files and floppies won't be encrypted, but previously encrypted
files will be accessed in an encrypted fashion):
<pre>DELETE "IDE.BLOWOUT"&nbsp;&nbsp;&nbsp; or

CALL IDE.BLOWOUT</pre>
You can turn full encryption back on with:
<pre>DELETE "IDE.BLOWON"&nbsp;&nbsp;&nbsp; or

CALL IDE.BLOWON</pre>
Again, make sure all opened files are closed before you turn encryption
off.
<p>Note that the password can also be passed with <tt>BLOWOUT </tt>and
<tt>BLOWOFF</tt>,
in the same way it is with <tt>BLOWON</tt>. However, when passing a password
with an Extended Basic <tt>CALL</tt>, you must use double quotes because
of a bug in the way Extended Basic calculates the size of unquated strings:
<tt>CALL
IDE".BLOWOUT.PASSWORD"</tt>
<h4>
<br>
Erasing the key</h4>
Your password remains in effect even if you reboot the TI-99/4A (as long
as you don't turn off the PE-Box). This was done so you can leave encryption
on while changing cartridges, etc. If that's not what you want, you have
the <a href="#user%20options">option</a> to configure the system so that
it automatically wipes off the encryption key upon power-up.
<p>For proper security, it is critical that you remove the key from memory
once you are done with accessing encrypted data. In addition, IDEAL will
also wipe out any unciphered data that may remain in the opened file buffers.
This is especially critical if you are using a battery-backed SRAM that
will retain buffer contents and encryption key even after power was turned
off. To erase the current key, just perform any file operation on <tt>IDE.BLOWAWAY</tt>:
<pre>DELETE "IDE.BLOWAWAY"&nbsp;&nbsp;&nbsp; or

CALL IDE.BLOWAWAY</pre>

<h4>
<br>
Encrypting data</h4>
You can also access the encryption engine directly so as to encode/decode
data yourself. This is done via two pseudofiles, <tt>IDE.BLOWPLAIN</tt>
and <tt>IDE.BLOWCIPHER</tt>. As you might have guessed, <tt>BLOWPLAIN
</tt>is
used to pass/retrieve plain text, whereas <tt>BLOWCIPHER </tt>accesses
the chiphertext.
<p><tt>IDE.BLOWPLAIN</tt> can be a file of any type you want, as long as
the maximum record length is 248 or less. Larger records result in a 256-byte
ciphered string, which is illegal in Basic (It's ok if you work from assembly,
but be aware that a 256-byte string has a size byte of >00). <tt>IDE.BLOWCIPHER</tt>
should be an <tt>INTERNAL, FIXED 249</tt> file. Smaller record lengths
may be ok, as long as they can accomodate all data passed to <tt>BLOWPLAIN,
</tt>rounded
up to the next multiple of 8, plus 1 byte for string size.
<p>The password should be specified with <tt>IDE.BLOWOFF.<i>password</i></tt>
as explained above. That is, assuming that you don't want to turn on encryption
for your hard-drive. Otherwise, you may just as well use <tt>BLOWON </tt>to
set the password.
<p>To encode data, write them to <tt>BLOWPLAIN </tt>and retrieve the coded
version from <tt>BLOWCIPHER</tt>. This will be a single string, upto 248
characters in length. NB: It is critical that BOTH files are opened before
you write anything to one of them (otherwise you'll get an end-of-file
error).
<pre>DELETE "IDE.BLOWOFF.THIS-IS-MY-PASSWORD"
RUN</pre>

<pre>100 OPEN #1:"IDE.BLOWPLAIN",INTERNAL,VARIABLE 80
110 OPEN #2:"IDE.BLOWCIPHER",INTERNAL,VARIABLE 249
120 PRINT #1:"This is a test",1234,Y,B$
130 INPUT #2:CODED$</pre>
To decode previously coded data, perform the opposite operation: write
the ciphered string to <tt>BLOWCIPHER </tt>and read back the plain data
from <tt>BLOWPLAIN</tt>.
<pre>140 PRINT #2:CODED$
150 INPUT #1:A$,X,Y,B$</pre>
Note that, because Blowfish always operates on 8-byte values, it may have
padded the end of the record with spaces. You shouldn't notice it in Basic
(that trims trailing spaces), but be aware of it when working from assembly.
<p>If you have battery-backed SRAMs, always close <tt>BLOWPLAIN </tt>when
done: this will wipe out any plain text that may remain in the card buffers.
<h4>
What's encrypted?</h4>
On a crypted disk, all sectors are encrypted except for sectors 0 and 1.
Such a disk is created if encryption is on when you create it. A flag is
sector 0 indicates that the disk is encrypted. Individual files cannot
be super-encrypted on a disk that's already encrypted.
<p>If you encrypt a file on a non-crypted disk, a flag bit is set in its
FDRs to indicates that the file is encrypted (the FDR is a sector that
contains all the file information). The FDR itself is not encrypted, only
the sectors that make up the file. These sectors are completely encrypted,
irrespective of whether the data occupies the full sector or if there are
"junk" bytes in the end.
<p>Since they consists of only a FDR, directory pointers are never encrypted
(unless they reside on an encrypted disk, of course).
<h2>
<br>
<br>
<a NAME="Catalog"></a>Extended catalog access</h2>
As mentionned above, you can obtain the catalog of a virtual floppy in
the same way as with the TI floppy disk controller:
<p><tt>OPEN #1:"DSK9.",INTERNAL, FIXED 38, INPUT</tt>
<p>Record 0 returns disk informations, the following records return information
on each file, in alphabetical order. The first empty record returns an
empty string and 0 values. Attempts to access records beyond this one result
in an end-of-file error.
<h4>
Extra information</h4>
IDEAL provides you with a more sophisticated catalog access. To use it,
open the file as either:
<p><tt>OPEN #1:"DSK9.",INTERNAL, VARIABLE 128</tt>
<p>or, from assembly language
<p><tt>OPEN #1:"DSK9.",INTERNAL, VARIABLE 120</tt>
<p>The second form returns all numbers in the form of integers, instead
of floating point numbers. These are more convenient for assembly language
programs. Strings are still prefaced with size bytes, though.
<p>Technical note: Actually, you can open the catalog as a file of any
type. For instance, if you want to access it as a relative file, Basic
will force you to open it as a <tt>FIXED </tt>file. Any file type is accepted,
only the record length matters: 38 opens the regular type catalog, 39 to
120 opens the extended catalog and passes numbers as integers, 121 to 128
passes them as floating point numbers. Finally, a record size of 129 or
higher is used for sector-wise access (<a href="#Sector%20access">see below</a>).
If you don't specify any record size, it defaults to 128.
<p>When opened as "extended", the catalog returns many additional variables
(although you don't have to input all of them, if you don't need them all).
<p>Record 0 returns disk information:
<p><tt>INPUT #1, REC 0:NAME$,FILES,SECTORS,FREE,TIMEC,DATEC,TIMEM,DATEM,FLAGS,RES</tt>
<li>
<tt>NAME$</tt>: A 10-character string containing the disk name</li>

<li>
<tt>FILES</tt>: Number of files in the catalog</li>

<li>
<tt>SECTORS</tt>: Number of sectors on disk</li>

<li>
<tt>FREE</tt>: Number of free sectors on disk.</li>

<li>
<tt>TIMEC</tt>: Time when the disk was created</li>

<li>
<tt>DATEC</tt>: Date when the disk was created (0 = not specified)</li>

<li>
<tt>TIMEM</tt>: Time of the last modification to the catalog</li>

<li>
<tt>DATEM</tt>: Date of the last modification to the catalog (0 = not specified)</li>

<li>
<tt>FLAGS</tt>: 1 = Disk is protected, 2 = Disk is encrypted, 4 = 720 sectors,
8 = 1440 sectors, 16 = Archive bit (reset when modified).</li>

<li>
<tt>RES</tt>: Reserved.</li>

<p><br>The next records return information on the files, in the order they
appear in the catalog (which should be alphabetical):
<p><tt>INPUT #1:NAME$,TYPE,SECTORS,RECLEN,TIMEC,DATEC,TIMEM,DATEM,FLAGS,FDR</tt>
<li>
<tt>NAME$</tt>: A 10-character string containing the file name</li>

<li>
<tt>TYPE</tt>: File type: 1=Dis/Fix 2=Dis/Var 3=Int/Fix 4=Int/Var 5=program.
Negative if protected.</li>

<li>
<tt>SECTORS</tt>: Number of sectors in file (including the FDR)</li>

<li>
<tt>RECLEN</tt>: Record length. For program files: # of bytes used in last
sector.</li>

<li>
<tt>TIMEC</tt>: Time when the file was created</li>

<li>
<tt>DATEC</tt>: Date when the file was created (0 = not specified)</li>

<li>
<tt>TIMEM</tt>: Time of the last modification to the file</li>

<li>
<tt>DATEM</tt>: Date of the last modification to the file (0 = not specified)</li>

<li>
<tt>FLAGS</tt>: 1 = File is protected, 2 = File is encrypted, 4 = File
is fractured (i.e. uses non-adjacent sectors), 8 = Directory, 16 = Archive
bit (reset when modified).</li>

<li>
<tt>FDR</tt>: Sector # of the file descriptor (the FDR, i.e. the sector
containing all the info about the file).</li>

<p><br>The time stamps have the following form:
<p><tt>DATE = (YEAR*512) + (MONTH * 32) + DAYOFMONTH</tt>
<br><tt>TIME = (HOURS * 2048) + (MINUTES *32 ) + (SECONDS / 2)</tt>
<p>Where <tt>YEAR </tt>= 0 to 99, <tt>MONTH </tt>= 1 to 12, <tt>DAYOFMONTH
</tt>=
1 to 31 (for any month), <tt>HOURS </tt>= 0 to 23, <tt>MINUTES
</tt>= 0
to 59, and <tt>SECONDS </tt>= 0 to 58.
<p>Note that note that, in order to pack the time in a single word, it
is specified in 2-second increments.
<p>A <tt>TIMEM </tt>value of 65535 is understood as a command for IDEAL
not to update the time stamps for this file/floppy. You also have the <a href="#user%20options">option</a>
to globally disable stamping of all floppies and/or all files when configuring
your system.
<h4>
<br>
Writing to the catalog</h4>
You can perform a number of disk operations without a disk manager, by
just writing to the appropriate record. Any field that you want to leave
unchanged should contain zero.
<p><tt>NAME$</tt>: you can change the name of a file but you cannot rename
the disk (for this use IDE.FLOPPIES, see below). Caution, the name should
be unique: if another file with the same name already exist a "file error"
is issued. Leave this string empty to keep the same name.
<p><tt>SECTORS</tt>: You can decrease or increase the number of sectors
on disk. However, you should not exceed the number of sectors indicated
in the <tt>FLAG </tt>word (this is the maximum space reserved on the hard
disk for this floppy).
<p><tt>DATEx</tt> and <tt>TIMEx</tt>: You can always change a date and
time, even that of creation. If you set the date of last modification to
65535 (>FFFF), neither the date nor the time will be updated when the file
is modified. If you set a value a zero, the current value, as read from
the clock, will be used instead. This works for both the disk and the files.
<p><tt>TYPE </tt>and <tt>RECLEN</tt>: You can change the file type and
record length, but be carefull: this may well render the file unusable.
Negative <tt>TYPE </tt>values result in protecting the file, positive values
do not affect the protection status unless the value is out of range (e.g.
<tt>TYPE
</tt>=
99) although it is probably more convenient to use the
<tt>FLAG
</tt>bits
to change the file protection. Here are some examples of modifications:
<li>
Program ---> DF128 (or DF64 or DF32, etc). Very convenient to patch a program
file from Basic...</li>

<li>
Any --> Program. A program file can contain any type of data. Note that
<tt>RECLEN
</tt>will
now correspond to the end-of-file offset (last byte in last sector).</li>

<li>
DF16 --> DF32 Expands a fixed file by merging its records. Safe as long
as it does not result in a record not fitting in the sector.</li>

<li>
DF16 -->DF48 won't work: there are sixteen DF16 records per sector, but
five DF48 records. These can only accomodate fifteen DF16 records!</li>

<li>
DF80 --> DF40 It is generally ok to split fixed records in several smaller
records, provided this does not result in using the unused bytes at the
end of the sector.</li>

<li>
DF200 -->DF50 Here is a case when it's not ok: there are 56 unused bytes
per sector with DF200 files. If you make it DF50, there will be five DF50
records per sector, the last one containing only garbage.</li>

<li>
DV80 --> DV130 It's always ok to extend the maximum record size, since
no record should be greater than the current size anyhow.</li>

<li>
DV80 --> DV60 This may result in loss of data, unless you know for sure
that no record on this file is greater than 60.</li>

<p><br><tt>FLAGS</tt>: You can modify the following flags: Disk protected,
File protected, Archive bit for either disk or file.
<h4>
Archive bit</h4>
Each time a file is modified and its FDR (File Descriptor Record, a sector
that contains the file name and all kind of info about it) is written back
to the disk, a special "archive" bit is reset in the FDR. This allows automatic
backup programs to monitor which file has changed. All such a program needs
to do is to set the archive bit in the FDR of any file it backs up. Next
time you do a backup, the program will only archive files whose "archive"
bit was reset. Another possibility is to compare the "last modification
date" of the file with that of the archive, and back up the file if it's
greater.
<p>The disk iteself also contains an archive bit which is modified only
if the disk catalog is modified. Which means that if you write to a file,
the directory archive bit won't necessarily be changed (it may if you changed
the file size, which modifies the sector bitmap).
<h3>
<br>
<a NAME="Sector access"></a>Sector access</h3>
Provision is made for you to access a virtual floppy in a sector-wise manner.
But be carefull: this is an extremely powerfull feature and you can hopelessly
mess up a virtual floppy if you don't know what you're doing. In fact,
you have the <a href="#user%20options">option</a> to turn this feature
off while configuring IDEAL, so that no malicious program will be able
to damage your virtual floppies.
<p>Note: From assembly language, it is more convenient to use subprogram
>10 to perform sector access.
<p>To access a floppy sector-wise, open its catalog as an <tt>INTERNAL,
FIXED 129</tt> file. Each sector maps to two records in the file, in numeric
order. Each record contains a single 128-byte string that corresponds to
half a sector.
<p><tt>100 OPEN #1: "DSKV.",INTERNAL,FIXED 129,RELATIVE</tt>
<br><tt>110 INPUT #1, REC 2: SEC1A$</tt>
<br><tt>120 INPUT #1, REC 3: SEC1B$</tt>
<p>Sector numbering starts from zero, so records 0 and 1 correspond to
sector 0, records 2 and 3 to sector 1, etc. The above program reads the
content of sector 1 into the strings <tt>SEC1A$</tt> that contains the
first 128 bytes in the sector, and <tt>SEC1B$</tt> that contains the last
128 bytes.
<p>You can modify these strings at will, then write them back at the same,
or another location. If the string you write is smaller than 128 characters,
only that many bytes are modified and the end of the half-sector remains
unchanged.
<p>The file can also be opened as a <tt>SEQUENTIAL </tt>file, but don't
forget that each read/write operation moves to the next record. So if you
<tt>PRINT
</tt>back
a string just after you <tt>INPUT </tt>it, you will actually write it to
the next record!
<p><u>Technical notes:</u>
<li>
You may have noticed that all bytes at the end of sector 0 in each vitual
floppy (bytes 238-255) read as 255, no matter what you write there. IDEAL
uses these bytes to store the information needed to manage the floppy collection:
links to the previous and next floppy, to the parent directory, flag bits,
etc. Altering these bytes may result in hopelessly messing up your floppy
collection. For this reason, neither subprogram >10 nor the above sector-wise
access technique let you modify them.</li>

<li>
Also note that if you alter the disk name in sector 0 your virtual floppy
collection will be rearranged, which could take a few seconds. If you have
protected your collection, the write operation will fail with a "write-protected"
error.</li>

<h2>
<br>
<a NAME="Collection"></a>Editing your virtual floppy collection</h2>
Your virtual floppy collection can be accessed via a pseudo-file named:
<tt>IDE.FLOPPIES</tt>.
This file must be opened as <tt>INTERNAL, FIXED 128 </tt>from Basic and
as <tt>INTERNAL, FIXED 120</tt> from assembly. The difference is that numbers
are passed as floating point values in Basic and as integers in assembly.
Strings are passed with a leading size byte in both cases.
<p>You can open the file as either <tt>RELATIVE </tt>or <tt>SEQUENTIAL
</tt>mode.
Relative files are easier to work with, but they are limited to 32767 records
in Basic and to >FFFE records in assembly, so if you have more floppies
you won't be able to access all of them. A sequential file is more cumbersome,
but has no limitations on the number of floppies. Note that <tt>IDE.FLOPPIES</tt>
has a special mechanism to jump to any record via record 0 (see <a href="#Floppies%20rec%200">below</a>),
that works with both sequential and relative files.
<p><tt>100 OPEN #1: "IDE.FLOPPIES",INTERNAL,FIXED 128, RELATIVE</tt>
<p>Note: You can set a security <a href="#user%20options">option</a> bit
while configuring your system, so that the collection cannot be modified
by writing to <tt>IDE.FLOPPIES</tt>. This will prevent malicious programs
from messing with your collection. While this bit is set, you can read
from <tt>IDE.FLOPPIES</tt>, but not write to it. Also you cannot use a
disk manager to rename a virtual floppy, nor to create a new one. Trying
to do so will result in an I/O error #5.
<h4>
<br>
Retrieving floppy disk parameters</h4>
Record 0 has a special meaning so we'll set it aside for the moment being.
Each of the next records accesses one of your virtual floppies, arranged
in alphabetical order. Note that, because Basic file operations limit the
number of records to 32767, you won't be able to access more virtual floppies
than this, unless you use a sequential file (from assembly, you can reach
upto 65534 records).
<p><tt>INPUT #1, REC X: NAME$,SECTORS,TIMEC,DATEC,TIMEM,DATEM,FLAGS,RES</tt>
<li>
<tt>NAME$</tt>: A 10-character string containing the disk name</li>

<li>
<tt>SECTORS</tt>: Apparent number of sectors in the disk, as stated on
sector 0. The actual amount of memory reserved for the virtual floppy depends
on flag bits 4 and 8: 360, 720 or 1440 sectors. The <tt>SECTORS </tt>value
should be small enough to fit in there. A value of 0 defaults to this size.</li>

<li>
<tt>DATEC</tt>: Date when the disk was created (-1 = not used, 0=now)</li>

<li>
<tt>TIMEC</tt>: Time when the disk was created (-1 = not used, 0=now)</li>

<li>
<tt>DATEM</tt>: Date of the last modification to the catalog (-1 = not
used, 0=now)</li>

<li>
<tt>TIMEM</tt>: Time of the last modification to the catalog (-1 = not
used, 0=now)</li>

<li>
<tt>FLAGS</tt>: 1 = Protect disk, 2 = Encrypt disk, 4 = 720 sectors, 8
= 1440 sectors, 16 = Archive bit (reset when modified).</li>

<li>
<tt>RES</tt>: Reserved.</li>

<p><br><tt>INPUT </tt>automatically moves to the next record each time
it's called so you can easily travel a sequential file, or a relative file
without a <tt>REC </tt>clause, by just repetedly reading its records.
<h4>
<br>
Modifying a floppy</h4>
You can modify any of these parameters by writing back to the same record.
The <tt>PRINT </tt>instruction always writes to the last record that was
read (or searched for) and does not move to the next record. This was done
so you can read records until you find the one you want and then modify
it. To write to the next record, you must first <tt>INPUT </tt>it, then
write to it. Of course, if you are using a relative file with a <tt>REC</tt>
clause, the specified record is accessed.
<p>The record structure is the same as described above. Any parameter that
you omit or leave as 0 remains unchanged. To keep the same name, you can
pass it as an empty string.
<p><tt>PRINT #1, REC 12: "",356</tt>
<p>This changes the apparent disk size (as it appears on its catalog, on
sector 0) to 356 sectors.
<p>The one thing that you cannot change is the physical size of the floppy
as determined by the flag bits, i.e. the amount of space it takes on the
hard disk. If you really want to do this, you must delete the floppy and
create another with the proper size.
<h4>
<br>
<a NAME="Floppies rec 0"></a>Locating a floppy</h4>
Rather than walking your floppy collection record by record to locate a
given floppy, you can use record 0 to locate it. Just write the desired
floppy name to record 0 and the next record that you access (to read or
write) will be that of the floppy.
<p><tt>PRINT #1, REC 0: "MYDISK"</tt>
<p>If the name does not exist, a "file error" is issued.
<p>Searching for an empty string jumps to the end of the file, so you can
add new floppies to your collection.
<p>You can also read back the record number corresponding to the searched
floppy, from record 0. Be aware that doing so rewinds the file, so the
next record accessed will be record 1.
<p><tt>INPUT #1, REC 0: A$,R</tt>
<p>or, for sequential files
<p><tt>RESTORE #1</tt>
<br><tt>INPUT #1: A$,R</tt>
<p>A$ will contain the string you passed with the <tt>PRINT </tt>statement
above (if any). R contains the record number that corresponds to this floppy,
or 0 if the floppy wasn't found.
<p>N.B. None of this can be done with the trash files.
<h4>
<br>
Creating a new floppy</h4>
To create a new floppy, move to the end of the file by passing an empty
string to record 0 or by opening the file in <tt>APPEND </tt>mode. Then
simply write a record with the required parameters: name, size, etc. Actually,
only the name is required: all other parameters have default values (360,-1,-1,-1,-1,0,0).
But the name must be unique: if another floppy with the same name already
exists, nothing is created and a file error is issued.
<p>CAUTION: every time you create, delete or rename a floppy, your collection
is rearranged in alphabetical order. Thus, you should never assume that
a given record will access the same floppy after an addition/deletion than
it did previously. In addition, as your collection grows, you may notice
a delay of a few seconds, and a lot of disk activity while the collection
is rearranged.
<h4>
<br>
Deleting a floppy</h4>
To remove a floppy from your collection, you can use opcode >08 (scratch
record) from assembly, or just overwrite its record with an empty name
string AND a size of -1. Removed floppies are placed in a trash file (there
are three of them, one per floppy size) so the space they occupied can
be reclaimed next time you create a new floppy. Until this happens, you
have the possibility to recover deleted floppies from the trash. You also
have the <a href="#user%20options">option</a> to configure IDEAL so that
it only recycles the trashed floppies once your hard drive is full.
<h4>
<br>
Recovering a deleted floppy</h4>
A floppy that was erased by mistake can be recovered from the trash by
opening <tt>IDE.TRASHn</tt> where n is a number from "1" to "3" and is
used to access the trash files that respectively contains the 360-, 720-
and 1440-sector floppies. The file should be opened in update mode, as
an Int/Fix file with a record size of 11 or more. It can be either sequential
or relative.
<p>To recover a floppy from the trash, you must first locate it. The most
recently deleted floppy is in record 0, the oldest one at the end of the
file: this is the one that will be recycled next. Each record consists
in only one string of at most 10 characters, which contains the name of
the deleted floppy.
<p>Once you found the record containing your floppy, just write a new name
(or the same one) to its record. This will automatically return the floppy
in your collection, provided the disk name does not already exist in the
collection, in which case a file error would be issued.
<pre>90 REM Recover a 360-sector floppy named HERE-IT-IS
100 OPEN #1:"IDE.TRASH1", INTERNAL, FIXED 80, UPDATE, RELATIVE&nbsp;
110 I=-1
120 I=I+1
130 INPUT #1,REC I:NAME$
140 IF NAME$&lt;>"HERE-IT-IS" THEN 120
150 REM we found it in record I. Let's recover it (with same name)
160 PRINT #1,REC I:NAME$
170 REM we could use ON ERROR in case the name already exists, to pick a different name
180 CLOSE #1</pre>
You can also open the file as sequential: every read operation moves forward
to the next record. A write operation accesses the record that was read
last (or record 0 if the file was just open).
<pre>90 REM Recover a 720-sector floppy named THAT-ONE
100 OPEN #1:"IDE.TRASH2", INTERNAL, FIXED 22, UPDATE, SEQUENTIAL
110 RESTORE #1
120 INPUT #1:NAME$
130 IF NAME$&lt;>"THAT-ONE" THEN 120
130 REM we found it. Let's recover it with a different name.
140 PRINT #1:"NEWNAME"
150 CLOSE #1</pre>

<h2>
<br>
<a NAME="clock"></a>Clock access</h2>
You can access the real-time clock onboard the IDE card by opening a pseudo-file
called CLOCK (by default, but you can change this name while configuring
your system). It should be opened as internal, fixed 128 in relative mode.
You can then access the various clock functions through specific records.
<pre>100 OPEN #1:"CLOCK", INTERNAL, FIXED 128, RELATIVE</pre>
Most variables can be modified by just writing the new values to the appropriate
record. Note that you must write all elements in a record, even if you
leave some unchanged. Illegal values are ignored, so it is a convenient
way to leave an element unchanged (alternatively, read it first and write
back what you read).
<p>There is no need to close the file when done, but it won't hurt to do
it:
<pre>500 CLOSE #1</pre>

<h4>
Record 0: Date</h4>

<pre>110 INPUT #1,REC 0:WEEKDAY,DAY,MONTH,YEAR1,YEAR2</pre>

<li>
<tt>WEEKDAY </tt>is the day-of-the-week. Sunday is 1, Monday is 2, etc.</li>

<li>
<tt>DAY </tt>is the day-of-the-month</li>

<li>
<tt>MONTH </tt>is the month</li>

<li>
<tt>YEAR1 </tt>contains the first two digits of the year (e.g. 19 or 20).</li>

<li>
<tt>YEAR2 </tt>contains the last two digits of the year. For a 4-digit
date calculate <tt>(100*YEAR1)+YEAR2</tt>.</li>

<h4>
Record 1: Time</h4>

<pre>120 INPUT #1, REC 1: HOURS,MINUTES,SECONDS,SETTINGS,CALIBRATION</pre>

<li>
<tt>HOURS </tt>contains the hour. In 24-hour mode, valid values are 0 (midnight)
to 23 (11 pm). In am/pm mode, valid values are 1 to 12 (am) and 129 to
140 (pm). As you can see, pm hours are marked by adding 128 to the hour.
When you set the time, make sure that the convention you are using is the
one specified in <tt>SETTINGS</tt>, otherwise you may end up with crazy
values (e.g. 17 am).</li>

<li>
<tt>MINUTES </tt>Valid values are 0 to 59.</li>

<li>
<tt>SECONDS </tt>Valid values are 0 to 59.</li>

<li>
<tt>SETTINGS </tt>are the clock settings. These bits vary according to
the clock chip used:</li>

<ul>
<ul>
<li>
1=daylight savings mode enabled: the clock automatically gains an hour
at 2:00 am the first Sunday in April and looses it at 2:00 am the last
Sunday in October. Only for RTC65271, with other clock chips you just change
the time yourself.</li>

<li>
2=clock is in 24-hour mode.Only for RTC65271 and bq4847 (the bq4842 and
bq4852 are always in 24 hours mode). This bit does not affect the way time
is passed to/from the <tt>CLOCK </tt>DSR.</li>

<li>
4=stop the clock. For use on clock chips with non-removable batteries:
bq4847, bq4842, and bq4852. Set this bit before putting your card into
storage, to spare the battery. When you install your card in the PE-box
again, just reboot your console and the power-up routine will reset this
bit and restart the clock.</li>

<li>
8=sign bit for calibration is positive. For bq4842 and bq4852 only.</li>
</ul>
</ul>

<li>
<tt>CALIBRATION </tt>For use with bq4842 and bq4852 only. Positive values
slow the clock by increments of 10.7 seconds a month, negative values (sign
bit = 0 in <tt>SETTINGS</tt>) slow the clock by increments of 5.35 seconds
a month.</li>

<h4>
Record 2: Alarm</h4>
You can set one alarm that will occur every day at the same time. Optionally,
you can make it an hourly alarm or even an alarm that occurs every minute.
This is done by placing a "don't care" value in the appropriate alarm register.
To disable alarms, set a value of 60 for the seconds.
<pre>130 INPUT #1,REC 2:HOUR,MINUTE,SECOND,INTF,ACTION,VECT,REC,SCRAD,DAY</pre>

<li>
<tt>HOUR </tt>is the hour at which the alarm must ring. The format is the
same as for <tt>HOURS </tt>in record 1, except that values 192 to 215 are
also legal: they mean that the alarm should occur whatever hour it is (i.e.
bits >C0 are set).</li>

<li>
<tt>MINUTE</tt> Legal values are 0 to 59. Values from 192 to 251 disregard
the minutes for alarm purposes.</li>

<li>
<tt>SECOND </tt>Legal values are 0 to 59. Values from 192 to 251 ignore
the seconds. To disable alarms completely just enter 60.</li>

<li>
<tt>INTF </tt>adds up the interrupt flags: 16=alarm interrupt enabled,
8=an interrupt occured, 4=it was a periodic interrupt, 2=it was an alarm,
1=there was an update (RTC65271) or a watchdog timeout (bq4842, bq4852).
Only flag 16 can be written to, the others are automatically reset when
accessing record 2.</li>

<li>
<tt>ACTION </tt>indicates the action to take when a periodic interrupt
occurs. 0=do nothing. 128=enable drive sleeping, 1=blink screen, 2=beep,
4=display record, 8=call program.</li>

<li>
<tt>VECT is </tt>the address of a BLWP vector (workspace and address) where
to branch at if the call program option is enabled.</li>

<li>
<tt>REC </tt>is the record number of the string you want to display (see
record numbers below, only the first string is displayed).</li>

<li>
<tt>SCRAD </tt>is the screen address where to display the time or date.
Add >80 to add the Basic bias to every character, >40 to prevent this from
happening. If you add neither, the charater at address <tt>SCRAD </tt>will
be read and, if it is >80 or greater the Basic bias will be added to the
string.</li>

<li>
<tt>DAY</tt> is the day-of-the-month at which the alarm should ring. The
format is 1 through 31, add 192 to make it a daily alarm. This word is
not available with the RTC65271, which has no such register.</li>

<p><br>The clock can trigger TI-99/4A interrupts, either at defined intervals
or when the alarm goes off. Of course, interrupts will only be effective
if the program currently running has enabled them (with a LIMI 2 instruction).
Basic and Extended Basic do so, but some assembly programs may not.
<p>Reading INTF lets you know what happened, writing to it lets you specify
which kind of interrupt is allowed.
<p>Four actions can be taken when an alarm occurs: the screen can blink
3 times (this uses the copy of VDP register 1 stored at >83D4), a beep
can sound 3 times, the time or the date can be displayed on screen in one
of the formats specified in records 4 to 11, or a call can be made to a
program of yours. Any combination of these actions is allowed.
<p>To display the time or the date, select the format desired from those
described for the records below and use this record number for the <tt>REC
</tt>value.
For instance, use 8 to display the time as "6:55 pm". Tip: using records
100-227 accesses the RTC65271 clock RAM, which allows you to display a
preset message on screen. Just place the message (with a leading size byte)
in the appropriate clock page by writing it to the corresponding record
and puts this record number in <tt>REC</tt>. Be carefull not to overwrite
the bootstrap program in the first clock pages.
<p>If you call a program it MUST be in memory when the interrupt occurs,
otherwise the system will crash mercilessly. The program is entered with
a BLWP after then interrupt service routine has returned. Once done, you
can return to the interrupted program with a simple RTWP.
<p>In addition, IDEAL uses alarms to put a drive to sleep after a given
period of inactivity. The sleep algorithm triggers an interrupt every minute
and counts them until the specified number of minutes has elapsed. Any
disk operation resets the counter. If you are using the alarm for any other
purpose, you should clear bit 128 in the <tt>ACTION </tt>word so as not
to mess up the count (unless you happen to have set an alarm every minute).
<p>Finally, turning the console off, then back on disables all interrupts.
This was done so that the computer won't lock up if an interrupt fires
when IDEAL is not loaded to acknowledge it. With the RTC65271 clock, you
have the option of opening DIP-switch #2 so that interrupts are NOT disabled
upon power-up. Use at your own risks...
<h4>
Record 3: Periodic events</h4>
You can cause the clock to repetedly trigger an event at defined intervals
that range from 122 microseconds to half a second.
<pre>140 INPUT #1,REC 3:PERIOD,INTS,ACTION,DATA</pre>

<li>
<tt>PERIOD </tt>is the delay between two interrupts, which is also the
frequency of the square-wave output. See the IDE page for <a href="ide.htm#square%20wave">legal
values</a>.</li>

<li>
<tt>INTS </tt>contains the control flags: 1=square-wave enabled, 8=periodic
interrupt enabled, 9=both.</li>

<li>
<tt>ACTION </tt>indicates the action to take when a periodic interrupt
occurs. 0=do nothing. 128=enable drive sleeping, 1=blink screen, 2=beep,
4=call program.</li>

<li>
<tt>DATA </tt>the address of a BLWP vector (workspace and address) where
to branch at if the call program option is enabled.</li>

<p><br>The same actions as for an alarm interrupt can be specified. However,
since the maximum interval is half a second, there is no point in blinking
the screen, nor beeping when such an interrupt occurs. Most likely you
will only want to call a program at this point. Just be aware that answering
an interrupt takes time. So if you set interrupts at too short a period,
the computer will end up spending most of its time servicing interrupts!
<h4>
Record 4 to 7: Formatted date</h4>
The next four records contains the date formatted in different ways into
text strings. These records cannot be written to.
<pre>150 INPUT #1,REC 4:DATE$,DAY$</pre>

<li>
<tt>DATE$</tt> is in the form "12/25/99"</li>

<li>
<tt>DAY$</tt> is in the form "Mon"</li>

<pre>160 INPUT #1,REC 5:DATE$,DAY$</pre>

<li>
<tt>DATE$</tt> is in the form "Sep 4 96"</li>

<li>
<tt>DAY$</tt> is in the form "Wed"</li>

<pre>170 INPUT #1,REC 6:DATE$,DAY$</pre>

<li>
<tt>DATE$</tt> is in the form "October 1, 2000"</li>

<li>
<tt>DAY$</tt> is in the form "Friday"</li>

<pre>180 INPUT #1,REC 7:DATE$,YEAR$,DAY$</pre>

<li>
<tt>DATE$</tt> is in the form "January, the 3rd"</li>

<li>
<tt>YEAR$</tt> is in the form "1976"</li>

<li>
<tt>DAY$</tt> is in the form "Saturday"</li>

<h4>
Record 8 to 11: Formatted time</h4>
The next four records contains the time formatted in different ways into
text strings. These records cannot be written to.
<pre>190 INPUT #1,REC 8:TIME$</pre>

<li>
<tt>TIME$</tt> is in the form "9:55 pm"</li>

<pre>200 INPUT #1,REC 9:TIME$</pre>

<li>
<tt>TIME$</tt> is in the form "11:23:06 am"</li>

<pre>210 INPUT #1,REC 10:TIME$</pre>

<li>
<tt>TIME$</tt> is in the form "13:45"</li>

<pre>220 INPUT #1,REC 11:TIME$</pre>

<li>
<tt>TIME$</tt> is in the form "17:25:00"</li>

<h4>
<br>
Record 12: RAM registers</h4>
Most clock chips contain extra registers that are available to the user
as battery-backed RAM. PC computers save the so-called "CMOS setup" in
these. According to the chip, there may be upto 128 registers (the RTC-65271
has 64, the bq4847 has only one), but in all cases registers 0 to 13 map
to clock functions.
<p>You can get a dump of all clock registers by accessing record 12:
<pre>230 INPUT #1,REC 12:R0TO63$,R64TO127$</pre>

<li>
<tt>R0TO63$</tt> is a 64-byte string that contains registers 0 to 63, one
character per register. See the IDE page for the meaning of registers 0-13.
Note that, if the first character (the seconds) is 59, the content of the
clock registers may not be accurate because the clock may have moved to
the next minute/hour/day/etc just after the seconds register was read.</li>

<li>
<tt>R64TO127$</tt> is a 64-byte string that contains registers 64 to 127,
if they exist. If your clock chip has only 64 registers or less, chances
are that this string will have accessed the same registers as <tt>R0TO63$
</tt>(and
thus will be identical unless the seconds were incremented).</li>

<p><br>You can write to this record to place new values in the clock RAM
registers. Registers 0 to 13 are reserved for clock registers, so the first
14 characters of <tt>R0TO63$</tt> will be ignored. Register 14 of the RTC65271
is used by IDEAL to store the first two digits of the year (20), so make
sure you leave this 15th character intact. By contrast <tt>R64TO127$</tt>
is copied entirely, which may result in modifying the clock registers if
you have only 64 registers. For this reason, you must always pass two strings
when writing to record 12: the second string should be empty unless you
are sure you have a clock chip with more than 64 registers.
<pre>240 A$=SEG$(R0TO63$,1,15)&amp;CHR(67)&amp;SEG$(R0TO63$,17,64)

250 PRINT #1, REC 12: A$,""</pre>
This example puts the number 67 into register 15 (the 16th character in
the string) and leaves the other registers unchanged.
<p>The bq4847 has only one extra register, which must always be zero. Thus
<tt>R0TO63$</tt>
is read as a 15-byte string and cannot be written to. Similarly, the bq4842
and bq4852 have no extra registers, so this string is 16-byte long and
cannot be modified either. In both cases, the second string <tt>R64TO127$</tt>
is not used.
<h4>
Record 13: Watchdog timer</h4>
This only works with the bq4842 and bq4852 clock chips (the bq4847 has
a hardware-only watchdog, the RTC-65271 has none).
<pre>140 PRINT #1,REC 13:PERIOD,UNITS,ACTION,DATA</pre>

<li>
<tt>PERIOD </tt>is the delay before the watchdog timer triggers an interrupt.
Legal range: 1 to 31. Zero disables the watchdog. 32 means "use the same
value as previously and ignore next records".</li>

<li>
<tt>UNITS </tt>specifies the units used for <tt>PERIOD</tt>: 0=1/16 sec,
1=1/4 sec, 2=1 sec, 3=4 sec</li>

<li>
<tt>ACTION </tt>indicates the action to take when a periodic interrupt
occurs. 0=do nothing. 128=enable drive sleeping, 1=blink screen, 2=beep,
4=call program.</li>

<li>
<tt>DATA </tt>the address of a BLWP vector (workspace and address) where
to branch at if the call program option is enabled.</li>

<p><br>To prevent the watchdog from firing, a program must constantly write
to record 13 before the grace period is expired.
<p>N.B. The watchdog timer is automatically disabled after power went off.
<h4>
Records 100 to 227: XRAM pages</h4>
If your IDE card carries the RTC-65271 clock, you have an additional 4K
of battery-backed RAM at your disposal. This memory is part of the clock
chip and arranged as 128 pages of 32 bytes. You can access these pages
via records 100 to 227: the record number corresponds to the page number
plus 100.
<pre>300 INPUT #1, REC PAGE+100: A$</pre>

<li>
<tt>A$</tt> is a 32-byte string that contains the content of page <tt>PAGE</tt>.</li>

<p><br>Technically, only the RTC65271 has onchip RAM, the other clock chips
emulate this feature by placing data into the SRAM. With the bq4847 clock,
there is only room for 14 pages (records 100 to 113), with the bq4842 and
bq4852 clocks you can have 120 pages (records 100 to 219).
<p>You can also write to these pages, but be carefull as IDEAL reserves
the first pages of the RTC-65271 for its own use (they contain the system
configuration and the boot sequence that loads IDEAL into the card SRAM).
Before writing anything, check the fourth byte in page 0: it contains the
number of the first free page (or zero if all pages are used). Feel free
to update this byte as you reserve pages for your own use.
<pre>310 INPUT #1, REC 100:A$
320 PAGE=ASC(SEG$(A$,4,1)
330 PRINT #1, REC PAGE+100:MYFIRSTPAGE$</pre>
If the string you write is shorter than 32 bytes, the remainder of the
page remains unchanged.
<h2>
<br>
<a NAME="Configuration"></a>Configuring IDEAL</h2>
IDEAL has the capability to configure itself following your instructions.
To this end, open the pseudo-file <tt>IDE.CONGIF</tt> as an <tt>INTERNAL,
VARIABLE 128</tt> file. The various records provide access to the multiple
features of IDEAL.
<pre>100 OPEN #1:"IDE.CONFIG",INTERNAL, FIXED 128, UPDATE, RELATIVE</pre>
Alternatively, you can open it as Int/Fix 120, in which case all numbers
will be passed as integers (or 32-bit long integers for LBAs). This is
usefull when working from assembly, so you don't have to deal with floating
point numbers.
<p>Technical note: actually, the file type is not checked, only the record
size is. A record size of 128 or above uses floating point numbers, any
size under 128 uses integers. Basic stupidely prevents you to open variable
files as relative, so you must either use <tt>FIXED</tt>, or open the file
as <tt>SEQUENTIAL</tt>. There is no such limitation if you work from assembly.
<p>You can modify some of these values by writing to the desired record.
Note that some records are read-only.
<p>Once you are done, don't forget to close the file: it's at this point
that the configuration is saved on disk. When you write to the file, the
changes are only saved into the SRAM and the RTC65271 clock XRAM, if you
have this clock chip.
<pre>500 CLOSE #1</pre>
By the way, saving the configuration to the hard drive is something that
you may want to do from time to time, just is case the clock battery would
run out... To this end, you must open <tt>IDE.CONFIG</tt>, write to it
at least once (e.g. to enter your password), the close it.
<h4>
Record 0</h4>

<pre>110 INPUT #1:PASSWORD$, LOCK, VERSION, PARTITION, VIRDRIVE</pre>

<li>
<tt>PASSWORD$</tt> is a password string that lets you write-protect IDE.CONFIG
so that a malicious program cannot fool around with your system settings.
The password can be upto 32 characters in length, by default it is "ThN"
(my initials, note that 'h' is in lower case). For obvious reasons, <tt>PASSWORD$</tt>
is write-only and always reads as an empty string.</li>

<li>
<tt>LOCK </tt>is the lock status flag: if it is 0, you don't need a password
to write to IDE.CONFIG (except to change <tt>PASSWORD </tt>and <tt>LOCK)</tt>.
When <tt>LOCK </tt>is different from 0, you will need to write your password
to record 0 before you can write to any other record. NB You don't need
to change <tt>LOCK </tt>when doing so: the file is temporarily unlocked
when you enter your password and will be relocked once you close it.</li>

<li>
<tt>VERSION</tt> Version number of IDEAL. Read only. Version 1.0 reads
as 10, version 1.1 as 11, etc.</li>

<li>
<tt>PARTITION</tt> Current partition (currently, only partition 1 is available).
Read only.</li>

<li>
<tt>VIRDRIVE</tt> Current virtual drive. Read only.</li>

<p><br>To access a locked file, all you need to do is to write your password
to record 0. The file is temporarily unlocked, until you close it. If you
want to unlock it permanently, set <tt>LOCK </tt>as 0.
<p>To change your password you must write twice to record 0: first write
the <b>old</b> password and set <tt>LOCK </tt>as 1, then write the new
password and set <tt>LOCK </tt>as you like.
<h4>
Record 1 through 4</h4>
These records access the current directory in partitions 1 through 4. These
are reserved for future expansion of the system.
<pre>110 INPUT #1:PATH$,DRIVENB,LBA</pre>

<li>
<tt>PATH$</tt> Path to the current directory in this partition. Currently,
set as partition root (i.e. A.).</li>

<li>
<tt>DRIVENB</tt> Drive number through wich this partition can be accessed
(currently >61).</li>

<li>
<tt>LBA </tt>Address of the current directory in the partition.</li>

<h4>
<a NAME="config rec5"></a>Record 5</h4>

<pre>110 INPUT #1,REC 5: SYSPATH$,MAXLBA,SLAVELBA,ROOTLBA,TOPLBA,SYSLBA,F360,F720,F1440,L360,L720,L1440</pre>

<li>
<tt>SYSPATH$</tt> Diskname and filename of the first system file (e.g.
"<tt>DISKNAME.IDEAL/A</tt>").</li>

<li>
<tt>MAXLBA </tt>Last address that can be used by the floppy collection
in the master drive.</li>

<li>
<tt>SLAVELBA </tt>Last address in the slave drive (if any).</li>

<li>
<tt>ROOTLBA </tt>Address of the virtual floppy disk collection (floppy
at root of the tree).</li>

<li>
<tt>TOPLBA </tt>Current address reached by the floppy collection (there
may be some empty slots in this space, if you deleted floppies)..</li>

<li>
<tt>SYSLBA</tt> Address of the virtual floppy containing the system files.</li>

<li>
<tt>F360,F720,F1440</tt> First floppies (i.e. last deleted) in the trash
lists for 360-, 720-, and 1440-sector floppies.</li>

<li>
<tt>L360,L720,L1440</tt> Last floppes (next reclaimed) in the trash lists.</li>

<p><br><tt>MAXLBA </tt>and <tt>SLAVELBA </tt>let you define the size of
your master and slave drive respectively. This space will be available
for the floppy disk collection. If you wanted to reserve space for other
purposes on the drive, you could set either parameter to less than the
actual hard disk size. If you have no slave drive, just set <tt>SLAVELBA
</tt>as
0, so that the floppy collection won't be expanded on the slave drive once
the master is full.
<p>With <tt>SYSPATH$</tt> you indicate the location of the IDEAL system
files, so they can be loaded at power-up time. It must be in the form of
a diskname, a dot, and the name of the first system file. When you write
to <tt>SYSPATH$</tt>, the corresponding <tt>SYSLBA </tt>is automatically
computed or a "file error" is issued if the disk does not exist (but the
presence of the system files on this disk is not verified).
<p><tt>TOPLBA</tt> and <tt>ROOTLBA </tt>are internal pointers to your floppy
disk collection. <tt>F360</tt> through <tt>L1440</tt> are internal pointers
to the three lists of deleted floppies. All are automatically updated when
you edit the collection. WARNING: it is very risky to modify these pointers
yourself, as this could completely mess up your collection. The only time
they should be written to is when trying to restore your configuration
frmo record 22, after it was accidentally lost (assuming you had no configuration
backup).
<h4>
Record 6 through 9</h4>
These records access the four partitions. Only partition 1 is implemented
in IDEAL.
<pre>110 INPUT #1: NAME$,DRIVENB,LBA,SIZE</pre>

<li>
<tt>NAME$</tt> Name of the DSR for the partition (Currently "A" for partition
1).</li>

<li>
<tt>DRIVENB </tt>Drive number to access the partition from subprograms
(Currently >61 for partition 1).</li>

<li>
<tt>LBA </tt>Address of the partition.</li>

<li>
<tt>SIZE </tt>Size of the partition, in 512-byte sectors.</li>

<h4>
Record 10 through 17</h4>
These records access the virtual drives DSRs that emulate floppy drives.
<pre>110 INPUT #1:NAME$,DRIVENB,FLOPPYLBA</pre>

<li>
<tt>NAME$</tt> Name of the DSR for this drive (Normally <tt>DSK1 </tt>through
<tt>DSK9
</tt>and
<tt>DSKA
</tt>through
<tt>DSKZ</tt>).</li>

<li>
<tt>DRIVENB</tt> Drive number to access this drive from subprograms (for
<tt>DSKx</tt>,
ascii of x minus >30, e.g. <tt>DSK2</tt> = >02, etc).</li>

<li>
<tt>FLOPPYLBA</tt> Hard disk address of the virtual floppy "inserted" in
this drive (-1 if none).</li>

<h4>
Record 18</h4>

<pre>200 INPUT #1:RTCNAME$</pre>

<li>
<tt>RTCNAME$</tt>: Name of the clock access DSR. By default "<tt>CLOCK</tt>".</li>

<h4>
<a NAME="Auto & XB files"></a>Record 19</h4>

<pre>130 INPUT #1:FULLNAME$,ONOFF,XBFULLNAME$,CRU</pre>

<li>
<tt>FULLNAME$</tt>: Specifies which program is launched upon power-up (if
any). It must be in the form <tt>DISKNAME.FILENAME</tt> (no subdirectory
path). The file should be a "program" file, containing either an assembly
language program, an Extended Basic program (in which case the Extended
Basic cartridge should be plugged in, or loadable in a GRAM-card), or a
GPL program (such as a cartridge) to be loaded in your GRAM-card.</li>

<li>
<tt>ONOFF</tt>: Determines whether the program will start automatically
upon power up. 0=no, 1=yes, 2=load but don't start.</li>

<li>
<tt>XBFULLNAME$</tt>: Specifies the location of the Extended Basic cartridge
to be loaded in a GRAM-card. It must be the name of the first file, in
the form <tt>DISKNAME.FILENAME</tt>.</li>

<li>
<tt>CRU </tt>is the base CRU of your GRAM-card, if you have one. 0 stands
for >1000, 1 for >1100, ... 15 for >1F00.</li>

<p><br>The existance of <tt>FULLNAME$</tt> and <tt>XBFULLNAME$</tt> is
only verified when they are actually used, so you won't get an error if
you enter the name of a file that does not exist (yet).
<h4>
<a NAME="user options"></a>Record 20</h4>
This record collects a whole bunch of options. To set one or more options,
add up the values of the corresponding flags and pass the result in <tt>OPTIONS</tt>.
<pre>240 INPUT #1:OPTIONS, SLEEP, OPENED, MAXOPEN</pre>

<li>
<tt>OPTIONS</tt>: User preferences flags. Just add up the flag values of
the desired options.</li>

<li>
<tt>SLEEP</tt>: Number of minutes of inactivity before the drives go to
sleep (0=ignored).</li>

<li>
<tt>OPENED`</tt> Number of opened files allowed simultaneously (just like
CALL FILES, but IDE-specific).</li>

<li>
<tt>MAXOPEN </tt>Maximum value for <tt>OPEN</tt>, depends on the size of
the SRAM.</li>

<p><br><u>Option flags:</u>
<br>1 = Time-stamp virtual floppies.
<br>2 = Time-stamp files.
<br>4 = Allow sector-wise access.
<br>8 = Recycle deleted floppies to create new ones.
<br>16 = Wipe encryption key upon reset.
<br>32 = Allow only one Dis/Fix directory file per disk (the parent).
<br>64 = Do not delete Dis/Var directory files when target disk is deleted.
<br>128 = Do not allow modifications to the floppy collection (i.e. write-protect
<tt>IDE.FLOPPIES</tt>).
<br>256= Put inactive drives to sleep.
<p>512 = RAMBO mode not allowed (even if supported by the hardware).
<br>1024= Encryption not supported.
<br>2048= Floppy collection manager and trash manager not supported.
<br>4096= Configuration manager, extended catalog and sector-wise access
not supported.
<br>8192= <tt>CLOCK </tt>DSR not supported (but time stamping still is).
<p>Flags "1" through "128" are self explanatory and have been discussed
in the relevant sections anyhow.
<p>By setting the "256" flag, you can cause the drives to be put to sleep
after a given number of minutes of inactivity. The number of minutes can
be set with the <tt>SLEEP </tt>value. The sleeping algorithm makes use
of the clock alarm to trigger an interrupt every minute, and decrease a
counter. When the counter reaches zero, the "sleep" command is sent to
the drives. Accessing any DSR or CALL on the card resets the counter to
the <tt>SLEEP </tt>value, thereby delaying the moment to put the drives
to sleep. Once a drive is asleep it may take several seconds to wake up,
so the next drive operation could appear hanged up, but don't worry: the
command will complete as soon as the drive is ready. N.B. Modifications
to this flag only become effective when you reset your TI-99/4A.
<p>The flags "512" through "8192" let you disable some parts of IDEAL,
so that you can save memory or loading time, by using a truncated version
of IDEAL. I'd recommend that you use the full-fledge version, but it's
up to you.
<h4>
Record 21</h4>
This record lets you access hardware information: it describes the peculiarities
of your card, how you wired it, what is available, etc.
<pre>250 INPUT #1:CONFIG,SRAM,RAMBO,REGBIT,SWBIT,FIXBIT,RAMBOBIT,WPBIT,RSTBIT,IRQBIT</pre>

<li>
<tt>CONFIG</tt>: Hardware configuration flags.</li>

<li>
<tt>SRAM</tt>: Size of the on-board SRAM.</li>

<li>
<tt>RAMBO</tt>: Number of available RAMBO banks (8 K each).</li>

<li>
<tt>REGBIT</tt>: CRU bit that selects register access (normally 1).</li>

<li>
<tt>SWBIT</tt>: CRU bit that enables bank switching. Negative if active-low,
0 if none (normally 2).</li>

<li>
<tt>FIXBIT</tt>: CRU bit that freezes the area >4000-4FFF to bank 0. Negative
if active-low, 0 if none (normally -3).</li>

<li>
<tt>RAMBOBIT</tt>: CRU bit that enable RAMBO mode. Negative if active-low,
0 if none (normally 4).</li>

<li>
<tt>WPBIT</tt>: CRU bit that write-protects the SRAM. Negative if active-low,
0 if none (normally 5).</li>

<li>
<tt>RSTBIT</tt>: CRU bit that resets the drives. Negated if active-low,
0 if none (normally 7).</li>

<li>
<tt>IRQBIT</tt>: CRU bit that senses drive-issued interrupts. Normally
0.</li>

<p><br>Configuration flags:
<br>1 = has battery-backed SRAM.
<br>2 = has XRAM in clock.
<br>4 = clock can send interrupts.
<br>8 = RAMBO mode supported by hardware.
<h4>
<a NAME="config rec22"></a>Record 22</h4>
Reading this record triggers a disk scanning routine that will search your
hard drive for virtual floppies and return the key pointers needed for
your configuration: the root of the collection and the first and last deleted
disks for each disk size. Be aware that it could take a very long time,
especially if you have a large hard drive. So be patient and wait for the
DSR to return control to you: you can tell it's working by looking at the
back LED which should blink as the hard drive is read (you may be able
to hear it clicking, too).
<p>Once scanning is completed, record 22 returns the following values:
<pre>910 INPUT #1:ERROR,ROOTLBA,TOPLBA,F360,F720,F1440,L360,L720,L1440</pre>
<tt>ERROR: </tt>returns the error status. See below.
<br><tt>ROOTLBA</tt>: floppy at the root of your collection, i.e. in the
middle of the alsphabetical order.
<br><tt>TOPLBA</tt>: is the first non-floppy area in the hard drive, where
the next floppy will be created.
<br><tt>F360,F720,F1440</tt>: first link in the chain of deleted floppies
for their respective size.
<br><tt>L360,L720,L1440</tt>: last link in these chains.
<p>These values can be written into record #5 to restore a lost configuration.
Make sure you first check the error code, then the individual LBA pointers
for validity. A missing pointer is returned as zero.
<p><u>Error codes:</u>
<br>>0001: Disk read error (fatal, aborts scanning)
<br>>0002: Multiple canditates for F360
<br>>0004: Multiple canditates for F720
<br>>0008: Multiple canditates for F1440
<br>>0010: Multiple canditates for L360
<br>>0020: Multiple canditates for L720
<br>>0040: Multiple canditates for L1440
<br>>0080: Can't find F360 or L360 (or both). No error issued if no deleted
file of this size was found.
<br>>0100: Can't find F720 or L720 (or both). Ditto.
<br>>0200: Can't find F1440 or L1440 (or both). Ditto.
<p>The scanning algorithm checks the "protected" area of sector 0 for each
virtual floppy. First and last deleted files are detected by the lack of
a "previous" or "next" link. The root of the active collection is the floppy
with the highest number of children in its left subtree, if there is a
tie the one which is heavy on the right wins. The routine stops scanning
when this area doesn't match the expected format (be aware that string
of >00 does match the format...). As a result, scanning may be aborted
if a damaged disk was encountered.
<p>You have several options to modify the scanning strategy, by writing
to record 22 prior to reading it:
<pre>900 PRINT #1: TOTAL,FIRSLBA,LASTLBA</pre>
<tt>TOTAL</tt>: indicates the number of virtual floppies that the routine
should search. For instance, if you know you have less than 300 floppies
in your collection, use 300. If zero, this parameter will be disregarded.
<br><tt>FIRSTLBA</tt>: tells the scanning routine where to look for your
floppy collection. If zero, the default address (hard sector 8) will be
used. You may use it to resume scanning where it had stopped (although
<tt>ROOTLBA
</tt>may
not be detected correctly).
<br><tt>LASTLBA</tt>: tells the scanning routine where to stop. When in
doubt, use the size of your hard drive in KB, multiplied by 2. If zero,
this parameter is disregarded.
<p>When both <tt>TOTAL </tt>and <tt>LASTLBA </tt>are specified, scanning
stops when the first of the two limits is reached. If <tt>TOTAL </tt>and
<tt>LASTLBA
</tt>are
both zero, scanning continues until an invalid format is detected, which
is the default situation if you do not write to record 22 at all.
<h2>
<br>
<a NAME="hard-drive access"></a>Direct access to the hard drives</h2>
It is possible for you to access your hard drives directly, on a sector-by-sector
basis. Just be aware that it is an extremely powerfull feature and that
you may end up completely scrambling the contents of your drives if you
don't know what you are doing. In fact, you have the option to disable
sector-wise access when configuring IDEAL, so that no malicious program
can play havoc with your drives.
<p>To access your drives, open the file <tt>IDE.SECTORS</tt> as a <tt>INTERNAL</tt>,
<tt>FIXED
129 </tt>file in Basic or Extended Basic. In assembly, use a record size
of 130: this will cause numeric values to be passed as 32-bit long integers,
rather than as floating point numbers.
<pre>100 OPEN #1: "IDE.SECTORS", INTERNAL, FIXED 129, RELATIVE</pre>
<tt>IDE.SECTORS</tt> is a pseudofile that contains only five records. Record
0 is used to set the sector number, and records 1 through 4 each contain
a 128-byte string corresponding to a quarter of the selected sector. Oh
yes, I forgot to mention it, but hard drives have 512-byte sectors.
<p>To read a hard-drive sector, you would do:
<pre>110 PRINT #1, REC 0: LBA1,LBA2
120 INPUT #1: PART1$,PART2$,PART3$,PART4$</pre>
Then you can write the strings back. The address won't change unless you
write a new one to record 0. (In case you forgot what it was, you can read
it back from record 0).
<pre>130 PRINT #1:PART1$,PART2$,PART3$,PART4$</pre>
If one of the strings contains less than 128 bytes, or if you don't write
back all four strings, the remaining bytes in the sector are unchanged.
<p>You don't have to explicitely close this file, but it won't hurt doing
it:
<pre>200 CLOSE #1</pre>

<h4>
<br>
<br>
LBA addressing</h4>
Nowadays, most hard drives use logical block addressing (LBA). Which means
that you can consider your drive as a huge array of 512-byte sectors, numbered
from 0 to whatever your drive size allows. Addresses 0 through 268,435,455
are on the master drive, whereas addresses 268,435,456 through 536,870,912
are on the slave drive. In hexadecimal notations, these are 0 through >0FFFFFFF
and >10000000 through >1FFFFFFF. If you do the math and multiply these
numbers by 512 bytes, you'll find out that you can access 128 gigabytes
per drive!
<p>For your convenience, if you pass a negative number in LBA1 it will
be ignored and LBA2 is assumed to contain an address in the slave drive,
to which the corresponding bias will be added (thus LBA2 should be in the
range 0 to 268,435,455). If LBA1 is positive, LBA2 will be ignored.
<p>Finally, if both LBA1 and LBA2 are negative, the address is bumped up
to the next sector. This is usefull to walk the drive sector by sector:
<pre>140 PRINT #1, REC 0:-1,-1</pre>
When working from assembly, you can avoid dealing with floating point numbers
and use long integers (32-bit words) instead. To this end, just open the
file as <tt>INTERNAL</tt>, <tt>FIXED 130</tt>. This tells IDEAL that all
LBAs should be passed to and from record 0 as long integers.
<h2>
<br>
<a NAME="DSRs"></a>DSRs</h2>
IDEAL implements several DSRs :
<ul>
<li>
Eight virtual drives that emulate TI drives. They can have any name upto
7 characters, but I'd suggest you stick with DSKx, where x is a digit from
'1' to '9', or a letter from 'A' to 'Z'. This will make them fully compatible
with existing TI programs.</li>

<li>
Four partitions that will be used for full-disk access in a future version.
Their default names are "A", "B", "C" and "D" and they are meant to implement
two partitions on the master drive and two on the slave drive. Currently,
only "A" is used to hold your collection of virtual floppies (and you can't
access it as a partition).</li>

<li>
A DSR called LD that will load any program file, whether assembly, Extended
Basic or cartridge dump.</li>

<li>
A DSR named IDE, that lets you configure your drives or the system itself.
It contains several pseudo-files:</li>

<ul>
<li>
<tt>IDE.CONFIG</tt> configures the system (see <a href="#Configuration">above</a>).</li>

<li>
<tt>IDE.BLOWON</tt>, <tt>BLOWOFF</tt>, <tt>BLOWOUT </tt>and <tt>BLOWAWAY
</tt>access
the Blowfish encryption functions (see <a href="#Encryption">above</a>).</li>

<li>
<tt>IDE.FLOPPIES</tt> accesses the floppy disk collection (see <a href="#Collection">above</a>).</li>

<li>
<tt>IDE.TRASH1,</tt> <tt>TRASH2 </tt>and <tt>TRASH3 </tt>accesses the deleted
floppies (see <a href="#Collection">above</a>).</li>
</ul>

<li>
A clock DSR, named <tt>CLOCK</tt> (by default), that lets you access the
real-time clock. You can read time and date, set alarms, etc. See <a href="#clock">above</a>
for a detailed description.</li>
</ul>
<a href="#DSKx">DSKx virtual drives</a>
<br><a href="#loaders">LD loader</a>
<br><a href="#autostart">Autostart feature</a>
<br><a href="#%3E0A">Opcode >0A</a>: load assembly program
<br><a href="#%3E0B">Opcode >0B</a>: load Basic program
<br><a href="#%3E0C">Opcode >0C</a>: load cartridge
<h4>
<a NAME="DSKx"></a>DSKx</h4>
These DSRs emulate a floppy drive. Their names can be set with IDE.CONFIG,
but should be kept in the range <tt>DSK1 - DSK9 </tt>and <tt>DSKA - DSKZ</tt>.
As always with DSRs, parameters are passed via a <a href="../../headers.htm#PAB">PAB</a>
(peripheral access block) in VDP memory.
<p>It is also possible to use the <tt>DSK.DISKNAME.FILENAME</tt> syntax,
but this may not work if the TI disk controller is installed: this stupid
controller returns an error if it does not find the disk in drives 1-3.
Thus <tt>DSK.DISKNAME</tt> only works properly when the IDE card is called
before the TI disk controller, i.e. when its CRU is >1000.
<p>As a remedy to this unfortunate situation, an extra DSR called <b>DSK@</b>
is provided. It is completely equivalent to <tt>DSK </tt>and should be
used in the same way: <tt>DSK@.DISKNAME.FILENAME</tt>. Since the TI controller
does not contain <tt>DSK@ </tt>it won't interfer with the search.
<p>An extra DSR called <b>DSK*</b> lets you access files on the same drive
that was last used (by either a DSR or a call). This is usefull when a
program must load data files: by using the <tt>DSK*.FILENAME</tt> syntax,
you ensure that the data files will always be loaded from the drive the
program was on.
<p>The standard opcodes defined by Texas Instruments are all implemented:
<li>
>00 Open file</li>

<li>
>01 Close opened file</li>

<li>
>02 Read record from opened file</li>

<li>
>03 Write record to opened file</li>

<li>
>04 Rewind opened file to a given record</li>

<li>
>05 Load program file</li>

<li>
>06 Save program file</li>

<li>
>07 Delete file</li>

<li>
>08 Scratch record from file (NB this one did not work with the TI controller.
It does now)</li>

<li>
>09 Return file status.</li>

<p><br>Several improvements, introduced with the Horizon Ramdisk, have
been included:
<li>
It is not necessary to specify the file type (DV80, IF254, etc) with <tt>OPEN
</tt>if
the file already exists. If you do not specify a record length, the file
type will be taken from disk, not from whatever you specified. Be aware
that Basic wants at least one comma after the file name in the
<tt>OPEN
</tt>instruction.</li>

<li>
Fixed files can now be opened in append mode: the number of the next record
past the end of file will be placed in PAB+6. This will only work from
assembly though, since Basic and Extended Basic are in the stupid habit
of reseting the record number to 0 after <tt>OPEN</tt>.</li>

<li>
Adding >40 to the opcode means that the data buffer specified at PAB+2
is located in CPU memory, not in VDP RAM.</li>

<li>
Opcode 8 (scratch record) works both for fixed and variable records. There
is no way to call it from Basic unfortunately.</li>

<li>
All opcodes return the file status in PAB+8, (only opcode >09 did it with
the TI controller). If a device error occured (IO error code 6) this byte
should contain the error code read from the IDE error register. See my
<a href="ide.htm#error%20codes">IDE
page</a> for meanings.</li>

<br>&nbsp;
<p>&nbsp;
<p>In addition, the following extra opcodes were defined by the Horizon
Ramdisk, and are also supported by IDEAL:
<li>
>0A Load <b>A</b>ssembly program</li>

<li>
>0B Load Extended <b>B</b>asic program</li>

<li>
>0C Load <b>C</b>artridge in a GRAM card</li>

<p><br>These serve to load and run a program. They are called automatically
by the LD DSR, but you can also use them from your assembly programs.
<h3>
<a NAME="loaders"></a>The program loaders</h3>

<h4>
The LD DSR</h4>
The LD DSR can be used to automatically load and run an assembly program,
in the form of one or more memory dump files in Editor/Assembler option
5 format. It can also trigger execution of an Extended Basic file, or load
a cartridge into a GRAM device, using the GramKracker file format. The
syntax is:
<pre>DELETE "LD.n.filename"&nbsp;&nbsp; from any language

CALL&nbsp; LD.n.filename&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; from TI-Basic or assembly

CALL&nbsp; LD".n.filename"&nbsp;&nbsp;&nbsp; from Extended Basic</pre>
<b><tt>DELETE </tt></b>is used here as an exemple. Actually, any file operation
will do (e.g. <tt>OPEN</tt>, <tt>OLD</tt>, <tt>SAVE</tt>, <tt>RUN</tt>,
and <tt>DELETE</tt>).
<br><b><tt>CALL </tt></b>has a different syntax in Extended Basic, because
Extended Basic does not consider characters beyond with ascii code beyond
'?' in the filename. You need to enclose the path in double quote to force
Extended Basic to consider it.
<br><b>n</b> is the drive number. If you did not name your drives following
the DSKn convention, n is the number you have assigned to the drive plus
48 (the ascii code for '0').
<br><b>filename</b> can be a simple file name, or a directory path ending
with a filename: <tt>LD.3.DIR1.DIR2.DIR3.MYFILE</tt>
<p>Alternatively, you may use the disk name:
<pre>RUN "LD.@.diskname.filename"

CALL LD.@.diskname.filename

CALL LD".@.diskname.filename"&nbsp; (Extended Basic only)</pre>
The <b>@</b> sign in place of a drive number instructs LD to look for a
vitual floppy in your collection (by analogy with <tt>DSK@</tt>).
<br><b>diskname </b>is the name of the desired virtual floppy.
<br><b>filename </b>is a simple file name or a full directory path.
<h4>
<br>
<a NAME="autostart"></a>Autostart feature</h4>
You have the option to automatically cause LD to load a given program at
power-up time. The program name can be selected with IDE.CONFIG, or with
one the the subprograms HAO, HAF and HAB (respectively standing for
<b>H</b>ard-drive
<b>A</b>utostart
<b>O</b>n,
o<b>F</b>f and <b>B</b>oot).
<pre>CALL HAO</pre>
Switches autostart on: each time you reboot your TI-99/4A the selected
program will be called in place of the "Texas Instruments Home Computer"
colorfull screen.
<pre>CALL HAO.diskname.filename</pre>
Same as above, but lets you change the file that should be called when
booting. Note that you must specify a diskname (not a DSKn drive) and a
filename with no subdirectories inbetween. Beware that it will not work
in Extended Basic (not even with quote marks), so always use TI-Basic to
change the name of the auto-start file.
<pre>CALL HAF</pre>
Switches autostart off. Note that <tt>CALL HAF.diskname.filename</tt> can
also be used.
<pre>CALL HAB</pre>
Switches autostart on for only one time: when you do a hard reboot (i.e.
turn the PE box power off ). This is usefull if you want to load a cartridge
in your GRAM card at power-up time: obviously there is no need to reload
it each time you press the &lt;quit> key! On the other hand, if power is
turned off, the cartridge will likely be wiped out of the GRAM card, and
you'll need to reload it. Since IDEAL will also be reloaded in such a situation,
it will automatically load your cartridge.
<p>Here also, <tt>CALL HAB.diskname.filename</tt> is legal.
<p>Note: the autostart file can also be set with the configuration manager
(see <a href="#Auto%20&%20XB%20files">above</a>).
<h4>
<br>
<a NAME=">0A"></a>Opcode >0A. Load assembly program</h4>
From assembly language, you have the option to use three special opcodes
to load a file with any "DSKn" DSR.
<p>Opcode >0A loads a program file in EA5 format, i.e. that starts with
a 6-byte header in the form:
<p>>0000: flag
<br>>0001: bank
<br>>0002: size
<br>>0004: loading address
<p>If <b>flag </b>is not >00xx, loading continues with a file having the
same name but for the last character that is incremented (e.g. <tt>MYFILE1
</tt>becomes
<tt>MYFILE2</tt>).
Execution normally starts at the beginning of the first file.
<br><b>Bank </b>is used to load a program into the IDE card SRAM banks.
It should contain the bank number, plus 32 (because banks 1 through 31
are reserved for GRAM cards). Note that, when execution begins, the last
bank is on, not the first one!
<br><b>Size </b>specifies the number of bytes to load. It can be ignored,
depending on the PAB (in which case the whole file is loaded).
<br><b>Address </b>is the address where to load the program. It can be
superceeded by the PAB.
<p>Some parameters in the PAB have unusual meanings:
<br>&nbsp;
<table BORDER >
<caption><tbody>
<br></tbody></caption>

<tr>
<th>>0000</th>

<td>>0A</td>

<td>>00</td>
</tr>

<tr>
<th>>0002</th>

<td COLSPAN="2">Start address</td>
</tr>

<tr>
<th>>0004</th>

<td COLSPAN="2">(not used)</td>
</tr>

<tr>
<th>>0006</th>

<td COLSPAN="2">Loadable size</td>
</tr>

<tr>
<th>>0008</th>

<td>(not used)</td>

<td>Name size</td>
</tr>

<tr>
<th>>000A</th>

<td COLSPAN="2">DSKn.FILENAME</td>
</tr>
</table>

<p><b>PAB+0</b>: Contains the opcode (>0A)
<br><b>PAB+1</b>: Should be 0. It will contain error flags if an error
occurs.
<br><b>PAB+2</b>: Address where to start execution. >0000: at the beginning
of the first file. >FFFF: load but don't execute.
<br><b>PAB+6</b>: If this word contains 0 (or >8000) no size checking will
occur. Otherwise, the file will only be loaded if its size (as specified
in the file FDR) is smaller or equal to this value. The >8xxx bit has a
special meaning: when set, the number of bytes is taken from <tt>SIZE</tt>,
the second word in the file. When the bit is reset, this word is ignored
and the whole file is loaded.
<h4>
<br>
<a NAME=">0B"></a>Opcode >0B. Load Extended Basic program</h4>
This opcode only works if the Extended Basic cartrige is plugged in, or
is emulated by a GRAM-card. It launches Extended Basic and snoops on it
via a hook to the interrupt routine. When it sees that Extended Basic is
about to load "<tt>DSK1.LOAD</tt>" it patches the filename in memory and
replaces it by the name of the program to be run. Nifty isn't it? (I whish
I could claim this trick as mine, but it's lifted from the Horizon Ramdisk
ROS, and they lifted it for someone else).
<p>Note that execution cannot return to the caller once Extended Basic
is done...
<p>If IDEAL does not find Extended Basic, but you have a GRAM card and
you have the Extended Basic cartridge stored somewhere on the hard disk,
the program will load the cartridge into the GRAM card and the proceed
with launching the XB program. For this to happen however, you must use
IDE.CONFIG to declare the location of the XB cartridge (see <a href="#Auto%20&%20XB%20files">above</a>).
<p>Only a few bytes in the PAB are actually used with opcode >0B:
<br>&nbsp;
<table BORDER >
<caption><tbody>
<br></tbody></caption>

<tr>
<th>>0000</th>

<td>>0B</td>

<td>>00</td>
</tr>

<tr>
<th>>0002</th>

<td COLSPAN="2">(not used)</td>
</tr>

<tr>
<th>>0004</th>

<td COLSPAN="2">(not used)</td>
</tr>

<tr>
<th>>0006</th>

<td COLSPAN="2">(not used)</td>
</tr>

<tr>
<th>>0008</th>

<td>(not used)</td>

<td>Name size</td>
</tr>

<tr>
<th>>000A</th>

<td COLSPAN="2">DSKn.FILENAME</td>
</tr>
</table>

<p><b>PAB+0</b>: Contains the opcode (>0B)
<br><b>PAB+1</b>: Should be 0. It will contain error flags if an error
occurs.
<h4>
<br>
<a NAME=">0C"></a>Opcode >0C. Load cartridge.</h4>
This opcode loads one or more program files into a GRAM device. The files
should follow the Gram-Kracker format, i.e start with a 6-byte header in
the form:
<p>>0000: flag
<br>>0001: bank
<br>>0002: size
<br>>0004: address
<br>>0008: option
<p>If <b>flag </b>is not >00, loading continues with another file. The
second file has the same name than the first one, with an extra "1". For
the following files, the "1" is incremented. So the sequence of names would
be: <tt>MYFILE</tt>, <tt>MYFILE1</tt>, <tt>MYFILE2</tt>, etc.
<br><b>Bank </b>specifies the GRAM area into which the file should be loaded.
Note that this information is redundant, since the address is already part
of the header. Alternatively, bank can specify a page in the cartrige RAM
space (>6000-7FFF). Standard cartridges and GRAM cards have only two RAM
pages but the german GramKarte allows for 16. In general the lower part
(>6000-6FFF) is identical in each bank, but there may be exceptions...
<br><b>Size </b>specifies the number of bytes to load.
<br><b>Address </b>it the address (in GRAM or RAM) where to load the data.
<br><b>option </b>corresponds to byte 4 in the GRAM, which is normally
zero. If it contains >A5 the GRAM device will be turned off after loading.
If it contains >5A only the RAM banks in the GRAM card will be turned off
after loading.
<p>Here is a summary of the valid values for "bank":
<br>>01: GRAM at >6000
<br>>02: GRAM at >8000
<br>>03: GRAM at >A000
<br>>04: GRAM at >C000
<br>>05: GRAM at >E000
<br>>06: GRAM at >0000 (caution: conflicts with console GROMs)
<br>>07: GRAM at >2000 (ditto)
<br>>08: GRAM at >4000 (ditto)
<br>>09: RAM bank 1 (>6000-7FFF)
<br>>0A: RAM bank 2 (normally only >7000-7FFF, but some device may allow
>6000-7FFF).
<br>>0B: RAM bank 3 (only on some devices)
<br>etc.
<br>>18: RAM bank 16
<p>Some parameters in the PAB have a special meaning:
<br>&nbsp;
<table BORDER >
<caption><tbody>
<br></tbody></caption>

<tr>
<th>>0000</th>

<td>>0C</td>

<td>>00</td>
</tr>

<tr>
<th>>0002</th>

<td COLSPAN="2">GRAM base</td>
</tr>

<tr>
<th>>0004</th>

<td COLSPAN="2">(not used)</td>
</tr>

<tr>
<th>>0006</th>

<td COLSPAN="2">(not used)</td>
</tr>

<tr>
<th>>0008</th>

<td>(not used)</td>

<td>Name size</td>
</tr>

<tr>
<th>>000A</th>

<td COLSPAN="2">DSKn.FILENAME</td>
</tr>
</table>

<p><b>PAB+0</b>: Contains the opcode (>0C)
<br><b>PAB+1</b>: Should be 0. It will contain error flags if an error
occurs.
<br><b>PAB+2</b>: If this word contains >98xx, this value is used as a
GRAM base. Otherwise, the current GRAM base stored at >83FA is used. If
>83FA does not contain a valid >98xx value, the default base >9800 is used.
<h4>
<a NAME="Gcard routine"></a>Gram card-specific routines</h4>
IDEAL currently supports only the german 128K GramKarte and the P-Gram+
card. All of IDEAL's gram-card management routines are calling a card-specific
subroutine that resides in its own file. For the German 128K Gram-Karte,
rename <tt>IDEAL/GK</tt> as <tt>IDEAL/G</tt> (this is the default). For
the P-Gram+ card, rename <tt>IDEAL/PG</tt> as <tt>IDEAL/G</tt>.
<p>If you have another GRAM device than the above, you can write yourself
a new version of this subroutine and IDEAL will use it to control your
device. This routine should be assembled as an AORG segment, to reside
at addresses >5900-5B00. As it is called by a BLWP instruction the first
two words (at >5900 and >5902) should be the workspace and the routine
address. You can place your workspace in the same memory area, between
>5904 and >5B00. I would advise you to use the RAG linker to generate the
final "program" file, since the TI loader cannot load a DF80 file at >5900.
Be aware that your routine will not be able to call DSRs or other routines
in the gram-card ROM since these would conflict with the IDE card DSR space.
<p>The default gram-card CRU, as set with <tt>IDE.CONFIG,</tt> can be retrieved
from the caller's R1 with a <tt>MOV @2(13),R12</tt> but this is entirely
optional: you could "hard-wire" the CRU inside your code if you want to
(for instance if you have several gram-cards).
<p>IDEAL will call your routine for various purposes. The reason for the
call is found in the caller's R0, that you can retrieve with a <tt>MOV
*R13,R0</tt>.
<ul>
<li>
If R0 is a positive number between >00 and >08, IDEAL is about to load
data into GRAM memory. R0 is the number of the target GROM (see "bank"
above for valid values). Your routine should write-enable the corresponding
memory, The GROM port to be used (e.g. >9800) can be found in the caller's
R8, i.e. at @16(R13). You can change it if necessary, but do not modify
any other register in the caller's workspace.</li>

<li>
If R0 is >09 or greater, IDEAL is about to load data into the cartridge
RAM space, at >6000-7FFF. R0 contains the bank number (>09 = first bank,
>0A = second, etc). Your routine should switch on the corresponding bank,
and write-enable it.</li>

<li>
If R0 is negative, IDEAL is done with loading and lets you decide what
you want to do with your card. As a clue, the least significant byte of
R0 contains the fourth byte of the last GROM loaded that contained a standard
header (i.e which started with >AA). The fourth byte is normally unused
(>00) but when creating a GRAM file you have the option to set it to a
special value to specify loading options:</li>

<ul>
<li>
If R0 is >xxA5, the card should be turned off after loading.</li>

<li>
If R0 is >xx5A, only the ROM banks should be turned off.</li>
</ul>
</ul>
Once done, you should return to the caller with a <tt>RTWP</tt> instruction,
preceded with an <tt>INCT R14</tt>. Returning without modifying R14 signifies
IDEAL that the current file should not be loaded (of course, if they are
more files to come, IDEAL will call again). For instance, since the console
GROMs map at >0000-57FF, you may want to reject any request to load at
these addresses. If, and only if, IDEAL was calling with >FFxx in R0, returning
without <tt>INCT R14</tt> will cause a "file error".
<p>Here is a sample Gram-card routine, that handles the German 128K Gram
Karte:
<br>&nbsp;
<table CELLSPACING=2 CELLPADDING=2 BGCOLOR="#E6E6E6" >
<caption><tbody>
<br></tbody></caption>

<tr>
<td>
<pre>*====================================================
*&nbsp; User-defined GRAM card routines for GramKarte
*&nbsp; Common entry point, loading code in *R13
*----------------------------------------------------
* CRU bit&nbsp;&nbsp; Meaning
* -------&nbsp;&nbsp; --------
* Bit 0&nbsp;&nbsp;&nbsp;&nbsp; 1=DSR on
* Bit 1&nbsp;&nbsp;&nbsp;&nbsp; 1=banks on
* Bit 2&nbsp;&nbsp;&nbsp;&nbsp; GRAM-enable 2
* Bit 3&nbsp;&nbsp;&nbsp;&nbsp; 0=GRAM on
* Bit 4&nbsp;&nbsp;&nbsp;&nbsp; 0=write-protect banks
* Bit 5&nbsp;&nbsp;&nbsp;&nbsp; 1=overwrite console GROMs
* Bit 6&nbsp;&nbsp;&nbsp;&nbsp; 1=use default bank (DIP-switch selected)
* Bit 7&nbsp;&nbsp;&nbsp;&nbsp; 0=switch banks 1=access banks
*====================================================
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AORG >5900

GCARD&nbsp; DATA WREGS,GKARTE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vectors (MUST be right here)
*
GKARTE INCT R14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; always ok: skip JMP upon return
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MOV&nbsp; @2(R13),R12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get default CRU&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MOV&nbsp; *R13,R11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; get loading code
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JLT&nbsp; GKDONE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; >FFxx = done
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CI&nbsp;&nbsp; R11,>0008&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; check if RAM-bank or GRAM
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JH&nbsp;&nbsp; GKBNK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bank

* Load in GRAM
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SBZ&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; turn GRAM on
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CI&nbsp;&nbsp; R11,>0006&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; is it in console space ?&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JL&nbsp;&nbsp; GK1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; no
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SBO&nbsp; 5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yes: override console GROMs
*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DECT R14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; alternative: skip this file
GK1&nbsp;&nbsp;&nbsp; RTWP&nbsp;

* Load in banks
GKBNK&nbsp; SBZ&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bank read ok
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SBZ&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bank write-protected
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SBZ&nbsp; 6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; no default bank
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SBZ&nbsp; 7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bank switching enabled
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; AI&nbsp;&nbsp; R11,-9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; adjust bank #
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SLA&nbsp; R11,1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MOV&nbsp; R11,@>6000(R11)&nbsp;&nbsp; switch
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SBO&nbsp; 7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bank switching disabled
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SBO&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bank write-enabled
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RTWP&nbsp;

* Done with loading
GKDONE SB&nbsp;&nbsp; R11,R11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keep only clue code
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CI&nbsp;&nbsp; R11,>00A5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; code for "card off"&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JNE&nbsp; GK2&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SBO&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; banks off
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SBO&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GRAM off
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SBZ&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; write-protect banks
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SBZ&nbsp; 5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; console GROMs in charge
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RTWP&nbsp;

GK2&nbsp;&nbsp;&nbsp; CI&nbsp;&nbsp; R11,>005A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; code for "banks off"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JNE&nbsp; GK3
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SBO&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; banks off
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SBZ&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and write-protected
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RTWP&nbsp;

GK3&nbsp;&nbsp;&nbsp; SBZ&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; normal case: write-protect banks&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SBZ&nbsp; 7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; enable switching
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RTWP&nbsp;
*
WREGS&nbsp; BSS&nbsp; 32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; our workspace

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; END</pre>
</td>
</tr>
</table>

<li>
Assemble such a file with the TI assembler.</li>

<li>
Link the resulting DF80 file with the RAG linker and name the final program
file IDEAL/G.</li>

<li>
Edit IDEAL/G with a file editor like DISKU and change the first two bytes
from >0000 to >FF22.</li>

<li>
Put it where all the other IDEAL/x files are.</li>

<h2>
<br>
<a NAME="Subprograms"></a>Subprograms</h2>
<b>Basic calls</b>
<br><a href="#WO&WF">WO and WF</a>
<br><a href="#DN">DN</a>
<br><a href="#HAO+HAF+HAB">HAO, HAF, and HAB</a>
<br><a href="#CD">CD</a>
<br><b>Assembly callable subprograms</b>
<br><a href="#%3E10">>10 Sector access</a>
<br><a href="#%3E11">>11 Disk format</a>
<br><a href="#%3E12">>12 File protection</a>
<br><a href="#%3E13">>13 File rename</a>
<br><a href="#%3E14">>14 Bulk read</a>
<br><a href="#%3E15">>15 Bulk write</a>
<br><a href="#%3EB0">>B0 Rambo manager</a>
<br><b>Others</b>
<br><a href="#Other%20subs">DSRs used as calls</a>
<h3>
<a NAME="Basic sub"></a>Basic subprograms</h3>
There are several subprograms that are designed to be called from Basic
or Extended Basic. You can also call them from assembly, just be aware
that the error code is returned in byte >8342 and that they skip a word
on return when no error occurs (<tt>INCT R11</tt>).
<h4>
<a NAME="WO&WF"></a>Write-protection</h4>
Real floppy disks can be protected in two ways: by software, by changing
the "DSK " string in sector 0 to "DSKP", or by hardware, by blocking the
write-protection notch with some opaque tape. The first mechanism is ignored
by the majority of disk managers, and virtual floppies obviously don't
have any notch! Instead, IDEAL is using a special bit in sector 0 to indicate
write-protected floppies. This bit can be set and cleared with the <tt>IDE.FLOPPIES</tt>
utility, or by accessing the disk's extended catalog.
<p>When a floppy is "inserted" into a virtual drive, its protection status
is read by the drive and comes into effect. However, you have the option
to temporarily override this status and set a different protection, just
for this drive:
<p><b><tt>CALL WO.n</tt></b> sets write protection on for drive n
<p><b><tt>CALL WF.n</tt></b> turns write-protection off for drive n
<p>Note that this does not affect the write-protection status of the floppy
in your collection, nor does it affect other drives that may be accessing
the same floppy. (Yes, you can load the same floppy in several drives.
But this is quite risky if more than one drivehas write permission...)
<p>If you insert a new floppy in the drive, the protection status of that
floppy will come into effect. In other words, whatever command arrives
last is the one that prevails.
<h4>
<br>
<a NAME="DN"></a>Drive name</h4>
Provided that a virtual drive obeys the DSKn naming convention, you can
change its number n with the following subprogram:
<pre><b>CALL DN.o.n</b></pre>
where <b>o</b> is the old drive number and <b>n</b> the new number (e.g.
<tt>CALL
DN.8.5</tt> renames <tt>DSK8 </tt>as <tt>DSK5</tt>).
<p>An error will occur if a drive with that number already exists in the
IDE card, but IDEAL cannot check for the presence of such a drive in the
floppy disk controller card, nor in a Ramdisk card. In case of conflicting
drive names, the card with the lowest CRU address is the one who will be
accessed.
<h4>
<br>
<a NAME="HAO+HAF+HAB"></a>Autostart</h4>
As described above, you can toggle the autostart feature on and off the
the following three subprograms:
<p><b><tt>CALL HAO</tt></b> turns autostart on
<p><b><tt>CALL HAF</tt></b> turns autostart off
<p><b><tt>CALL HAB</tt></b> only autostarts at boot time (i.e. once, after
power went off).
<p>Either of these can also be used from TI-Basic (or assembly) to change
the program to be started at power-up time:
<pre>CALL HAO.diskname.filename</pre>
The selected program may be an assembly program in EA5 format, an Extended
Basic program (in which case the Extended Basic cartridge may be automatically
loaded in your GRAM card, if needed), or a cartridge dump in GramKracker
format. Note that cartridges are loaded, but not executed, unless they
contain a power-up routine or a foreign language translation routine.
<h4>
<a NAME="CD"></a>Change disk</h4>
As described previously, the CD subprogram can be used in several manners
to change the virtual floppy accessed through a drive:
<pre><tt>CALL CD.n..diskname&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; from TI-Basic or assembly

CALL CD".n..diskname"&nbsp;&nbsp;&nbsp; from Extended Basic</tt></pre>
This will "insert" the virtual floppy named "diskname" into drive <tt>DSKn</tt>.
Note the double-dot syntax that signals a disk name.
<pre><tt>CALL CD.n.directory&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; from TI-Basic or assembly

CALL CD".n.directory"&nbsp;&nbsp;&nbsp; from Extended Basic</tt></pre>
This will insert the disk pointed at by a directory file located on the
disk currently inserted in <tt>DSKn</tt>. This time, there is only one
dot after the drive number, which indicates a directory path.
<p><tt>CALL CD.n.&lt;</tt>
<p>This will insert the parent of the current vitual floppy in DSKn. A
virtual floppy has a parent if at least one directory file points to it.
If there is more than one, the first one you created is the parent unless
you specified it otherwise. This allows you to organise your floppies in
a tree-wise manner, as on a PC:
<pre><b>DISK1
</b>+-HERSTUFF-------><b>DISK5
</b>|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-LETTER1
|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-LETTER2
|
+-MYDIR----------><b>MYDIR
</b>+-OTHERFILE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-GAMES-----><b>GAMES
</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-CHESS
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-HANGMAN
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-NUDIES----><b>DISK4
</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-CLAUDIA
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-ELLE
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-SOPHIE</pre>
For example, assume the virtual floppy named <tt>GAMES</tt> is currently
inserted in drive <tt>DSKZ</tt> and you want to access the file called
<tt>LETTER1.</tt>
You could do something like:
<pre>OPEN #1: "DSKZ.&lt;.&lt;.HERSTUFF.LETTER1", DISPLAY, VARIABLE 80</pre>
Of course, you could also do it this way:
<pre>OPEN #1: "DSK@.DISK5.LETTER1", DISPLAY, VARIABLE 80</pre>
or this way:
<pre>OPEN #1: "DSK@.DISK1.HERSTUFF.LETTER1", DISPLAY, VARIABLE 80</pre>

<h4>
<br>
<a NAME="Assembly subs"></a>Assembly subprograms</h4>
The standard assembly level subprograms >10 through >16 are provided. A
common extra feature is that you can add >80 to the drive number, to indicate
that the data buffer is located in CPU memory instead of VDP memory.
<h4>
<a NAME=">10"></a>>10 Sector I/O</h4>
This subprogram reads or writes a sector from the disk to/from a data buffer
that you provide. This buffer is normally in VDP memory, unless you add
>80 to the drive number. The number of bytes transfered is always 256.
<p>Input parameters
<br>&nbsp;
<table BORDER >
<caption><tbody>
<br></tbody></caption>

<tr>
<td>>834A</td>

<td COLSPAN="2" WIDTH="80%">-</td>
</tr>

<tr>
<td>>834C</td>

<td WIDTH="40%">Drive #&nbsp;</td>

<td WIDTH="40%">0: write&nbsp;
<br>&lt;>0: read</td>
</tr>

<tr>
<td>>834E</td>

<td COLSPAN="2" WIDTH="80%">Data buffer address</td>
</tr>

<tr>
<td>>8350</td>

<td COLSPAN="2" WIDTH="80%">Sector number</td>
</tr>
</table>

<p>Output parameters
<br>&nbsp;
<table BORDER >
<caption><tbody>
<br></tbody></caption>

<tr>
<td>>834A</td>

<td COLSPAN="2" WIDTH="80%">Sector number</td>
</tr>

<tr>
<td>>834C</td>

<td WIDTH="40%">-</td>

<td WIDTH="40%">-</td>
</tr>

<tr>
<td>>834E</td>

<td COLSPAN="2" WIDTH="80%">-</td>
</tr>

<tr>
<td>>8350</td>

<td COLSPAN="2" WIDTH="80%">Error code</td>
</tr>
</table>

<p><u>Technical notes</u>
<p>IDEAL stores some information at the end of sector 0 (bytes >EE-FF)
that is used to manage the floppy disk collection. Since these data are
critical for proper operation, subprogram >10 does not let you modify them.
<p>If you have set the time-stamping option while condiguring IDEAL, bytes
>14 through >1B may be automatically modified upon writing sector 0. The
current time and date are written to bytes >18-1B (last modification stamp)
unless bytes >18-19 contain >FFFF. If bytes >14-15 contain >0000, the same
values are also written to bytes >14-17 (creation stamp).
<p><u>Encryption issues</u>
<p>Subprogram >10 can tell whether sector 0 is encrypted or not, but it
cannot do it with other sectors. So it just assumes that, if encryption
is on (<tt>DELETE "IDE.BLOWON"</tt>), the whole disk must be encrypted:
it decodes any sector you read and encodes anything you write. If that's
not what you wanted, turn encryption off (e.g. <tt>DELETE "IDE.BLOWOFF"</tt>).
<p>Additionally, if encryption is set with <tt>DELETE "IDE.BLOWOUT"</tt>,
subprogram >10 will use encryption or not (both to read and write), according
to what was determined the last time sector 0 was read. This lets you turn
encryption on and off from within a disk manager: first read sector 0,
then the sector you want to access. As it turns out, DISKU's sector editor
always reads sector 0 (to determine what the maximum sector number is)
before it lets you edit another sector, so if you use DISKU encryption
is always turned on/off appropriately after calling <tt>BLOWOUT</tt>.
<p>To sector-edit encrypted files on a non-encrypted disk, you will need
to force encryption with <tt>DELETE "IDE.BLOWON"</tt>. This will of course
cause all non-crypted sectors of the disk (except sectors 0+1) to appear
scrambled!
<p>If you try to access an encrypted disk (as determined by a flag in sector
0) but no password has been entered yet, you will get a disk error. If
you have entered the wrong password, no error is issued but you'll read
only garbage. Note that, as long as you write back exactly what was read,
no data will be lost. Problems only arise when you modify a sector and
save it with the wrong password...
<ol>&nbsp;</ol>

<h4>
<a NAME=">11"></a>>11 Format disk</h4>
This subprogram will NOT format the hard-disk: IDE drives are formatted
in factory and should never be reformatted by the user (it may mess up
the address translation mechanism). What subprogram >11 does is simply
to create a new virtual floppy and add it to your collection..
<p>Input parameters
<br>&nbsp;
<table BORDER >
<caption><tbody>
<br></tbody></caption>

<tr>
<td>>834A</td>

<td COLSPAN="2" WIDTH="80%">-</td>
</tr>

<tr>
<td>>834C</td>

<td>Drive #&nbsp;</td>

<td WIDTH="40%">>A5 flag</td>
</tr>

<tr>
<td>>834E</td>

<td COLSPAN="2" WIDTH="80%">Diskname ptr</td>
</tr>

<tr>
<td>>8350</td>

<td WIDTH="40%">Density (1/2)</td>

<td># of sides (1/2)</td>
</tr>
</table>

<p>Density (1 or 2) and number of sides (1 or 2) are combined so as to
choose among 3 possible sizes:
<br>SS/SD: 360 sectors (90K)
<br>SS/DD and DS/SD: 720 sectors (180K)
<br>DS/DD: 1440 sectors (360K).
<p>Byte >834D should contain >A5 if you wish to pass a diskname in the
buffer pointed at by >834E. The name must be exaclty 10 characters in size,
so pad the string with trailing spaces if necessary. If this name already
exists in your floppy collection, a "file error" is issued. If the first
character in the name is not printable (ascii 33-127) the filename is considered
invalid and IDEAL will coin a dummy filename in the form "!xxxx" where
xxxx is an arbitrarily chosen hexadecimal number. This also happens if
the flag byte >A5 is not found in >834D. This is generally the case when
you use the "format" command of a disk manager: it creates a noname disk
and then names it by modifying sector 0.
<p>Output parameters
<br>&nbsp;
<table BORDER >
<caption><tbody>
<br></tbody></caption>

<tr>
<td>>834A</td>

<td COLSPAN="2" WIDTH="80%"># of sectors per disk</td>
</tr>

<tr>
<td>>834C</td>

<td WIDTH="40%">-</td>

<td WIDTH="40%">-</td>
</tr>

<tr>
<td>>834E</td>

<td COLSPAN="2" WIDTH="80%">-</td>
</tr>

<tr>
<td>>8350</td>

<td COLSPAN="2" WIDTH="80%">Error code</td>
</tr>
</table>

<p>If encryption is on (i.e. <tt>DELETE "IDE.BLOWON"</tt>) the new disk
will be automatically encrypted with the current password. This will not
occur if encryption is set as "output-only" (i.e. <tt>DELETE "IDE.BLOWOUT"</tt>).
<br>&nbsp;
<br>&nbsp;
<h4>
<a NAME=">12"></a>>12 File protection</h4>
This routine is used to modify the protection status of a file, i.e whether
the file can or cannot be deleted and modified.
<p>Input parameters
<br>&nbsp;
<table BORDER >
<caption><tbody>
<br></tbody></caption>

<tr>
<td>>834C</td>

<td WIDTH="40%">Drive #</td>

<td WIDTH="40%">0: unprotected
<br>>FF: protected</td>
</tr>

<tr>
<td>>834E</td>

<td COLSPAN="2" WIDTH="80%">Filename ptr&nbsp;</td>
</tr>

<tr>
<td>>8350</td>

<td COLSPAN="2" WIDTH="80%">-</td>
</tr>
</table>

<p>The filename must be a left-justified, 10-char string. Add as many trailing
spaces as necessary.
<br>&nbsp;
<p>Output parameters
<br>&nbsp;
<table BORDER >
<caption><tbody>
<br></tbody></caption>

<tr>
<td>>834C</td>

<td WIDTH="40%">-</td>

<td WIDTH="40%">-</td>
</tr>

<tr>
<td>>834E</td>

<td COLSPAN="2" WIDTH="80%">-</td>
</tr>

<tr>
<td>>8350</td>

<td COLSPAN="2" WIDTH="80%">Error codes</td>
</tr>
</table>

<br>&nbsp;
<h4>
<a NAME=">13"></a>>13 Rename file</h4>
This routine changes the name of a file on a given drive.
<p>Input parameters
<br>&nbsp;
<table BORDER >
<caption><tbody>
<br></tbody></caption>

<tr>
<td>>834C</td>

<td WIDTH="40%">Drive #&nbsp;</td>

<td WIDTH="40%">-</td>
</tr>

<tr>
<td>>834E</td>

<td COLSPAN="2" WIDTH="80%">New name ptr&nbsp;</td>
</tr>

<tr>
<td>>8350</td>

<td COLSPAN="2" WIDTH="80%">Old name ptr&nbsp;</td>
</tr>
</table>

<p>Filenames must be 10 character strings, with as many trailing spaces
as necessary. Beware that no check is made to ensure that the new name
is a valid filename!
<br>&nbsp;
<p>Output parameters
<br>&nbsp;
<table BORDER >
<caption><tbody>
<br></tbody></caption>

<tr>
<td>>834C</td>

<td WIDTH="40%">-</td>

<td WIDTH="40%">-</td>
</tr>

<tr>
<td>>834E</td>

<td COLSPAN="2" WIDTH="80%">-</td>
</tr>

<tr>
<td>>8350</td>

<td COLSPAN="2" WIDTH="80%">Error codes</td>
</tr>
</table>

<br>&nbsp;
<h4>
<a NAME=">14"></a>>14 File input</h4>
This routine reads data from a file sector-wise, irrespective of its type,
record length, etc. For instance, it can read a "program" file by chunks
of 256 or 512 bytes (or whatever size is convenient).
<p>Input parameters
<br>&nbsp;
<table BORDER >
<caption><tbody>
<br></tbody></caption>

<tr>
<td>>834C</td>

<td WIDTH="40%">Drive #</td>

<td WIDTH="40%"># of sectors</td>
</tr>

<tr>
<td>>834E</td>

<td COLSPAN="2" WIDTH="80%">Filename ptr&nbsp;</td>
</tr>

<tr>
<td>>8350</td>

<td WIDTH="40%">Info ptr (>83xy)</td>

<td WIDTH="40%">-</td>
</tr>
</table>

<p># of sectors: 0 = Get file info (fills the structure below, using data
from the file's FDR)
<br>&lt;>0 = Read this number of sectors (starting from the first sector
indicated in the structure below).
<br>&nbsp;
<table BORDER >
<caption><tbody>
<br></tbody></caption>

<tr>
<td>>83xy</td>

<td COLSPAN="2" WIDTH="80%">VDP buffer address</td>
</tr>

<tr>
<td>+2</td>

<td COLSPAN="2" WIDTH="80%">First sector #</td>
</tr>

<tr>
<td>+4</td>

<td WIDTH="40%">File type</td>

<td WIDTH="40%">Recs / sector</td>
</tr>

<tr>
<td>+6</td>

<td WIDTH="40%">EOF offset</td>

<td WIDTH="40%">Rec lenght</td>
</tr>

<tr>
<td>+8</td>

<td WIDTH="40%"># of rec</td>

<td WIDTH="40%">-</td>
</tr>
</table>

<p>Output parameters
<br>&nbsp;
<table BORDER >
<caption><tbody>
<br></tbody></caption>

<tr>
<td>>834C</td>

<td WIDTH="40%">-</td>

<td WIDTH="40%"># of sectors read</td>
</tr>

<tr>
<td>>834E</td>

<td COLSPAN="2" WIDTH="80%">-</td>
</tr>

<tr>
<td>>8350</td>

<td COLSPAN="2" WIDTH="80%">Error codes</td>
</tr>
</table>

<p>Result of get file info (# of sectors=0):
<br>&nbsp;
<table BORDER >
<caption><tbody>
<br></tbody></caption>

<tr>
<td>>83xy</td>

<td COLSPAN="2" WIDTH="80%">-</td>
</tr>

<tr>
<td>+2</td>

<td COLSPAN="2" WIDTH="80%">-</td>
</tr>

<tr>
<td>+4</td>

<td WIDTH="40%">File type</td>

<td WIDTH="40%">Recs / sector</td>
</tr>

<tr>
<td>+6</td>

<td WIDTH="40%">EOF offset</td>

<td WIDTH="40%">Rec lenght</td>
</tr>

<tr>
<td>+8</td>

<td WIDTH="40%"># of rec</td>

<td WIDTH="40%">-</td>
</tr>
</table>

<h4>
<br>
<a NAME=">15"></a>>15 File output</h4>
This routine writes data to a file sector-wise, irrespective of its type,
record length etc.
<p>Input parameters
<br>&nbsp;
<table BORDER >
<caption><tbody>
<br></tbody></caption>

<tr>
<td>>834C</td>

<td WIDTH="40%">Drive #&nbsp;</td>

<td WIDTH="40%"># of sectors</td>
</tr>

<tr>
<td>>834E</td>

<td COLSPAN="2" WIDTH="80%">Filename ptr&nbsp;</td>
</tr>

<tr>
<td>>8350</td>

<td WIDTH="40%">Info ptr (>83xy)</td>

<td WIDTH="40%">-</td>
</tr>
</table>

<p># of sectors: 0 = Create file (using info in the structure below to
create the FDR)
<br>&lt;>0 = Write this number of sectors (from the first sector indicated
in the structure below).
<br>&nbsp;
<table BORDER >
<caption><tbody>
<br></tbody></caption>

<tr>
<td>>83xy</td>

<td COLSPAN="2" WIDTH="80%">VDP buffer address</td>
</tr>

<tr>
<td>+2</td>

<td COLSPAN="2" WIDTH="80%">First sector #</td>
</tr>

<tr>
<td>+4</td>

<td WIDTH="40%">File type</td>

<td WIDTH="40%">Recs / sector</td>
</tr>

<tr>
<td>+6</td>

<td WIDTH="40%">EOF offset</td>

<td WIDTH="40%">Rec lenght</td>
</tr>

<tr>
<td>+8</td>

<td WIDTH="40%"># of rec</td>

<td WIDTH="40%">-</td>
</tr>
</table>

<p>Output parameters
<br>&nbsp;
<table BORDER >
<caption><tbody>
<br></tbody></caption>

<tr>
<td>>834C</td>

<td WIDTH="40%">-</td>

<td WIDTH="40%"># of sectors writen&nbsp;</td>
</tr>

<tr>
<td>>834E</td>

<td COLSPAN="2" WIDTH="80%">-</td>
</tr>

<tr>
<td>>8350</td>

<td COLSPAN="2" WIDTH="80%">Error codes</td>
</tr>
</table>

<h4>
<br>
>16 and FILES: Number of files</h4>
With the TI floppy disk controller, these two subprograms serve to change
the number of files that can be opened at a time. <tt>CALL FILES(n)</tt>
is used from Basic, and subprogram >16 from assembly. This was necessary
because the DSRs on the floppy controller card used VDP memory to buffer
opened files, and space is quite limited over there (that's where Basic
programs and variables reside, among other things).
<p>The IDE card has its own memory chip and uses it both to store the DSR
and to buffer opened files. Therefore it is not necessary to constantly
jungle with VDP memory usage, and subprogram >16 and FILES are not implemented
in IDEAL.
<p>There is a way to specify how many opened files you allow, when configuring
your system with IDE.CONFIG. By default, this number is 15, so at any given
time you can have upto 15 files opened on the hard-drive.The absolute maximum
value depends on the size of your SRAM.
<h4>
<br>
<a NAME=">B0"></a>>B0 Rambo access</h4>
This subprogram was introduced in the Horizon Ramdisk operating system.
It allows access to Rambo banks, i.e. memory in the area >6000-7FFF. The
subprogram actually consists in 3 subfunctions, selected by the value in
>834C.
<h5>
Page count</h5>

<table BORDER >
<caption><tbody>
<br></tbody></caption>

<tr>
<th>Word</th>

<th>Input&nbsp;</th>

<th>Output&nbsp;</th>
</tr>

<tr>
<td>>834A&nbsp;</td>

<td>0</td>

<td>Available pages</td>
</tr>

<tr>
<td>>834C</td>

<td>0</td>

<td>0</td>
</tr>

<tr>
<td>>8350</td>

<td>-</td>

<td>0: ok
<br>-1: error</td>
</tr>
</table>

<p>Returns the total number of pages available in all Rambo devices.
<p>Important note: if you have an Horizon Ramdisk and an IDE card, you
should run this subprogram this way before you select a given page. It
will let IDEAL bias the page number by whatever pages there are on the
Ramdisk (e.g. if there are 100 pages in the Ramdisk, page 101 is the first
one in the IDE card).
<h5>
<br>
Page selection</h5>

<table BORDER >
<caption><tbody>
<br></tbody></caption>

<tr>
<th>Word</th>

<th>Input&nbsp;</th>

<th>Output&nbsp;</th>
</tr>

<tr>
<td>>834A&nbsp;</td>

<td>-</td>

<td>CRU base</td>
</tr>

<tr>
<td>>834C</td>

<td>Page #&nbsp;</td>

<td>CRU value&nbsp;</td>
</tr>

<tr>
<td>>8350</td>

<td>-</td>

<td>0: ok
<br>-1: error</td>
</tr>
</table>

<p>Selects a given Rambo page. Returns the CRU of the Rambo device in >834A
and the CRU value used in >834C. Note that Rambo pages are not selected
through the CRU with the IDE card, so the value returned in >834C can only
be used to turn Rambo mode on, NOT to switch pages: always use subprogram
>B0 for this.
<h5>
Rambo off</h5>

<table BORDER >
<caption><tbody>
<br></tbody></caption>

<tr>
<th>Word</th>

<th>Input&nbsp;</th>

<th>Output&nbsp;</th>
</tr>

<tr>
<td>>834A&nbsp;</td>

<td>-</td>

<td>-</td>
</tr>

<tr>
<td>>834C</td>

<td>-1</td>

<td>-1</td>
</tr>

<tr>
<td>>8350</td>

<td>-</td>

<td>0</td>
</tr>
</table>

<p>Turns off Rambo mode.
<h4>
<a NAME="Other subs"></a>DSRs used as subprograms</h4>

<ul>
<li>
The DSRs <tt>IDE.BLOWON</tt>, <tt>IDE.BLOWOFF</tt>, <tt>IDE.BLOWOUT</tt>
and <tt>IDE.BLOWAWAY</tt> can also be accessed as subprograms, for instance
with a Basic <tt>CALL</tt>..</li>

<li>
So does the <tt>LD.filename</tt> loader device.</li>

<li>
Conversely, the <tt>CD </tt>subprogram can be called as a DSR.</li>
</ul>

<h2>
<br>
<a NAME="New format"></a>Modifications to the TI disk format</h2>
As far as possible, I have tried to stick to the floppy disk format established
by Texas Instruments. However, I had to make a few modifications to allow
for new features. They are summarized here.
<h4>
Sector 0</h4>
This sector holds the disk directory just like with the TI format, but
most of the reserved bytes have now been put to use. Bytes >EE through
>FF are protected by IDEAL, so they cannot be modified with a sector editor.
<pre><u>Bytes&nbsp;&nbsp; Contents&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</u>>14-15: Time of creation.
>16-17: Date of creation.
>18-19: Time of last modification.
>1A-1B: Date of last modification.
>EE&nbsp;&nbsp; : Flags (>10=archive, >02=encrypted, >04=720 sectors, >08=1440 sectors, >20=protected).
>EF&nbsp;&nbsp; : Node balance (>FF=heavy left, >00=balanced, >01=heavy right, >80=deleted).
>F0-F1: Number of items in the left subtree.
>F2-F5: LBA of left subtree(>0000 0000 if none).
>F6-F9: LBA of right subtree (ditto).
>FA-FD: LBA of parent directory (ditto).
>FE-FF: Sector # for FDR of pointer file on parent directory.</pre>
N.B. Sector 1 follows the TI format with no modification: it lists the
sector numbers for the FDR of all files, in alphabetical order. The list
must finish with a >0000, thus there can be only 127 files on a given disk.
<h4>
File Descriptor Records (FDRs)</h4>
There is one such sector for each file, that contains all the relevant
file informations. These are the sectors listed in sector 1. The following
modifications were introduced.
<pre><u>Bytes&nbsp;&nbsp; Contents&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</u>>0A&nbsp;&nbsp; : Flags (>10=acrchive bit, >02=Encrypted, >08=directory pointer).
>14-15: Time of creation.
>16-17: Date of creation.
>18-19: Time of last modification.
>1A-1B: Date of last modification.</pre>

<h4>
Directory pointer files</h4>
A directory pointer is nothing more than an empty file, consisting of only
the FDR. It follows the new FDR format described above. There are some
extra modifications to allow chaining of all pointer files that refer to
the same directory.
<pre><u>Bytes&nbsp;&nbsp; Contents&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</u>>20-23: LBA of the current disk (i.e. of sector 0).
>24-27: LBA of sector 0 for previous link.
>28-29: Sector number for previous link.
>2A-2D: LBA of sector 0 for next link.
>2E-2F: Sector number for next link.
>30-31: Number >0000 (used to detect when it's encrypted).</pre>

<address>
Revision 1. 7/28/00. Preliminary, not for release.</address>

<address>
Revision 2. 5/28/01. Ok to release (about time!).</address>

<address>
Revision 3. 8/25/01. Minor modifications to "Getting started".</address>

<address>
Revision 4. 4/14/04. Modified for the new version of the IDE card, and
bug fixes.</address>

<address>
Revision 5.7/6/04. Final polishing. Ok to release.</address>

<address>
Revision 6. 9/14/04. Added info on errors with IDELOAD, corrected typos.</address>

<address>
Revision 7. 10/17/04. Corrected floppy creation example. Added IDEDIAG.</address>

<ul>&nbsp;
<center>
<p><a href="titechpages.htm">Back to the TI-99/4A Tech Pages</a></center>
</ul>

</body>
</html>
