<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
  <title></title>
  <meta name="Author" content="">
  <meta name="GENERATOR"
 content="Mozilla/3.04Gold (Win95; U) [Netscape]">
</head>
<body>
<h1 align="center"><a
 href="http://www.nouspikel.com/ti99/titechpages.htm"><img
 src="logo.jpg" style="border: 0px solid ; height: 33px; width: 95px;"
 title="" alt=""></a></h1>
<h1>Blowfish encryption</h1>
<p>This page discusses an assembly language implementation of the
encryption
algorithm known as Blowfish.</p>
<p><a href="#intro">Introduction<br>
</a><a href="#xor%20and%20modulo%20add">Bitwise XOR and modulo additions<br>
</a><a href="#Feistel%20network">Feistel network<br>
</a><a href="#the%20function%20F">The function F<br>
</a><a href="#Encode%20and%20decode">Encoding and decoding routines<br>
</a><a href="#key%20generation">Key generation<br>
</a><a href="#Test">Testing<br>
</a><a href="#Refs">References</a></p>
<h3><br>
<a name="intro"></a>Introduction</h3>
<p>Blowfish is a fast and secure encryption algorithm, designed by B.
Schneier
in 1993. Since that time it has never been cracked, in spite of
numerous
attempts. It is designed for speed, by using only simple operations
like
additions and bitwise exclusive or (XOR). Its speed and strength are
due
to the fact that it uses a huge key, over 4 Kbytes of random numbers!
Obviously,
it is impossible to memorize such a key, but the Blowfish designer
provided
an elegant solution: a unique key is selected once and for all, and
subsequently
altered by a password of your choice. The alteration is performed via
repeted
rounds of Blowfish encryption, in other words the key encodes itself.
This
self-encoding process is a bit lengthy but only needs to be performed
once
per session.</p>
<h3><br>
<br>
<a name="xor and modulo add"></a>Bitwise XOR and modulo additions</h3>
<p>Before we go further, let me discuss briefly the two mathematical
operations
that are at the heart of Blowfish: modulo additions and bitwise XOR.</p>
<p><b>Modulo additions</b> simply means that there is a maximum value
that
cannot be trespassed. If the result of the addition is greater than
this
value, it "wraps aroud" and restart from zero. For instance,
additions modulo 2<sup>16</sup> are 16-bits additions: &gt;F000 +
&gt;2002
should be &gt;11002, but because only 16 bits are allowed, the result
is
&gt;1002 instead. Blowfish uses modulo 2<sup>32</sup> additions, which
means the greatest possible value is &gt;FFFFFFFF.</p>
<p><b>A bitwise exclusive OR</b> compares two numbers bit-by-bit: when
the two bits are identical the corresponding bit in the result os 0,
when
the bits are different the result is 1. In other words, the truth table
is: 0 xor 0 = 0, 0 xor 1 = 1, 1 xor 0 = 1, 1 xor 1 = 0.</p>
<p>XOR is a commonly used encryption tool, as it very effectively
mangles
the original value (aka plaintext):</p>
<pre>    &gt;00100110 (plaintext: &gt;46 or 'F')<br>xor <u>&gt;10110010</u> (key: &gt;B2)<br>    &gt;11010100 (ciphertext: &gt;D4)</pre>
<p>XOR is commutative, so the plaintext can be retrieved by just XORing
the ciphertext with the key again:</p>
<pre>    &gt;11010100 (ciphertext: &gt;D4)<br>xor <u>&gt;10110010</u> (key: &gt;B2)<br>    &gt;00100110 (plaintext: &gt;46)</pre>
<p>Unfortunately it is also associative, so if an adversary manages to
guess one word in the plaintext, he can obtain the key by combining
plantext
and ciphertext:</p>
<pre>    &gt;00100110 (plaintext: &gt;46)<br>xor <u>&gt;11010100</u> (ciphertext: &gt;D4)<br>    &gt;10110010 (key: &gt;B2)<br></pre>
<p>Several strategies are possible to overcome this problem, by
combining
XORs in more complex functions.</p>
<h3><br>
<a name="Feistel network"></a>Feistel network</h3>
<p>Blowfish is is a block cipher, which means that is operates on
blocks
of a fixed size (64 bits, or 8 bytes) that are encoded independently
from
each other. It is based on a Feistel network, an algorithm that
operates
as follows:</p>
<li>Given a 64-bit value X, split it in two 32-bit parts: Xl (leftmost
4 bytes) and Xr (rightmost 4 bytes).</li>
<li>Do Xr = Xr xor F(Xl)</li>
<li>Do Xl = Xl xor F(Xr)</li>
<p>The function F will be discussed later, for the moment being it is
sufficient
to know that it returns an arbitrary number that depends on the value
of
its argument.</p>
<p>It is easy to see that the above algorithm is symetrical and can be
taken backwards to decipher the ciphertext. To make the code harder to
brake, the process is repeated 8 times. In addition, at each step Xl
and
Xr are XORed with arbitrarily chosen random numbers, that change at
each
pass. These numbers are stored in an array called P that contains
eighteen
32-bit numbers and forms one part of the key (there are 18 values
instead
of 16 because an extra XOR is performed after the last step).</p>
<p>The algorithm thus become:</p>
<ul>
  <li>Split the plain 64-bit value X in two 32-bit halves: Xl and Xr</li>
  <li>For i = 1 to 16 do</li>
  <ul>
    <li>Xl = Xl xor P[i]</li>
    <li>Xr = Xr or F(Xl)</li>
    <li>Swap Xl and Xr</li>
  </ul>
  <li>Undo the last swap</li>
  <li>Xr = Xr xor P[17]</li>
  <li>Xl = Xl xor P[18]</li>
  <li>Recombine Xl and Xr into a ciphered 64-bit value</li>
</ul>
<p><br>
To decode the final value back to the original one, the same method is
used, except that the array P is walked backwards:</p>
<ul>
  <li>Split the ciphered 64-bit value X in two 32-bit halves: Xl and Xr</li>
  <li>For i =18 to 3 step -1 do</li>
  <ul>
    <li>Xl = Xl xor P[i]</li>
    <li>Xr = Xr or F(Xl)</li>
    <li>Swap Xl and Xr</li>
  </ul>
  <li>Undo the last swap</li>
  <li>Xr = Xr xor P[2]</li>
  <li>Xl = Xl xor P[1]</li>
  <li>Recombine Xl and Xr into a plain 64-bit value</li>
</ul>
<p>Elegant, isn't it?</p>
<h3><br>
<a name="the function F"></a>The function F</h3>
<p>Before we get to this mysterious function F, let me introduce two
important
cryptographic concepts: one-way functions and non-linearity.</p>
<p>A <b>one way function</b> is a function where it is very easy to
calculate
F(x) given x, but very difficult, if at all possible, to work backwards
and get x from F(x). A naive exemple would be: y = x<sup>2 </sup>It is
easy to square a number, but much harder to extract its square root. Of
course, real-world one-way functions are more complex than this, but
you
get the idea.</p>
<p><b>Non-linearity</b> means that even a tiny change in the key
results
in major changes in the ciphertext. It is important so that an
adversary
does not get the feeling that "it begins to make sense" as he
guesses more and more letters in your password. Ideally, even if he has
all characters correct but for a single bit, the ciphertext should
still
be just as mystifying as if he had it all wrong.</p>
<p>A good way to achieve non-linearity is to use S boxes. A S box is
nothing
else than an array of randomly chosen numbers. A non-linear function
may
just return S[x], i.e. the element at position x in the array. Since
these
elements are chosen at random, chances are that two neighbouring
elements
have vastly different values. In addition, this is also a one-way
function
since a given number may appear at several places in the array: given
this
value it is impossible to tell which element was the one that returned
it.</p>
<p>There is one problem with this approach though: remember that the
function
F in Blowfish takes a 32-bit number as an argument and returns another
32-bit number. If the function was to perform a simple array lookup we
would need a S box containing 4 billions 32-bit numbers! To overcome
this
problem, the function F in Blowfish breaks up the 32-bit input
parameter
in 4 bytes. Each byte is used to fetch a 32-bit number from a different
S box (S1 through S4), and the four numbers are combined with additions
and XOR operations. Blowfish uses four S boxes to avoid the symetry
problems
that could occur for numbers like &gt;11112222 if only one box were
used.
Together with the P box, the four S boxes make up the encryption key.</p>
<p>The algorithm for function F is:</p>
<li>Given a 32-bit value X, break it in 4 bytes: a, b, c and d.</li>
<li>Return (( S1[a] + S2[b] ) xor S3[c] ) + S4[d]</li>
<p>Note how fast and easy it is to obtain F(x) from x: only 4 lookups,
two additions (modulo 2<sup>32</sup>) and an exclusive or. By contrast,
given F(x) it is very hard to figure out what the value of x was. It
may
even be impossible, as F may return the same number for different
values
of x. Thus F is a non-linear, one-way function.</p>
<h3><br>
<a name="Encode and decode"></a>Encoding and decoding routines</h3>
<p>With all this theory behind us, it is now time for some assembly
code.
Here is my implementation of the coding and decoding functions for
Blowfish.
Note that they have been optimised for speed: they almost exclusively
use
registers and my advise would be to use a workspace located in the fast
scratch-pad memory, such as &gt;8300. For the same reason, I did not
implement
F as a distinct function, but rather integrated it into each routine.
This
saves us the 16 calls and return operations. To further speed up these
routines, you may "open the loop", viz copy F 16 times in a row
instead of using a counter. This way, you don't even need to swap Xr
and
Xl, and you save the time needed to decrement a counter, test it, and
jump
back to the beginning of the loop.</p>
<h4>Encrypting 64 bits</h4>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre>*---------------------------------------------------------------------<br>* Encryption routine. R1=input ptr (plain), R2=output ptr (ciphered)<br>*---------------------------------------------------------------------<br>ENCOD8 MOV  *1+,5             get xL<br>       MOV  *1+,6<br>       MOV  *1+,7             get xR<br>       MOV  *1+,8<br> <br>       CLR  3                 iteration counter i<br>LP1    XOR  @P(3),5           xL xor P[i]<br>       XOR  @P+2(3),6<br> <br>       MOV  5,4               function F(x)<br>       SRL  4,8               -------------<br>       SLA  4,2               make 1st byte a pointer <br>       MOV  @S1(4),9          into an array of 32-bit dwords<br>       MOV  @S1+2(4),10       get 32-bit dword<br> <br>       MOV  5,4               second byte b<br>       SLA  4,8<br>       SRL  4,6               pointer into a second array<br>       A    @S2+2(4),10       32-bit addition<br>       JNC  SK1<br>       INC  9                 carry to leftmost word<br>SK1    A    @S2(4),9<br> <br>       MOV  6,4               third byte c<br>       SRL  4,8<br>       SLA  4,2               pointer into a third array<br>       XOR  @S3(4),9<br>       XOR  @S3+2(4),10       xor with previous result<br> <br>       MOV  6,4               fourth byte d<br>       SLA  4,8<br>       SRL  4,6               pointer into a fourth array<br>       A    @S4+2(4),10       32-bit addition<br>       JNC  SK2<br>       INC  9                 carry to leftmost word<br>SK2    A    @S4(4),9          F(abcd) = S1[a] + S2[b] xor S3[c] + S4[d]<br> <br>       XOR  7,9<br>       XOR  8,10              xR xor F(xL) = new xR<br> <br>       MOV  5,7               swap xL with xR<br>       MOV  6,8<br>       MOV  9,5<br>       MOV  10,6<br> <br>       C    *3+,*3+           4 bytes per entry<br>       C    3,@PASS<br>       JL   LP1               repeat 16 times<br> <br>       XOR  @P+64,5           xR xor P17<br>       XOR  @P+66,6<br>       XOR  @P+68,7           xL xor P18<br>       XOR  @P+70,8<br> <br>       MOV  7,*2+             encoded xL<br>       MOV  8,*2+<br>       MOV  5,*2+             encoded xR<br>       MOV  6,*2+<br>       B    *11<br>*<br>PASS   DATA 16*4              number of passes</pre>
      </td>
    </tr>
  </tbody>
</table>
<h4>Decrypting 64 bits</h4>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre>*---------------------------------------------------------------------<br>* Encryption routine. R2=input ptr (ciphered), R1=output ptr (plain)<br>*---------------------------------------------------------------------<br>DECOD8 MOV  *2+,5             get xL<br>       MOV  *2+,6<br>       MOV  *2+,7             get xR<br>       MOV  *2+,8<br> <br>       MOV  @PASS,3           iteration counter i<br>LP3    XOR  @P+4(3),5         xL xor Pi<br>       XOR  @P+6(3),6<br> <br>       MOV  5,4               function F(x)<br>       SRL  4,8               -------------<br>       SLA  4,2               make 1st byte a pointer<br>       MOV  @S1(4),9          into an array of 32-bit dwords<br>       MOV  @S1+2(4),10       get 32-bit dword<br> <br>       MOV  5,4               second byte b<br>       SLA  4,8<br>       SRL  4,6               ptr into a second array<br>       A    @S2+2(4),10       32-bit addition<br>       JNC  SK3<br>       INC  9                 carry to leftmost word<br>SK3    A    @S2(4),9<br> <br>       MOV  6,4               third byte c<br>       SRL  4,8<br>       SLA  4,2               ptr into a third array<br>       XOR  @S3(4),9<br>       XOR  @S3+2(4),10       xor with previous result<br> <br>       MOV  6,4               fourth byte d<br>       SLA  4,8<br>       SRL  4,6               ptr into a fourth array<br>       A    @S4+2(4),10       32-bit addition<br>       JNC  SK4<br>       INC  9                 carry to leftmost word<br>SK4    A    @S4(4),9          F(abcd) = S1[a] + S2[b] xor S3[c] + S4[d]<br> <br>       XOR  7,9<br>       XOR  8,10              xR xor F(xL) = new xR<br> <br>       MOV  5,7               swap xL with xR<br>       MOV  6,8<br>       MOV  9,5<br>       MOV  10,6<br> <br>       AI   3,-4              4 bytes per entry<br>       JGT  LP3               repeat 16 times<br> <br>       XOR  @P+4,5            xR xor P1<br>       XOR  @P+6,6<br>       XOR  @P+0,7            xL xor P0<br>       XOR  @P+2,8<br> <br>       MOV  7,*1+             encoded xL<br>       MOV  8,*1+<br>       MOV  5,*1+             encoded xR<br>       MOV  6,*1+<br>       B    *11</pre>
      </td>
    </tr>
  </tbody>
</table>
<h3><br>
<a name="key generation"></a>Key generation</h3>
<p>If you followed the theoretical part above, you will have noted that
Blowfish uses a really large key: a P box containing 18 32-bit numbers
and four S boxes, each with 256 entries. All this adds up to 4168
bytes.
What we need now is a way to generate these boxes from a simple, easy
to
remember, password.</p>
<p>To do this, we'll first start with an arbitrary set of random values
in the boxes. By convention these are the decimals of Pi, but any suite
of random numbers will do. The nice thing with Pi is that, if you loose
the source code, you can always reconstitute it. Also, you can verify
that
the numbers provided are indeed the decimals of Pi and not values
carefully
selected by a devious programmer so as to leave a weakness in your
encryption
scheme, a backdoor that will allow him (or the government) to easily
decrypt
all your messages...</p>
<p>Second, we'll XOR your password over the bytes in the P box. Your
password
should be at most 56 characters (I don't know why it cannot be longer).
If it's shorter it will be repeated over and over again, until all the
bytes in the P box have been XORed with a letter from your password.</p>
<p>Third, we'll Blowfish-encode an arbitrary chosen 64-bit value, using
the P and S boxes that we just created. By convention, the value chosen
is &gt;0000000000000000. The ciphered result will replace the first 4
bytes
in the P box. This ciphered value is then Blowfished again, using the
new
version of the key, and the result replaces the next 4 bytes in the P
box.</p>
<p>The process is repeated 521 times, so as to replace each entry in
the
P box, then in the four S boxes. Each time, the new ciphered value is
encoded
again, using the version of the key that it has just created. The whole
process is quite lengthy, and takes about 3 seconds with the routine
below.</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre>*---------------------------------------------------------------------<br>* Key generation<br>*---------------------------------------------------------------------<br>INIKEY LWPI &gt;8300             use workspace in PAD for speed<br> <br>       LI   2,P               first step: fill boxes with random digits<br>       LI   1,PI              ----------  here: the decimals of PI<br>LP7    MOV  *1+,*2+<br>       CI   2,EOS4<br>       JL   LP7<br> <br>       LI   2,P               second step: xor password with P box<br>       LI   1,KEY             -----------<br>       MOVB *1+,0             size of password (could truncate to 56)<br>       SRL  0,8               make it a word<br>       JEQ  WIPE              0: erase current key<br> <br>LP5    MOVB *1+,3             get 1 char<br>       SWPB 3<br>       DEC  0                 end of password?<br>       JNE  SK6<br>       LI   1,KEY             yes: restart from beginning<br>       MOVB *1+,0             get size<br>       SRL  0,8<br>SK6    MOVB *1+,3             get another char<br>       SWPB 3<br>       DEC  0                 end of password?<br>       JNE  SK7<br>       LI   1,KEY             yes: restart from beginning<br>       MOVB *1+,0<br>       SRL  0,8<br>SK7    XOR  *2,3              xor password with P box<br>       MOV  3,*2+<br>       CI   2,S1<br>       JNE  LP5               next word in P box<br> <br>       LI   1,NULL            third step:  self-encode P + S boxes<br>       LI   2,P               ----------<br>LP6    BL   @ENCOD8           encode it, put new value in box <br>       MOV  2,1<br>       AI   1,-8              re-encode the new value <br>       CI   2,EOS4            until all boxes are full<br>       JL   LP6<br>       JMP  RETURN            done<br>*<br>*---------------------------------------------------------------------<br>* Wipe out current key<br>*---------------------------------------------------------------------<br>WIPE   LI   1,P<br>LP8    CLR  *1+               clear all boxes<br>       CI   1,EOS4<br>       JL   LP8<br> <br>RETURN LWPI &gt;20BA             back to caller workspace<br>       B    *11<br>*<br>*---------------------------------------------------------------------<br>* Data area<br>*---------------------------------------------------------------------<br>NULL   DATA 0,0,0,0           null string<br> <br>KEY    BYTE 11                password length<br>       TEXT 'My password'     password<br>       BSS  45                max 56 characters<br><br>       COPY "DSK4.PI/S"       this file contains the digits of PI<br> <br>P      BSS  72                room for custom-made key<br>S1     BSS  1024<br>S2     BSS  1024<br>S3     BSS  1024<br>S4     BSS  1024<br>EOS4</pre>
      </td>
    </tr>
  </tbody>
</table>
<p>Note that I also wrote a tiny routine to wipe the key out of memory,
just for security purposes.</p>
<p>Oh, and <a href="pi_s.txt">here</a> are the decimals of Pi (in
hexadecimal).</p>
<h3><br>
<a name="Test"></a>Testing</h3>
<p>Finally, here are some test routines. They encode 512 bytes in an
arbitrary
chosen buffer.</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre>       DEF  ENCODE,DECODE,INIKEY,WIPE<br> <br>TEST   EQU  &gt;D000<br>ENDOT  EQU  &gt;D200</pre>
      <pre>*---------------------------------------------------------------------<br>* Encode 512 bytes into a test buffer<br>*---------------------------------------------------------------------<br>ENCODE LWPI &gt;8300             use fast workspace<br>       LI   1,TEST            ptr to test buffer<br>LP2    MOV  1,2               overwrite it with ciphered version<br>       BL   @ENCOD8           encode 8 bytes<br>       CI   1,ENDOT           are we done?<br>       JL   LP2               not yet<br>       JMP  RETRN<br>*<br>*---------------------------------------------------------------------<br>* Decode 512 bytes from a test buffer<br>*---------------------------------------------------------------------<br>DECODE LWPI &gt;8300             use fast workspace<br>       LI   2,TEST            ptr to test buffer<br>LP4    MOV  2,1               overwrite with deciphered version<br>       BL   @DECOD8           decode 8 bytes<br>       CI   2,ENDOT           are we done?<br>       JL   LP4               not yet<br><br>RETRN  LWPI &gt;20BA             back to caller workspace<br>       B    *11<br>*<br>       END</pre>
      </td>
    </tr>
  </tbody>
</table>
<p>To test:</p>
<li>Load the program.</li>
<li>Run INIKEY, then ENCODE.</li>
<li>Exit the program and make sure the content of the buffer is now
scrambled.</li>
<li>Load the program again, run INIKEY, then DECODE. </li>
<li>Check if the content of the buffer is back to what it was.<br>
  <br>
</li>
<h3><a name="Refs"></a>References</h3>
<p>B.&nbsp;Schneider. <i>Description of a New Variable-Length Key,
64-Bit
Block Cipher (Blowfish)</i>. Fast Software Encryption, Cambridge
Security
Workshop Proceedings (December 1993). Springer Verlag, 1994, pp.
191-204.</p>
<p>B Schneider's company website: <a href="http://www.counterpane.com">http://www.counterpane.com</a></p>
<p>A Blowfish implementation in C language by Paul Kosher
(pck@netcom.com),
found at the above website.</p>
<address><br>
<br>
Revision 1. 6/14/00. Ok to release.<br>
</address>
<center>
<p><br>
<a href="titechpages.htm">Back to the TI-99/4A Tech Pages</a></p>
</center>
</body>
</html>
