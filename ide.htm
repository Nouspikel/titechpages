<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
  <title></title>
  <meta name="Author" content="">
  <meta name="GENERATOR"
 content="Mozilla/3.04Gold (Win95; U) [Netscape]">
</head>
<body>
<h1 align="center"><a
 href="http://www.nouspikel.com/ti99/titechpages.htm"><img
 src="logo.jpg" style="border: 0px solid ; height: 33px; width: 95px;"
 title="" alt=""></a></h1>
<h1>IDE interface card (prototype)</h1>
Click <a href="ide2.htm">here</a> for the "production" version of this
card.<br>
<p>Building a hard drive controller card for my TI-99/4A has long been
a dream of mines. Unfortunately, it was far beyond my abilities. And
yet,
here it is: I finally made it! Not that I suddenly became more
knowledgeable
in electronics, but because the IDE standard made things so much
easier.
You see, with IDE (Integrated Drive Electronics, or is it Intelligent
Drive
Electronics?) the controller is part of the hard disk. All I had to do
was to design an adapter to make the PE-box bus look like a PC bus. And
that's fairly easy. It would even be trivial if Texas Instruments had
not
crippled the PE-box by multiplexing the TMS9900 16-bit bus to 2 times 8
bits. As it is, we'll need a <b>demultiplexer</b>, but that's not too
complicated:
just a few TTL chips.</p>
<p>The nice thing with IDE is that these days everybody swears by
gigabytes-wide
SCSI drives, so it is really easy to find very cheap "small"
IDE drives. I bought a 540 Megs drive for $18, to give you an idea. And
540 Megs is equivalent to about 6000 floppies! This interface card
supports
<b>two IDE drives</b>. It may also work with CD-ROMs but you'll have to
write your own control program.</p>
<p>While I was at it, I also included a 32K to 512K <b>SRAM memory </b>chip
on the card. It serves to hold the DSRs and the buffers for opened
files.
The memory is also available to the user in the area &gt;6000-7FFF,
according
to the RAMBO protocol introduced with the Horizon Ramdisk.</p>
<p>Last but not least, the card comprises a <b>real-time clock</b>.
This
allows the software to time-stamp the files, which is something I
always
missed with the TI-99/4A. And the clock chip I selected also contains
4K
of battery-backed memory, so we can stuff the DSRs in there, to be
transfered
in the SRAM at power-up time. This saves us the trouble of having a
battery-backed
SRAM.</p>
<p>I have no intention to market that card, but if you want to build
your
own you'll find all the necessary instructions in this page. That's
fairly
easy to do too: after all I did it and I'm no EE, nor especially good
at
handywork... You can also download the operating system (and its
instruction
manual), tentatively named <a href="ideal.htm">IDEAL</a> for "IDE
Access Layer". </p>
<p>Here is an annotated <a href="idecard.htm">picture</a> of the
prototype
board I built. Note that this point-to-point soldering on a pre-etched
perf board is a bit messy: this awful rat's nest creates quite a bit of
resonnance between wires. I have been plagued by glitches that generate
spurious read operations when the ultra-fast IDE controller mistakes
them
for a data access. I was able to control them by placing a capacitor on
the MEMEN* line, but still I strongly recommend that you etch a PCB...</p>
<p>Here is a detailed <a href="ide.zip">schematic</a>. To view it you
will
need a program called PC-Trace which can be freely downloaded from <a
 href="http://www.eesoft.com">www.eesoft.com</a>
(it will also let you create a PCB, but to print it out you'll have to
fork out a registration fee). The specific sections of the circuit are
described in details further down this page.</p>
<p>Please, let me know if you built such a card and if you're happy
with
it. Suggestions for improvements, and software bug reports are always
appreciated.<br>
</p>
<p><img src="award2.gif" alt="2001 Mauk Award" hspace="10" height="112"
 width="88" align="middle">I'm
proud to announce that this card was granted the 2001 Edgar Mauk award,
in the category "hardware".</p>
<h4><font color="#ff0000">Legal disclaimer. Read this first.</font></h4>
<p><font size="-2">The contents of this webpage are for educative
purposes
only. I'm not an electrical engineer, I have little knowledge of
electronics
and therefore cannot guaranty that the device described in this
document
as an IDE interface card will function properly. In fact, it probably
won't.
It may even cause damage to your computer. And quite possibly catch on
fire and burn your house to ashes, sending toxic fumes in the whole
neighbourhood.
Actually, it may even kill you. So if you know where your interest it,
don't build it! Don't even think of it. Furthermore, building the
aforementionned
device may constitute a copyright violation, an infringement on FCC
regulations,
a federal crime or whatever it is called in the country you live in.
You
have been warned! By reading this page further and/or building the
electronic
device described herein, you agree on taking whole legal and moral
responsability
for any disapointment, loss of data, damage, accident, catastrophe, or
apocalypse that this device may directly or indirectly cause or favor.
And if you were thinking of suing me, forget it. I may have an MD but
I'm
only a scientist: I don't have any money.</font></p>
<p><font size="-2">The design detailed below is copyrighted by me,
Thierry&nbsp;Nouspikel,
till the end of time or 50 years after my death, whichever occurs
first.
I grant you the right (but not the exclusive rights) to produce and
even
market as many of these as you want, as long as you understand that I
take
no responsability for it. If you market them, be sure to include my
copyright
and a link to the present webpage. </font></p>
<p><br>
<br>
<b><font size="+1">Hardware<br>
<br>
</font></b><a href="#Components">Components<br>
</a><b>Card circuitery<br>
</b><a href="#Power">Power supply<br>
</a><a href="#Bus%20buffers">Bus buffering<br>
</a><a href="#CRU%20logic">CRU logic<br>
</a><a href="#Addressing">Address mapping<br>
</a><a href="#SRAM%20logic">SRAM access<br>
</a><a href="#Clock%20logic">Clock access<br>
</a><a href="#IDE%20logic">IDE port access<br>
</a><b>RTC-65271<br>
</b><a href="#RTC%20pinout">Pinouts<br>
</a><a href="#Batteries">Batteries<br>
</a><a href="#RTC%20registers">Registers<br>
</a><a href="#XRAM">XRAM<br>
</a><a href="#Time%20and%20date">Time &amp; date<br>
</a><a href="#alarms">Alarms<br>
</a><a href="#square%20wave">Square wave<br>
</a><a href="#Timing%20diagrams">Timing diagrams<br>
</a><a href="#Electrical">Electrical characteristics<br>
</a><b>IDE interface<br>
</b><a href="#IDE%20pinouts">Cable pinouts<br>
</a><a href="#IDE%20registers">Registers<br>
</a><a href="#IDE%20commands">Commands<br>
</a><a href="#Operating%20the%20IDE%20controller">Operating the IDE
controller<br>
</a><a href="#LBA%20vs%20CSH">LBA vs CSH<br>
</a><a href="#DMA">DMA<br>
</a><a href="#Drive%20considerations">Drives</a></p>
<p><br>
<b><font size="+1">Software</font></b></p>
<p><a href="#CRU%20map">CRU map<br>
</a><a href="#Memory%20map">Memory map<br>
</a><a href="#Low-level">Low-level access<br>
</a><a href="#High%20level">High-level access</a><br>
</p>
<h2>
<hr width="100%">Hardware</h2>
<h4><a name="Components"></a>Components required</h4>
<p>As I said, I'm not selling this board, not even as a kit. This table
is only meant to give you an idea of what it would cost to build the
card.
</p>
<table border="1">
  <tbody>
    <tr>
      <th>#</th>
      <th>Component</th>
      <th>Description</th>
      <th>Price </th>
    </tr>
    <tr>
      <td>5</td>
      <td>74LS244</td>
      <td>8-bit buffer, 3-state</td>
      <td>$0.55</td>
    </tr>
    <tr>
      <td>1</td>
      <td>74LS245</td>
      <td>8-bit transceiver, 3-state </td>
      <td>$0.55</td>
    </tr>
    <tr>
      <td>1</td>
      <td>74LS125</td>
      <td>4-bit buffer</td>
      <td>$0.33</td>
    </tr>
    <tr>
      <td>1</td>
      <td>74LS85</td>
      <td>4-bit comparator</td>
      <td>$0.42</td>
    </tr>
    <tr>
      <td>1</td>
      <td>74LS688</td>
      <td>8-bit comparator </td>
      <td>$1.30</td>
    </tr>
    <tr>
      <td>1</td>
      <td>74LS259</td>
      <td>8-bit addressable latch </td>
      <td>$0.71</td>
    </tr>
    <tr>
      <td>1</td>
      <td>74LS251</td>
      <td>8-to-1 multiplexer </td>
      <td>$0.62</td>
    </tr>
    <tr>
      <td>1</td>
      <td>74LS138</td>
      <td>3-to-8 decoder</td>
      <td>$0.58</td>
    </tr>
    <tr>
      <td>1</td>
      <td>74LS139</td>
      <td>Dual 2-to-4 decoders</td>
      <td>$0.40</td>
    </tr>
    <tr>
      <td>3</td>
      <td>74LS373</td>
      <td>8-bit latch, 3-state</td>
      <td>$0.55</td>
    </tr>
    <tr>
      <td>2</td>
      <td>74LS32</td>
      <td>Quad OR gates</td>
      <td>$0.24</td>
    </tr>
    <tr>
      <td>1</td>
      <td>74LS02</td>
      <td>Quad NOR gates</td>
      <td>$0.44</td>
    </tr>
    <tr>
      <td>1</td>
      <td>74LS08</td>
      <td>Quad AND gates</td>
      <td>$0.44</td>
    </tr>
    <tr>
      <td>2</td>
      <td>74LS04</td>
      <td>Hex inverters</td>
      <td>$0.22</td>
    </tr>
    <tr>
      <td>1</td>
      <td>RTC65271</td>
      <td>Real-time clock + RAM</td>
      <td>$1.50</td>
    </tr>
    <tr>
      <td>2</td>
      <td>BR1225</td>
      <td>+3V lithium batteries</td>
      <td>$1.00</td>
    </tr>
    <tr>
      <td>1</td>
      <td>HM628512 <br>
(or equivalent) </td>
      <td>SRAM, 32K to 512 Kbytes </td>
      <td>$2.00 -<br>
$12.00</td>
    </tr>
    <tr>
      <td>1</td>
      <td>7805CT</td>
      <td>+5V voltage regulator, 1 Amp</td>
      <td>$0.50</td>
    </tr>
    <tr>
      <td>1</td>
      <td><br>
      </td>
      <td>Heat sink for TO-220</td>
      <td>$0.80</td>
    </tr>
    <tr>
      <td>1</td>
      <td><br>
      </td>
      <td>Hex DIP-switch</td>
      <td>$0.25</td>
    </tr>
    <tr>
      <td>1</td>
      <td><br>
      </td>
      <td>SPST switch </td>
      <td>$0.56</td>
    </tr>
    <tr>
      <td>1</td>
      <td><br>
      </td>
      <td>6 x 10K resistors network (or 6 1K resistors) </td>
      <td>$0.30</td>
    </tr>
    <tr>
      <td>1</td>
      <td><br>
      </td>
      <td>8 x 4.7K resistor network (or 8 1K resistors) </td>
      <td>$0.30</td>
    </tr>
    <tr>
      <td>2</td>
      <td><br>
      </td>
      <td>4.7K resistor</td>
      <td>$0.05</td>
    </tr>
    <tr>
      <td>2</td>
      <td><br>
      </td>
      <td>Resistors 220 Ohms</td>
      <td>$0.05</td>
    </tr>
    <tr>
      <td>22</td>
      <td><br>
      </td>
      <td>Ceramic capacitors, 100 nF</td>
      <td>$0.11</td>
    </tr>
    <tr>
      <td>1</td>
      <td><br>
      </td>
      <td>Electrolytic capacitor, 22 uF, 50V</td>
      <td>$0.55</td>
    </tr>
    <tr>
      <td>2</td>
      <td><br>
      </td>
      <td>LEDs (light-emmiting diodes). 1 yellow, 1 red</td>
      <td>$0.10</td>
    </tr>
    <tr>
      <td>1</td>
      <td><br>
      </td>
      <td>IDE connector (or 2 x 15-pin headers)</td>
      <td>$1.00</td>
    </tr>
    <tr>
      <td>1</td>
      <td><br>
      </td>
      <td>Printed circuit board</td>
      <td>$15.00</td>
    </tr>
    <tr>
      <td>1</td>
      <td><br>
      </td>
      <td>IDE cable</td>
      <td>$2.95</td>
    </tr>
    <tr>
      <td>1</td>
      <td><br>
      </td>
      <td>IDE hard drive, 540 Meg</td>
      <td>$17.50</td>
    </tr>
  </tbody>
</table>
<p>Total: components $20-$30 depending on the SRAM. Plus board + hard
drive.
About $60. Could be cheaper if you look around for a good deal on the
expensive
parts (SRAM, board and drive).</p>
<h4><br>
Souces</h4>
<li>Digi-key Corporation (www.digikey.com)</li>
<li>BG-Micro (www.bgmicro.com)</li>
<li>All Electronics Corporation (www.allelectronics.com)</li>
<li>Fry's Electronics</li>
<li>Haltek surplus (out of business, but may come back...)</li>
<li>Halted surplus, aka HSC (www.halted.com)</li>
<h3><br>
<a name="Power"></a>IDE card circuitery</h3>
<h4>Power supply</h4>
<table cellspacing="2" cellpadding="2" bgcolor="#cccce6">
  <tbody>
    <tr>
      <td>
      <pre>&nbsp;<br>              &nbsp;&nbsp;&nbsp;&nbsp; 78L05&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; All chips<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +----------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +5V&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-----+<br>+8V-----+-------|Vin&nbsp;&nbsp; Vout|---+-----... ---+------|Vcc&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; Ref&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 22 uF +----------+&nbsp;&nbsp; = 0.1 uF&nbsp;&nbsp;&nbsp;  =0.1uF |&nbsp;&nbsp;&nbsp;&nbsp; |<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; |<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Gnd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Gnd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Gnd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gnd--+------|Vss&nbsp; |<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; +-----+</pre>
      </td>
    </tr>
  </tbody>
</table>
<p>Nothing special here: the 78L05 voltage regulator can supply 1 mAmp
at +5 volts. Make sure you use a large heat sink: it's gonna heat a lot.</p>
<p>To filter transients, each chip should have a 100 nF cap connected
accross
its supply pins, as close to the chip as possible. Ideally, the +5
volts
current should meet the cap before it meets the Vcc pin of the chip.</p>
<h4><br>
<a name="Bus buffers"></a>Bus buffering</h4>
<p>As recommended by Texas Instruments, all lines to/from the
peripheral
bus are buffered on-card. This is done with three 74LS244 for the
address
bus (16 bits) and some of the control lines: MEMEN*, CRUCLK, RESET*,
DBIN,
and WE*. </p>
<p>The data bus, of course needs a bidirectional 74LS245 buffer. The
DIRection
is controlled by the DBIN signal from the peripheral bus, the ENable
pin
by the CardSel* signal generated by the card (see below). </p>
<p>The selection signal is also connected via a 74LS125 to the RDBENA*
line of the peripheral bus to enable the drivers in the connection card
and the console-end of the cable. A 74LS125 is necessary, so as not to
hold the line high when we are not using it, as another card may need
it.
The CardSel* signal enables the '125 which input is connected to the
ground,
the rest of the time, the 74LS125 is in high-impedance (i.e. isolated)
state.</p>
<p>The only line that is not buffered in the CRUIN line that comes
directly
from the 74LS251 (this chip has a 3-state output anyhow).</p>
<p>The following schematic combines the above buffering circuits and
the
CRU logic described in the next chapter.</p>
<table cellspacing="2" cellpadding="2" bgcolor="#cccce6">
  <tbody>
    <tr>
      <td>
      <pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;74LS244&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-----+&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp; A0&gt;---|&nbsp;&nbsp; &nbsp; |---&gt;A0&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; &nbsp; |    .&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; &nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; &nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;.&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; &nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; &nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;.<br>&nbsp;&nbsp;&nbsp;&nbsp; A7&gt;---|&nbsp;&nbsp;&nbsp;  |---&gt;A7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Gnd--|EN*  |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                      <b>CRU logic<br></b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-----+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '244&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;                             <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-----+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                 270 Ohm<br>&nbsp;&nbsp;&nbsp;&nbsp; A8&gt;---|&nbsp;&nbsp; &nbsp; |---&gt;A8&nbsp;&nbsp;&nbsp;&nbsp;          Gnd---WWW---,                  IDE port<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; &nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;.&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;                    <u>|</u>&nbsp;&nbsp;&nbsp;&nbsp;,------------&lt;IRQ* <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; &nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;  LED &nbsp;<u>^</u>&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; &nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        '259    |    |      '251<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; &nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;.&nbsp;&nbsp;&nbsp;&nbsp;   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +------+&nbsp;&nbsp;|   &nbsp;|&nbsp;&nbsp;&nbsp; +------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; &nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;.&nbsp;&nbsp;  ,------------|RST &nbsp; |&nbsp; |&nbsp;&nbsp;&nbsp; |  &nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;  |<br>&nbsp;&nbsp;&nbsp;&nbsp; A15&gt;--|&nbsp;&nbsp;&nbsp;  |---&gt;A15&nbsp; |  &nbsp; A12&gt;----|S2  Q0|--'    '----|D0&nbsp; S2|----&lt;A12&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Gnd--|EN*  |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | &nbsp;  A13&gt;----|S1  Q1|---     ----|D1&nbsp;&nbsp;S1|----&lt;A13&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-----+ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |    A14&gt;----|S0  Q2|------------|D2&nbsp;&nbsp;S0|----&lt;A14<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '244&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;|   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;  Q3|------------|D3&nbsp;&nbsp;  | &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-----+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |    A15&gt;----|D&nbsp;  Q4|------------|D4&nbsp;&nbsp; Q|----&gt;CRUIN <br> RESET*&gt;---|&nbsp; &nbsp;&nbsp; |---------'&nbsp;&nbsp;&nbsp;'32      |&nbsp;&nbsp;  Q5|------------|D5&nbsp;&nbsp;  |&nbsp;<br>CRUCLK*&gt;---|&nbsp; &nbsp;&nbsp; |--------------=)&gt;-----|EN  Q6|------------|D6&nbsp;&nbsp;  |&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; WE*&gt;---|&nbsp; &nbsp;&nbsp; |---&gt;WE*&nbsp;&nbsp;   &nbsp;| &nbsp;&nbsp;  &nbsp;&nbsp; |&nbsp;&nbsp;  Q7|------------|D7  EN|---,&nbsp;&nbsp;&nbsp;<br>  MEMEN&gt;---|&nbsp; &nbsp;&nbsp; |---&gt;MEMEN*&nbsp;&nbsp;&nbsp;| &nbsp;&nbsp;&nbsp;&nbsp;   +------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +------+&nbsp;  |&nbsp;&nbsp;&nbsp;<br>CLKOUT*&gt;---|&nbsp; &nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '-----------------------------,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;<br>&nbsp;          |&nbsp; &nbsp;&nbsp; |         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Main&nbsp;    &nbsp; +------+&nbsp; '04&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; |&nbsp;<br>&nbsp;&nbsp; DBIN&gt;---|&nbsp; &nbsp;&nbsp; |---,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;     switch      |&nbsp;  A=B|--|&gt;o---+---------'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Gnd--|EN*  |&nbsp;&nbsp; |&nbsp;      A3---o_o-------&gt;|A=B &nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10K&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-----+&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Gnd---o&nbsp;  A4&gt;---&gt;|A1  B1|------+---WWW---+-+5V&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '245&nbsp;&nbsp;&nbsp;  |&nbsp;&nbsp;&nbsp;           &nbsp;&nbsp;A5&gt;---&gt;|A2  B2|-----+|---WWW---+&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-----+&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;         &nbsp; A6&gt;---&gt;|A3  B3|----+||---WWW---+&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |  DIR|&lt;--'&nbsp;&nbsp;&nbsp;        &nbsp;&nbsp;&nbsp;  A7&gt;---&gt;|A4  B4|---+|||---WWW---'&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; D0&lt;---&gt;|&nbsp;&nbsp; &nbsp; |&lt;--&gt; D0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        Gnd--&gt;|A&lt;B&nbsp;  |&nbsp;&nbsp; ||||&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp; .&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;  |&nbsp;&nbsp;&nbsp;   .              +5V--&gt;|A&gt;B&nbsp;  |&nbsp;&nbsp; oooo&nbsp; DIP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp; .&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;  |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.&nbsp;&nbsp;&nbsp;             &nbsp;&nbsp;&nbsp; +------+&nbsp;&nbsp; oooo&nbsp; switch&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp; .&nbsp;&nbsp;&nbsp;&nbsp; | &nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;   .                &nbsp;&nbsp;&nbsp;&nbsp;  '85&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ||||          <br>&nbsp;&nbsp;&nbsp;&nbsp; .&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp; &nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; ++++-Gnd          <br>&nbsp;&nbsp;&nbsp;&nbsp; .&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp; &nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp; .&nbsp;&nbsp;&nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;  |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; D7&lt;---&gt;|&nbsp;&nbsp;&nbsp;  |&lt;--&gt; D7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; |  OE*|&lt;------,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-----+&nbsp;&nbsp;  &nbsp;&nbsp; +----------&lt; CardSel*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;  <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp; |&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>RDBENA*&lt;-----------------&lt;|--Gnd<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '125&nbsp;&nbsp;</pre>
      </td>
    </tr>
  </tbody>
</table>
<h4><br>
<a name="CRU logic"></a>CRU logic</h4>
<p>The CRU logic is pretty standard. A 74LS85 comparator is used to
compare
the CRU address to a value set with a 4-DIP-switch (actually, it's a
7-DIP-switch,
the other switches are used elsewhere or reserved). Line A3 is
connected
to the A=B input and must be high to enable the output, which allows to
discriminate the console CRU space (&gt;0000-0FFF: A3 = low). An
optional
SPDT switch can be used to toggle between the A3 line and ground. When
the A=B input is connected to ground, it shuts off the card and
prevents
it from answering any CRU request. This may come handy when the DSRs
get
messed up and prevent the TI-99/4A from booting correctly...</p>
<p>The A=B output of the 74LS85 is active high. It must be inverted so
as to control the 74LS251 that performs CRU input. The inverted signal
must be further combined with CRUCLK* to enable the 74LS259 that
accepts
CRU output from the peripheral bus. This is necessary so that CRU input
operations don't alter the content of the '259 (the opposite circuit is
not needed on the '251 because the TMS9900 CPU just ignores the CRUIN
line
during CRU output operations).</p>
<p>Most CRU bits are reflected on themselves by connecting each output
of the '259 to the corresponding input of the '251. This is not true
however
for bits 0 and 1. Bit 0 ouput turns on a yellow LED and provides a
selection
signal for the addressing logic. In input mode, it reads the status of
the IRQ line on the IDE connector. Bit 1 will be discussed below.</p>
<h4><br>
<a name="Addressing"></a>Address decoding</h4>
<table cellspacing="2" cellpadding="2" bgcolor="#cccce6">
  <tbody>
    <tr>
      <td>
      <pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 74LS688&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;           &nbsp; 74LS138   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;74LS139&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;            +------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;           +------+<br>    Gnd---|G* A=B*|--------------------------|S0 Y0*|--+--------------|G*    |<br>&nbsp;&nbsp;&nbsp; A7&gt;---|A0&nbsp;  B0|--,&nbsp;       Bit0---,    &nbsp;  |   Y1*|--|-+--&gt;SRAMsel* |   Y0*|------XRAMsel*<br>&nbsp;&nbsp;&nbsp;&nbsp;A6&gt;---|A1&nbsp;  B1|--+&nbsp;&nbsp;A2--+--------==)&gt;o---|S1&nbsp;   |  | |            |   Y1*|------RTCsel*  <br>&nbsp;&nbsp;&nbsp;&nbsp;A5&gt;---|A2&nbsp;  B2|--+&nbsp;&nbsp;    '---|&gt;o--, '02&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;  &nbsp;|  | |     A10&gt;---|S0    |&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;A4&gt;---|A3&nbsp; &nbsp;B3|--+&nbsp;&nbsp;&nbsp;     Bit4---==)&gt;o---|S2&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp; | |      A9&gt;---|S1 Y2*|---+--------&gt;CS1Fx&nbsp;<br>    A3&gt;---|A4&nbsp;  B4|--+--Gnd +5V--||--------, |    &nbsp; |&nbsp; | | '08        | &nbsp; Y3*|---|-+------&gt;CS3Fx&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;A2&gt;---|A5&nbsp;  B5|--+&nbsp;&nbsp;&nbsp;      1nF MEMEN*&gt;-+-|G2A*&nbsp; |&nbsp; '-==|)--,      |&nbsp;&nbsp;    |   | |<br>&nbsp;&nbsp;&nbsp; Gnd---|A6&nbsp; &nbsp;B6|--+&nbsp;&nbsp;&nbsp;              A0&gt;---|G2B*&nbsp;&nbsp;|          |      |      |   '-==|)-+-IDEsel* <br>Bit1out---|A7&nbsp; &nbsp;B7|----+---o o---Gnd&nbsp;  A1&gt;---|G1    |      CardSel*   |   &nbsp;  |      '08 <u>|<br></u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +-------+&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp; 10K&nbsp;              +------+&nbsp;&nbsp;&nbsp;              +------+    270   <u>V</u> LED <br>            Bit1in-----+---WWW--- +5V                                       +5V---WWW---'</pre>
      </td>
    </tr>
  </tbody>
</table>
<p>The heart of the address decoding logic is the 74LS138 3-to-8
decoder,
which I am using as a 1-to-2 decoder with multiple enabling lines. It
is
enabled by MEMEN*, A0 and A1, i.e. for memory operations in the range
&gt;4000-7FFF.
Line A2 is combined with CRU bits 0 and 4, so as to select outputs Y0*
and Y1* in two cases:</p>
<li>When CRU bit 0 is high and A2 is low (address range &gt;4000-5FFF,
i.e. card ROM space)</li>
<li>When CRU bit 4 is high and A2 is high (address range &gt;6000-7FFF,
for RAMBO banks)</li>
<p>The 74LS688 is an 8-bit comparator whose A=B* outpout is active low
when the address is in the range &gt;4000-40FF and CRU bit 1 matches
the
DIP-switch. Line A2 is included in the comparison, so that the '688
never
gets active in the RAMBO space. The DIP-switch allows you to decide
whether
the SRAM or the clock RAM should be present at power-up time. As CRU
bits
are reset to 0 upon power-up, the clock RAM is selected when the switch
is closed, the SRAM when the switch is open. The status of this switch
can be read with CRU bit 1, so the software always know how to switch
the
SRAM on (when output does not match input) or off (when bit 1 output
mirrors
its input).</p>
<p>The A=B* output of the '688 selects either Y0* or Y1* of the '138.
Both
are combined with an AND gate to produce the CardSel* signal that is
used
to enable the data bus. Y1* activates the SRAM, Y0* activates a 74LS139
decoder that decides which of the 4 extra devices is accessed. Lines A9
and A10 are used for this selection:</p>
<li>Addresses &gt;4000-401F correspond to the clock extended RAM (128
pages
of 32 bytes)</li>
<li>Addresses &gt;4020-403F access the real-time-clock registers (see <a
 href="#Clock%20logic">below</a>)</li>
<li>Addresses &gt;4040-405F access the first set of registers in the
IDE
controller</li>
<li>Addresses &gt;4060-407F access the second set.</li>
<li>Addresses &gt;4080-40FF just repeat the above pattern (only the RTC
uses them differently).</li>
<p>Note that the two IDE access lines are combined through an AND gate,
to provide an IDEsel* signal for the bus demultiplexer. Just for the
fun
of it, this signals also shines a red LED, that lets you know when the
drive is accessed. Both this LED and the yellow LED triggered by CRU
bit
0 should be mounted so as to shine through the tiny window, in front of
the PE-Box.</p>
<p>You may wonder why I have a 1 nF cap on the Memen* line. This was an
attempt to filter out the glitches that caused spurious opertations
from
the IDE controller. I suspect that the glitches are due to my
point-to-point
soldering, and that the cap would not be necessary with a properly
etched
PCB...</p>
<h4><br>
<br>
<a name="SRAM logic"></a>SRAM access</h4>
<table cellspacing="2" cellpadding="2" bgcolor="#cccce6">
  <tbody>
    <tr>
      <td>
      <pre>                                       Gnd---++++++++<br>                                             ||||||||   <br>                                   74LS373     10 K        SRAM<br>                                   +------+  ||||||||   +----------+<br>                            A14---&gt;|D0  Q0|--++++++++--&gt;|A13     D7|&lt;---&gt;D0<br>                             .     |      |             | .        |     .<br>                             .     |      |             | .        |     .<br>                             .     |      |             | .        |     .<br>                            A7----&gt;|D7  Q7|------------&gt;|An      D0|&lt;---&gt;D7<br>                                   |      |      A3----&gt;|A12       |<br>SRAMsel*----, '32        '02       |      |       .     | .        |<br>WE*---------==)&gt;-------==)&gt;o------&gt;|LE    |       .     | .        |  '32  ,----Bit5 <br>CRU bit 2---|&gt;o--------'           |      |       .     | .     WE*|---&lt;(==----&lt;WE*<br>            '04  '32    '02        |      |      A15---&gt;|A0        |          <br>         A3---==)&gt;----==)&gt;o-------&gt;|OE*   |             |       CS*|----SRAMsel  <br>         A2---'       |            +------+             +----------+<br>  CRU bit 3-----------'</pre>
      </td>
    </tr>
  </tbody>
</table>
<p>The SRAM data lines are connected to the data bus. Note that Texas
Instruments
numbers the bits the opposite way to everyone else: D0 (or A0) is the
most
significant bit. That's why I connected D0 to D7, D1 to D6, etc. This
is
not critical for the SRAM, but it is for all other devices!</p>
<p>The SRAM address lines are driven (in part) by the address bus,
lines
A3 through A15. This provides us with a &gt;2000-byte access window. As
the SRAM is likely much larger than 8K, it will have extra address
lines.
These serve as "page selection" lines and are set by the 74LS373
latch. The exact number of lines depends on the size of the SRAM, the
'373
can latch 8 bits, which allows us to use a 2 Megabyte SRAM (if such a
beastie
exists...).</p>
<p>The '373 latches the address bus, lines A7 through A14, according to
a convention set by the cartridges ROMs. The latching occurs when one
writes
to the SRAM while CRU bit 3 is set to one (which it isn't at power-up
time).
To this end, a selection circuit combines SRAMSel* and WE* via an OR
gate
(active low when both are active) and combines the resulting signal
with
the inverse of CRU bit 2, via a NOR gate.</p>
<p>An additional and critical feature is the little circuit that
controls
the OE* (output enable) pin of the '373. When this pin is high, the
outputs
of the '373 are in high impedance state, so the corresponding address
lines
will reflect a default state. The eight 10K resistors grounding these
pins
ensure that page 0 will be selected in this situation. If you wanted
to,
you could use a DIP-switch (or a CRU bit) to connect the resistors
either
to ground or to +5V: this would give the user the choice between two
default
pages.</p>
<p>These outputs are only disabled when an access occurs in the range
&gt;4000-4FFF
(i.e. A2 and A3 are low), and CRU bit 3 is 0. This is critical so that
a default page, that supposedly contains the DSRs, is always selected
upon
power-up and won't be paged off when the user switches RAMBO pages.
Also,
it allows routines in the &gt;4000-4FFF memory space to switch pages in
the &gt;5000-5FFF and &gt;6000-7FFF area without kicking themselves out
of memory. The cartridge ROMs do this by having a copy of the
&gt;6000-6FFF
area at the bottom of each page, but wasting all this memory is kind of
a shame! The above hardware trick allow us to freeze the bottom half of
page 0, while still paging the top part.</p>
<p>Finally, the WE* input pin is controlled by the WE* line, after due
masking by CRU bit 5. When this bit is 1, it prevents any writing to
the
SRAM. This "ROM emulation" feature is usefull to switch banks
without altering the content of the SRAM.</p>
<p>Optionally, you could install a +3V coin battery to back-up the SRAM
when power is off. This requires a low-power SRAM, with a way of
putting
the outputs in high-impedance when power is off (either an active-high
CS pin, or an active-low STANDBY* pin). </p>
<h4><br>
<a name="Clock logic"></a>Clock access</h4>
<table cellspacing="2" cellpadding="2" bgcolor="#cccce6">
  <tbody>
    <tr>
      <td>
      <pre>                         RTC-65271<br>                       +----------+<br>                A8----&gt;|A5      D7|&lt;---&gt; D0<br>               A15----&gt;|A4        |      .<br>               A14----&gt;|A3        |      .<br>               A13----&gt;|A2        |      .<br>               A12----&gt;|A1        |      .<br>               A11----&gt;|A0        |      .<br>         '125          |        D0|&lt;---&gt; D7<br>INTRQ*&lt;---&lt;|---Gnd     |          | <br>          '------------|INTRQ*    |    '04<br>                       |       RD*|&lt;---o&lt;|---&lt;DBIN      <br>                       |       WR*|&lt;---------&lt;WE*<br>         RTCsel*------&gt;|RTC*      |<br>        XRAMsel*------&gt;|XRAM*     |<br>RESET*---o o------+---&gt;|RESET*    |<br>             10K  |    +----------+<br>       +5V--WWW---' </pre>
      </td>
    </tr>
  </tbody>
</table>
<p>The RTC-65271 chip serves two functions: it contains a real-time
clock
(RTC) similar to the standard MC146818 clock found on the PC computers.
In addition, it contains 4 Kbytes of battery-backed RAM, accessible as
128 pages of 32 bytes. This is a nice feature because it allows us to
store
the DSRs in the clock RAM, without the need for a battery-backed SRAM.
At power-up time, the DSRs will be copied into the SRAM, since it is
not
very convenient to switch pages every 32 bytes!</p>
<p>The clock data lines must be connected to the data bus in reverse
order,
i.e. D7 to D0, D6 to D1, etc. The address lines must be connected as
shown
above. Under these conditions, the extended RAM maps at &gt;4000-401F,
and the page selection register (controlled by pin A5, address line A8)
at &gt;4080. </p>
<p>The RTC contains 64 registers that are accessible via two ports.
First
you write the number of the desired register at &gt;4030, then you can
read or write to this register at &gt;4020. (NB: Lines A1-A5 are
ignored
upon RTC access, so the remaining addresses map to the same ports).</p>
<p>The WR* pin is connected to WE*, the RD* pin to the inverse of DBIN.
The two chip select lines, RTC* and XRAM*, are connected to the outputs
of the 74LS139 in the address selection logic. They select the
Real-Time-Clock
or the eXtended-RAM respectively.</p>
<p>Finally, the RTC chip can generate interrupts. These will pull down
the EXTINT* line of the peripheral bus, via a 74LS125 buffer whose
input
is grounded. When the IRQ pin is high, the '125 is in high impedance
and
won't affect the EXTINT* line.</p>
<p>Because interrupts can occur at any time, even when the computer is
off, there is a risk that the system becomes unbootable: as soon as you
turn the console on it sees the interrupt and tries to answer it. But
if
IDEAL is not loaded yet, it won't clear the interrupt condition and the
system keeps scanning cards, inbetween each GPL instruction. To prevent
this from happening, the RESET* line is connected to the RESET* pin of
the clock chip. This will disable all interrupts when the console is
powered
on. This feature can be disabled by opening the DIP switch in the
RESET*
line. For instance, if you have a battery-backed SRAM, you may be
reasonnably
sure that IDEAL will always be loaded and ready to handle interrupts.</p>
<h4><br>
<a name="IDE logic"></a>IDE port access</h4>
<table cellspacing="2" cellpadding="2" bgcolor="#cccce6">
  <tbody>
    <tr>
      <td>
      <pre>                                             74LS373                             <br>                                            +------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;      <br>                                ,-----------|Q0 &nbsp;D0|&lt;---,                        <br>                              ,-|-----------|Q1 &nbsp;D1|&lt;---|-,                      <br>                            ,-|-|-----------|Q2 &nbsp;D2|&lt;---|-|-,                    <br>&nbsp;                         ,-|-|-|-----------|Q3 &nbsp;D3|&lt;---|-|-|-,                  <br>                        ,-|-|-|-|-----------|Q4 &nbsp;D4|&lt;---|-|-|-|-,                <br>                       ,|-|-|-|-|-----------|Q5 &nbsp;D5|&lt;---|-|-|-|-|-,              <br>&nbsp;&nbsp;                  ,-|-|-|-|-|-|-----------|Q6 &nbsp;D6|&lt;---|-|-|-|-|-|-,            <br>                  ,-|-|-|-|-|-|-|-----------|Q7  D7|&lt;---|-|-|-|-|-|-|-,          <br>                  | | | | | | | |  ,--------|OE* LE|----|-|-|-|-|-|-|-|---------,<br>                  | | | | | | | |  |    &nbsp;   +------+&nbsp;   | | | | | | | |         |<br>   Even byte      | | | | | | | |  |          74LS244   | | | | | | | |         |<br>                  | | | | | | | |  |       &nbsp; +------+&nbsp;  | | | | | | | |         |<br>&nbsp;                 | | | | | | | +--|--------&gt;|A0&nbsp; Y0|---+-|-|-|-|-|-|-|---&gt;D15  |<br>                  | | | | | | +-|--|--------&gt;|A1&nbsp; Y1|-----+-|-|-|-|-|-|---&gt;D14  |<br>&nbsp;                 | | | | | +-|-|--|--------&gt;|A2&nbsp; Y2|-------+-|-|-|-|-|---&gt;D13  |<br>&nbsp;                 | | | | +-|-|-|--|--------&gt;|A3&nbsp; Y3|---------+-|-|-|-|---&gt;D12  |<br>&nbsp;                 | | | +-|-|-|-|--|--------&gt;|A4&nbsp; Y4|-----------+-|-|-|---&gt;D11  |<br>&nbsp;                 | | +-|-|-|-|-|--|--------&gt;|A5&nbsp; Y5|-------------+-|-|---&gt;D10  |<br>&nbsp;                 | +-|-|-|-|-|-|--|--------&gt;|A6&nbsp; Y6|---------------+-|---&gt;D9   |<br>&nbsp;                 +-|-|-|-|-|-|-|--|--------&gt;|A7  Y7|-----------------+---&gt;D8   |<br>                  | | | | | | | |  |         |G1*G2*|                           |<br>                  | | | | | | | |  |         +------+&nbsp;&nbsp;                         |<br>&nbsp;&nbsp;                | | | | | | | |  |           |  |             IDE connector   |<br> PE box           | | | | | | | |  |     ,-----+--'             16-bit bus      |<br> 8-bit bus        | | | | | | | |  |     |    74LS373                           |<br>                  | | | | | | | |  |     |&nbsp;   +------+&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;    |<br>&nbsp;&nbsp;D0&lt;-------------|-|-|-|-|-|-|-+--|-----|---&gt;|D0 &nbsp;Q0|---+----------------&gt;D7   |<br>&nbsp;&nbsp;D1&lt;-------------|-|-|-|-|-|-+-|--|-----|---&gt;|D1 &nbsp;Q1|---|-+--------------&gt;D6   |<br>&nbsp;&nbsp;D2&lt;-------------|-|-|-|-|-+-|-|--|-----|---&gt;|D2 &nbsp;Q2|---|-|-+------------&gt;D5   |<br>&nbsp;&nbsp;D3&lt;-------------|-|-|-|-+-|-|-|--|-----|---&gt;|D3 &nbsp;Q3|---|-|-|-+----------&gt;D4   |<br>&nbsp; D4&lt;-------------|-|-|-+-|-|-|-|--|-----|---&gt;|D4 &nbsp;Q4|---|-|-|-|-+--------&gt;D3   |<br>&nbsp;&nbsp;D5&lt;-------------|-|-+-|-|-|-|-|--|-----|---&gt;|D5 &nbsp;Q5|---|-|-|-|-|-+------&gt;D2   |<br>&nbsp;&nbsp;D6&lt;-------------|-+-|-|-|-|-|-|--|-----|---&gt;|D6 &nbsp;Q6|---|-|-|-|-|-|-+----&gt;D1   |<br>&nbsp;&nbsp;D7&lt;-------------+-|-|-|-|-|-|-|--|-----|---&gt;|D7  Q7|---|-|-|-|-|-|-|-+--&gt;D0   |<br>                  | | | | | | | |  |     |    |OE* LE|   | | | | | | | |        |<br>                  | | | | | | | |  |     |&nbsp;   +------+&nbsp;  | | | | | | | |        |<br>                  | | | | | | | |  |     '      |   |    | | | | | | | |        |<br>   Odd byte       | | | | | | | |  |     '------+   |    | | | | | | | |        |<br>                  | | | | | | | |  | 74LS244    |   |    | | | | | | | |        |<br>                  | | | | | | | | &nbsp;| +------+&nbsp;  |   |    | | | | | | | |        |<br>&nbsp;                 | | | | | | | '--|-|Y0&nbsp; A0|&lt;--|---|----' | | | | | | |        |<br>                  | | | | | | '----|-|Y1&nbsp; A1|&lt;--|---|------' | | | | | |        |<br>&nbsp;                 | | | | | '------|-|Y2&nbsp; A2|&lt;--|---|--------' | | | | |        |<br>&nbsp;                 | | | | '--------|-|Y3&nbsp; A3|&lt;--|---|----------' | | | |        |<br>&nbsp;                 | | | '----------|-|Y4&nbsp; A4|&lt;--|---|------------' | | |        |<br>&nbsp;                 | | '------------|-|Y5&nbsp; A5|&lt;--|---|--------------' | |        |<br>&nbsp;                 | '--------------|-|Y6&nbsp; A6|&lt;--|---|----------------' |        |<br>&nbsp;                 '----------------|-|Y7  A7|&lt;--|---|------------------'        |<br>                                   | |G1*G2*|   |   |                           |<br>                                  &nbsp;| +------+&nbsp;  |&nbsp;  |        74LS04             |<br>                                   |   |  |     |   |     ,---o&lt;|---WE*         |<br>                         74LS139   |   '--+     |   '--(|=----------A15         |<br>                                   |      |     |                         '04   |<br>                    &nbsp;&nbsp;&nbsp;&nbsp; +------+&nbsp; |  &nbsp;&nbsp;  |&nbsp;&nbsp;&nbsp; &nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;74LS08&nbsp;&nbsp;&nbsp;&nbsp;         ,--|&gt;o--'<br>               A15&gt;-----&gt;|S0 Y2*|--'      |     |&nbsp;A11---,               |        <br>               DBIN&gt;----&gt;|S1 Y3*|---------+-----|-------=)&gt;-------,&nbsp;&nbsp;   |        <br>&nbsp;                        |   Y1*|-nc            |       '32    ,---=)&gt;--+------&gt;RD*<br>     IDEsel*&gt;------+----&gt;|G* Y0*|---------------+--------,    |    '32            <br>             LED   |&nbsp;&nbsp; &nbsp; +------+&nbsp;&nbsp;               WE*----=)&gt;--|----,           &nbsp; &nbsp;<br> +5V---WWW---|&gt;|---'             74LS165                 '32  +----=)&gt;---------&gt;WR*<br>     220 Ohm               &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+------+      Pulses          |   74LS32          <br>                            ,---|P7  Q7|----------------------'                   <br>                            +---|P6    |                                          <br>                +5V---WWW---+---|P5 CK1|&lt;---Phi3*            A12&gt;--------------&gt;A2<br>                      4.7K  +---|P3 CK2|---Gnd               A13&gt;--------------&gt;A1<br>                            +---|P1    |                     A14&gt;--------------&gt;A0<br>                            +---|P0 LD*|&lt;---o&lt;|---Memen*                          <br>                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   '---|D     |        &nbsp;&nbsp;&nbsp;        Bit0in&lt;-------------&lt;IRQ*<br>                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gnd----|P4    |         &nbsp;&nbsp;&nbsp;       Bit7-------|&gt;o------&gt;RESET* <br>                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gnd----|P2    |                                          <br>                                +------+                                           </pre>
      </td>
    </tr>
  </tbody>
</table>
<p>The IDE port consists in 10 registers, that map as two separate
blocks.
The two blocks are enabled by CS1Fx and CS3Fx, controlled by two
outputs
of the 74LS139 in the address selection logic (see <a
 href="#Addressing">above</a>).
CS1Fx maps at &gt;4040-405F and CS3Fx maps at &gt;4060-407F. The
register
number is passed to the IDE controller on its A0-A2 lines, from the
address
lines A14-A13 (in reverse order because A2 is the msb for the IDE
controller).
</p>
<p>All registers are 8 bits wide, except the data register that is
16-bit.
For this reason, we must demultiplex the peripheral data bus, and bring
it back to what it was in the console. This is achieved by the circuit
above, that basically consists in two 74LS244 buffers and two 74LS373
latches.</p>
<p>The 74LS139 decoder (the other half of the chip used in the address
selection logic) discriminates between the four operations: Y0* = write
even byte, Y1* = write odd byte, Y2* = read even byte, Y3* = read odd
byte.
The odd byte is always passed first, for both read and write operations.</p>
<p>For write operations, the odd byte is latched in a 74LS373. Normaly,
Y1* should drive the "latch enable" pin of this chip, after being
combined with WE* via an OR gate. Unfortunately we are running out of
OR
gates! To avoid having to install an extra 74LS32 chip, I'm using one
of
the AND gates left in the 74LS08 instead. The AND gate combines A15
with
WE* , just like the 74LS139 would. Note that LE is an active-high
signal.</p>
<p>The second byte (the even one) is passed directly to the IDE
controller,
via a 74LS244 buffer. You could use a 74LS245 if you find its pin
layout
more convenient, just make sure the DIR pin is properly set. The buffer
and the 74LS373 latch are enabled together by Y0* when the TI-99/4A
writes
the second byte, so the IDE controller can read a full word.</p>
<p>For read operations, the odd byte is passed to the data bus via a
74LS244,
enabled by Y3*. At the same time, the even byte is latched into a
second
74LS373 until the TI-99/4A is ready to read it. When this finally
occurs,
the latch is enabled by Y2*.</p>
<p>The 74LS165 shift register is necessary because the TI-99/4A does
not
provide a "read" pulse to be applied to the RD* pin of the IDE
controller. I tried to make the whole 2-byte read cycle a single pulse,
but that was too messy: the IDE controller is so fast that it would
pick
any glitch on the line and think it was a request for the next data
word.
As a result, it was sending lots of words before the TI-99/4A was ready
to read them! To solve this problem I had to modify the multiplexer (my
initial design had only one latch) and to implement a pulse generator.
When Memen* goes low, the 74LS165 latches the bit pattern present on
P0-P7.
At this time, the output Q7 reflects P7. Then, at each clock pulse of
Clkout*
the next bit is passed to Q7. New bits are filled in by the D pin, but
this is not really needed because a memory operation in the PE box only
takes 6 clock cycles. By connecting P4 and P2 to ground, we are
generating
two active-low pulses on Q7: one between clock cycle 2 and 3 for read
operation,
and one between cycles 4 and 5 for write operations.</p>
<p>The WR* input of the IDE port is controlled by the WE* signal, at
the
time the even byte is writen (Y0* is low), and is further truncated by
the second pulse from the 74LS165. The latter may not be strictly
necessary
since WE* is a pulse in itself, but lets play it safe...</p>
<p>The RD* input is controlled by Y3* (which is active low while
reading
the first byte) combined with the first pulse and A11. Using A11
restricts
read operations to the range &gt;4040-404F and &gt;4060-406F. This is
required
because the TMS9900 CPU performs a read before each write. The IDE
controller
does not expect that and may not answer properly to write operations if
they were intermingled with reads (although I did not try). Masking RD*
with A11 ensures ensures that no read operation will occur in the range
&gt;4050-405F nor in &gt;4070-407F, which is where we'll perform the
write
operations. The true reads will be done at &gt;4040-404F and
&gt;4060-406F.
The RD* pulse is also used to latch the second byte in a 74LS373 until
the TI-99/4A is ready to read it.</p>
<p>Finally, as mentionned above, the IRQ* line is connected to input A0
of the 74LS251 chip, so that it can be read with CRU bit 0. CRU bit 7
is
used to perform a hardware reset. It is inverted so that the drive will
power-up when the PE-Box is turned on, even if the console is still off.</p>
<p>The LED is optional. It lights up to indicate disk access and should
be of a different color (and somewhat brighter) than the LED controlled
by bit 0. It should be installed so that both LEDs are visible from the
little window in the PE-box.</p>
<p>
</p>
<hr width="100%">
<p></p>
<h3><a name="RTC pinout"></a>The RTC-65271</h3>
<p>The RTC-65271 is a real cool chip. Basically, it is a real-time
clock,
compatible with the MC146818A that you'll find in a PC. The nice thing
is that the chips has its own crystal, and a battery holder: no extra
components
needed! In addition, it contains 4 Kbytes of battery-backed SRAM. This
will come handy to store a "boot sequence" that will load the
DSRs from disk at power-up time.</p>
<h4>Pinout</h4>
<pre>       +----+--+----+ <br>    A0 |1 o       28| A2<br>    A1 |2    R    27| A3<br> TMODE |3    T    26| Vcc<br>TCLOCK |4    C    25| SQW<br> STBY* |5         24| A4 <br>    D0 |6    6    23| A5 <br>    D1 |7    5    22| n.c.<br>    D2 |8    2    21| IRQ*<br>    D3 |9    7    20| RESET*<br>    D4 |10   1    19| RD* <br>    D5 |11        18| n.c. <br>    D6 |12        17| WR*<br>    D7 |13        16| XRAM* <br>   GND |14        15| RTC*<br>       +------------+</pre>
<p><u>Power supply<br>
</u><b>Vcc</b>: +5V <br>
<b>GND</b>: ground</p>
<p><u>Control signals<br>
</u><b>RTC*</b>: Accessed the real-time clock registers when low
(unless
XRAM* is also low).<br>
<b>XRAM*</b>: Acceses the extended RAM when low (has precedence on
RTC*).<br>
<b>RD*</b>: Read data from a register or the XRAM when low.<br>
<b>WR*</b>: Latch data into a register/XRAM when low. RD* and WR*
should
never be low together.<br>
<b>RESET*</b>: Resets the clock. When low, clears register C and bits
SQW,
PIE, AIE, and UIE in register B. Pin IRQ* is high impedance and the
data
bus is disabled. Caution: should not be used within 300 ms of power-up.
If not used, connect to Vcc.<br>
<b>STDBY*</b>:&nbsp;Stand-by.All inputs are inhibited, all outputs are
in high-impedance. If batteries are installed, the clock still operates
normally and the XRAM is maintained intact. The pin has an internal
pull-up
resistor, but should still be connected to Vcc if not used.</p>
<p><u>Address bus<br>
</u>When RTC* is low: <b>A0</b> selects the address register when low,
the data/clock registers when high. <b>A1-A5</b> are ignored.<br>
When XRAM* is low: <b>A5</b> selects the page register when high
(A0-A4
are ignored), or the XRAM when low. In the latter case, <b>A0-A4</b>
are
the address of a byte in the selected page.</p>
<p><u>Data bus<br>
</u><b>D0-D7</b>: Bidirectional data bus. D0 is the least significant
bit,
D7 the most significant one (opposite of the TI-99/4A).</p>
<p><u>Extra pins<br>
</u><b>IRQ*</b>: the clock bring this open-collector output low when
issuing
an interrupt (unless it is in stand-by or in battery-backed mode). The
load voltage should not excess Vcc. Leave n.c. when not in use.<br>
<b>SQW</b>: the clock can output a square wave signal on this pin if
the
proper bit is set in register B. Otherwise, or when the clock is in
stand-by
or power-off mode, the pin remains in high impedance.<br>
<b>TMODE</b>: Test mode. Do not use. Leave open (has an internal
pull-down
resistor) or connect to ground.<br>
<b>TCLOCK</b>: Test clock Always keep low. The clock may not work
properly
if either TMODE or TCLOCK is high.</p>
<h4><br>
<a name="Batteries"></a>Batteries</h4>
<p>Use two BR-1225 batteries (12.5 mm diameter, 2.5 mm thick, 3.0
volts).
Do not mix old and new batteries, remove exhausted batteries in case
they
would leak. Insert the batteries from right to left (pin 28 towards pin
1) with flat side up, do not apply force on the pin1-side of the
holder.
To remove a battery, insert a pointed object on the pin28-side of it
and
lift it up gently.</p>
<h4><br>
<a name="RTC registers"></a>Registers</h4>
<p>he RTC contains 64 registers. To access a register, you must first
pass
its address to the chip: just write a number from 0 to 63 while A0 is
low.
Then pull A0 high and you can read or write the selected register.
Pulse
RD* low for a read, pulse WR* low for a write. In all cases RTC* should
be low to select the RTC. Registers 0 to 13 access clock functions, the
remaining ones are SRAM registers free for you to use. IDEAL 1.0 uses
register
14 to store the first two digits of the year (20), but this won't be
updated
by the RTC don't forget that on December 31 2999.</p>
<p>Most values in the clock registers can be expressed as hexadecimal
(&gt;00
to &gt;FF) or binary coded decimal (&gt;00 to &gt;99). With the latter,
a hex digit codes for the equivalent decimal digit. For instance 32
would
be coded &gt;32 (as opposed to &gt;20 in hexadecimal) and 99 would be
&gt;99
(instead of &gt;63). IDEAL 1.0 expects the RTC to operate in
hexadecimal
mode, so from now on I will put the emphasis on this one.</p>
<p><b>Register 0</b>: Seconds. Valid values: 0 to 59 (Hex &gt;00-3B,
BCD
&gt;59)</p>
<p><b>Register 1</b>: Alarm seconds. As above. Add &gt;C0 to disregard
seconds in the alarm settings.</p>
<p><b>Register 2</b>: Minutes. Valid values: 0 to 59.</p>
<p><b>Register 3</b>: Alarm minutes. As above. Add &gt;C0 to disregard
minutes in alarm settings.</p>
<p><b>Register 4</b>: Hours. Valid values : 0 to 23 in 24h mode. 1 to
12
and &gt;81 to &gt;8C in am/pm mode (add &gt;80 for pm).</p>
<p><b>Register 5</b>: Alarm hours. As above. Add &gt;C0 to disregard
hours
in alarm settings.</p>
<p><b>Register 6</b>: Day of the week. Valid values 1 (Sunday) through
7 (Saturday).</p>
<p><b>Register 7</b>: Day of the month. Valid values 1 to 31 (the RTC
knows
how many days there are in each month. Leap years are taken into
account,
including year 2000).</p>
<p><b>Register 8</b>: Month. Valid values 1 to 12.</p>
<p><b>Register 9</b>: Year. Valid values 0 to 99.</p>
<p><b>Register 10</b>: Control register A.</p>
<table border="1">
  <tbody>
    <tr>
      <td>&gt;80</td>
      <td>&gt;40</td>
      <td>&gt;20</td>
      <td>&gt;10</td>
      <td>&gt;08</td>
      <td>&gt;04</td>
      <td>&gt;02</td>
      <td>&gt;01</td>
    </tr>
    <tr>
      <td>UIP </td>
      <td colspan="3">DV</td>
      <td colspan="4">RS</td>
    </tr>
  </tbody>
</table>
<p><b>UIP</b>: Read-only bit. 1=Register update in progress. 0=no
update
for the next 244 usec.<br>
<b>DV</b>: Oscillator + frequency divider control 0=both stopped.
2=both
on. 6=oscillator on, reset all dividers below 8192 Hz.<br>
<b>RS</b>: Frequency of the square wave signal on pin SQW.</p>
<p><b>Register 11</b>: Control register B</p>
<table border="1">
  <tbody>
    <tr>
      <td>&gt;80</td>
      <td>&gt;40</td>
      <td>&gt;20</td>
      <td>&gt;10</td>
      <td>&gt;08</td>
      <td>&gt;04</td>
      <td>&gt;02</td>
      <td>&gt;01</td>
    </tr>
    <tr>
      <td>SET </td>
      <td>PIE </td>
      <td>AIE </td>
      <td>UIE </td>
      <td>SQW</td>
      <td>DM </td>
      <td>24h </td>
      <td>DSE</td>
    </tr>
  </tbody>
</table>
<p><b>SET</b>: 1=stop register update, clears UIE and UIP. 0=registers
are updated every second.<br>
<b>PIE</b>: 1=enabls periodic interrupts at a frequency determined by
RS
in register A.<br>
<b>AIE</b>: 1=enable alarm interrupts.<br>
<b>UIE</b>: 1=enable update interrupts: once per second, after
registers
are updated.<br>
<b>SQW</b>: 1=issue a square wave signal on pin SQW, at a frequency
determined
by RS.<br>
<b>DM</b>: Data mode. 1=hexadecimal. 0=binary-coded decimal.<br>
<b>24h</b>: 1=24h mode 0=am/pm mode. Caution: hour + alarm hour must be
modified when changing this bit.<br>
<b>DSE</b>: 1=Enable daylight savings. </p>
<p><b>Register 12</b>: Status register</p>
<p>This is a read-only register. Reading it automatically clears all
interrupt
bits, so does bringing the RESET* pin low.</p>
<table border="1">
  <tbody>
    <tr>
      <td>&gt;80</td>
      <td>&gt;40</td>
      <td>&gt;20</td>
      <td>&gt;10</td>
      <td>&gt;08</td>
      <td>&gt;04</td>
      <td>&gt;02</td>
      <td>&gt;01</td>
    </tr>
    <tr>
      <td>IRQF</td>
      <td>PF </td>
      <td>AF </td>
      <td>UF </td>
      <td colspan="4">not used</td>
    </tr>
  </tbody>
</table>
<p><b>IRQF</b>: 1=an interrupt occured, the IRQ* pin is low. Cleared
when
reading the status register.<br>
<b>PF</b>: 1=a periodic interrupt occured since last time the status
was
read. Set even if PIE is 0 (but IRQ* stays high).<br>
<b>AF</b>: 1=an alarm occured since the status was last read. Set
whether
or not the interrupt is enabled by AIE.<br>
<b>UF</b>: 1=an update was completed since status was last read. Set
whether
or not UIE is enabled.</p>
<p><b>Register 13</b>: Power-status register</p>
<p>This read-only register should be read twice as it provides a
different
information each time.</p>
<table border="1">
  <tbody>
    <tr>
      <td>&gt;80</td>
      <td>&gt;40</td>
      <td>&gt;20</td>
      <td>&gt;10</td>
      <td>&gt;08</td>
      <td>&gt;04</td>
      <td>&gt;02</td>
      <td>&gt;01</td>
    </tr>
    <tr>
      <td>VLT</td>
      <td colspan="7">not used</td>
    </tr>
  </tbody>
</table>
<p>VLT: 1=voltage normal. The first time it is read VLT indicate what
happened
while Vcc was off and the clock operated on its batteries. The second
(and
subsequent) reading indicate what the power-status while Vcc is powered.</p>
<p><b>Registers 14 to 63</b>: User defined values, ignored by the RTC.</p>
<h4><br>
<a name="XRAM"></a>Extended RAM</h4>
<p>The RTC-65271 contains an extra 4 Kbytes of static RAM. The clock
battery
maintains the integrity of the data in the SRAM even when power is off.
To access the SRAM, pull down the XRAM* pin (instead of the RTC* pin
for
clock access). The SRAM is arranged as 128 pages of 32 bytes. The
address
of the byte in a page must be places on A0-A5 with A6 low, then the
byte
can be accessed via D0-D7 (pulse RD* down for a read, pulse WR* down
for
a write).</p>
<p>To select a page, pull A6 high: this accesses the page register
(A0-A5
are ignored). Write the number of the desired page, 0 to 127 (higher
values
loop back to 0-127). Then bring A6 back low to access data on this page.</p>
<p>The IDE card maps the XRAM at &gt;4000-401F, which allows to store
an
embyonnic DSR in it. All it does is to fetch IDEAL 1.0 from disk and
load
it into the SRAM chip on the card. And yes, that's quite tricky to do:
imagine switching pages every 32 bytes! If you are curious to know how
this is done, here is the source.</p>
<h4><br>
<a name="Time and date"></a>Setting/reading the time and date</h4>
<p>To read time and date, just read the relevant registers. The only
problem
is that time may change as you are reading it (e.g. if its 2:59:59), so
you may end up reading 2:00:00 if you read the hour before the minutes.
A simple solution is to always check the seconds last. If it is 0, read
the other registers once more (no need to check the seconds this time).</p>
<p>Alternatively, you can set bit &gt;80 in register B, so as to freeze
the registers while you are reading them. This won't stop the clock
that's
still ticking internally, it only prevents register update. This is
mandatory
when you want to set the clock. Freeze it first, then set the proper
time
and date, then restart it. In fact, if you really want split second
accuracy,
you should first set the RV bits in register A as 6 and restart the
clock.
This resets all stages of the frequency divider, below 8192 Hz, and
ensures
that the first second will begin exactly 0.5 seconds later. Then freeze
the clock again, set the RV bits as 2 and restart the clock for normal
operation.</p>
<p>You can enable summer-time (aka daylight saving time) by setting bit
&gt;01 in register B. When in this mode, the clock automatically jumps
from 1:59:59 am to 3:00:00 am on the first Sunday in April. It jumps
back
from 1:59:59 to 1:00:00 am on the last Sunday in October.</p>
<p><br>
<a name="alarms"></a><b>Alarms</b></p>
<p>You can set an alarm for a given time in the day, by writing a value
into the three alarm registers: hour, minutes and seconds. If a
register
is not used, set the two leftmost bits as 1 (i.e. values in the range
&gt;C0-FF).
This way you can set repetitive alarms, e.g. every hour on the hour
(hours
= &gt;C0, minutes=0, seconds=0). To disable alarms altogether, enter an
impossible value in one of the registers: e.g. minutes=64.</p>
<p>By setting bit &gt;xx in register B, you can cause the alarm to
trigger
an external interrupt when it goes off. The IRQ will be brought low
until
the alarm is acknowledged by reading register C. The IDE card sends
this
signal to the EXTINT* line, which causes an external interrupt. The
card
SRAM contains an interrupt service routine that clears the alarms and
takes
the appropriate (user selectable) action.</p>
<p><br>
<a name="square wave"></a><b>Square wave</b></p>
<p>The clock can generate a square-wave signal on its SQW pin. To do
this,
set bit &gt;80 in register B. The signal frequency is determined by
register
A, bits &gt;08 to &gt;01. The IDE card does not use this signal, but
makes
it available as an external connection. The signal period is also the
interval
between two periodic interrupts sent on pin IRQ* if the PIE bit is
enabled
in register B.</p>
<table border="1">
  <tbody>
    <tr>
      <th>RS </th>
      <th>SQW frequency</th>
      <th>Interrupt period </th>
    </tr>
    <tr>
      <td>0</td>
      <td align="center">-</td>
      <td align="center">-</td>
    </tr>
    <tr>
      <td>1</td>
      <td align="right">256 Hz</td>
      <td align="right">3.90625 ms</td>
    </tr>
    <tr>
      <td>2</td>
      <td align="right">128 Hz</td>
      <td align="right">7.8125 ms</td>
    </tr>
    <tr>
      <td>3</td>
      <td align="right">8192 Hz</td>
      <td align="right">122.07 us</td>
    </tr>
    <tr>
      <td>4</td>
      <td align="right">4096 Hz</td>
      <td align="right">244.141 us</td>
    </tr>
    <tr>
      <td>5</td>
      <td align="right">2048 Hz</td>
      <td align="right">488.281 us</td>
    </tr>
    <tr>
      <td>6</td>
      <td align="right">1024 Hz</td>
      <td align="right">976.5625 us</td>
    </tr>
    <tr>
      <td>7</td>
      <td align="right">512 Hz</td>
      <td align="right">1.953125 ms</td>
    </tr>
    <tr>
      <td>8</td>
      <td align="right">256 Hz</td>
      <td align="right">3.90625 ms</td>
    </tr>
    <tr>
      <td>9</td>
      <td align="right">128 Hz</td>
      <td align="right">7.8125 ms</td>
    </tr>
    <tr>
      <td>10</td>
      <td align="right">64 Hz</td>
      <td align="right">15.625 ms</td>
    </tr>
    <tr>
      <td>11</td>
      <td align="right">32 Hz</td>
      <td align="right">31.25 ms</td>
    </tr>
    <tr>
      <td>12</td>
      <td align="right">16 Hz</td>
      <td align="right">62.5 ms</td>
    </tr>
    <tr>
      <td>13</td>
      <td align="right">8 Hz</td>
      <td align="right">125 ms</td>
    </tr>
    <tr>
      <td>14</td>
      <td align="right">4 Hz</td>
      <td align="right">250 ms</td>
    </tr>
    <tr>
      <td>15</td>
      <td align="right">2 Hz</td>
      <td align="right">500 ms</td>
    </tr>
  </tbody>
</table>
<h3><br>
<a name="Timing diagrams"></a>Timing diagrams</h3>
<h4>Read cycle</h4>
<pre>  |<u>            &gt;395  ns               </u>| <br>XXX<u>              valid                </u>XXXX A0-A5<br>__<u>|</u>__<u>|</u>a|                       |a<u>|    |   </u>   <br>  |   \<u>___                      </u>/     |    RTC*/XRAM*<br><u>  |   |&gt;50 |</u>a|            |a<u>|&gt;20|     |   </u> <br>  |   &gt;50   \___<u>&gt;325 ns</u>____/|   &gt;20   |    RD*     <br>            |25-240|<u>        |10-100</u>|   <br>-------------------X<u>     valid     </u>X------ D0-D7 </pre>
<pre>a)&lt; 30 ns       </pre>
<h4><br>
Write cycle</h4>
<pre>  |<u>          &gt;395  ns                 </u>| <br>XXX<u>              valid                </u>XXXX A0-A5<br>__<u>|</u>__<u>|</u>a|                       |a<u>|    |   </u>   <br>  |   \<u>___                      </u>/     |    RTC*/XRAM*<br><u>  |   |  0 </u>|               <u>|&gt;20|      |   </u> <br>  |   0    \___<u>&gt;325 ns</u>____/|   &gt;20    |    WR*     <br>        |<u>    &gt;200 ns       |0</u>|   <br>--------X<u>     valid          </u>X------------ D0-D7 </pre>
<pre>a)&lt; 30 ns </pre>
<h4><br>
Interrupts </h4>
<pre>___     ___________________________<br>   \___/|                           RD*<br>________|_____________         ____<br>        |             \<u> &gt;5 us </u>/     RESET*     <br>        |     _ _ _   |&lt;2us<u>|</u>_______<br><u>        |&lt;2us</u>/     \<u>      </u>/         IRQ*</pre>
<h4><br>
Square wave</h4>
<pre>                       __    __    __<br>______________________|  |__|  |__|  |__ SQW<br><u>      </u>       <u>| &lt; 1 sec|                 <br></u>      \<u>     </u>/|                           WR*<br><u>             </u>|<u>                         </u>    <br><u>             </u>X<u>                         </u>  DV: 0 to 2</pre>
<h3><br>
<br>
<a name="Electrical"></a>Electrical characteristics</h3>
<h4>Absolute maximum ratings</h4>
<pre>Supply voltage Vcc:               -0.3V to 7V<br>Input voltage:           Vss-0.3V to Vcc+0.3V<br>Storage temperature:             -40 to 85 `C<br>Soldering temperature: max 260 `C for 10 secs</pre>
<h4><br>
<br>
Recommended operating conditions</h4>
<table border="1">
  <tbody>
    <tr>
      <th>Parameter</th>
      <th>Min</th>
      <th>Nom</th>
      <th>Max</th>
      <th>Unit</th>
    </tr>
    <tr>
      <td>Supply voltage, Vcc</td>
      <td>4.5</td>
      <td>5</td>
      <td>5.5</td>
      <td>V</td>
    </tr>
    <tr>
      <td>Free-air temperature</td>
      <td>-10</td>
      <td>.</td>
      <td>70</td>
      <td>`C</td>
    </tr>
  </tbody>
</table>
<h4><br>
Electrical characteristics under recommended conditions</h4>
<table border="1">
  <tbody>
    <tr>
      <th>Parameter</th>
      <th>Test conditions</th>
      <th>Min</th>
      <th>Typ</th>
      <th>Max</th>
      <th>Unit</th>
    </tr>
    <tr>
      <td>High-level input voltage</td>
      <td>.</td>
      <td>2.2</td>
      <td>.</td>
      <td>Vcc+0.3</td>
      <td>V</td>
    </tr>
    <tr>
      <td>Low-level input voltage</td>
      <td>.</td>
      <td>-0.3</td>
      <td>.</td>
      <td>0.8</td>
      <td>V</td>
    </tr>
    <tr>
      <td>Input leakage current </td>
      <td>RESET*, RD*, WR*,&nbsp;RTC*,<br>
XRAM*, D0-D7, A0-A5</td>
      <td>-1</td>
      <td>.</td>
      <td>+1</td>
      <td>uA</td>
    </tr>
    <tr>
      <td>High-level output voltage </td>
      <td>Vcc = 5 V, I = 4.0 mA</td>
      <td>2.4</td>
      <td>.</td>
      <td>.</td>
      <td>V</td>
    </tr>
    <tr>
      <td>Low-level output voltage </td>
      <td>Vcc = 5 V, I = 4.0 mA</td>
      <td>.</td>
      <td>.</td>
      <td>0.4</td>
      <td>V</td>
    </tr>
    <tr>
      <td>Power supply current consumption</td>
      <td>No load, SQW=8192Hz</td>
      <td>.</td>
      <td>.</td>
      <td>15</td>
      <td>mA</td>
    </tr>
    <tr>
      <td>Current in standby mode</td>
      <td>STDBY*=GND</td>
      <td>.</td>
      <td>.</td>
      <td>2</td>
      <td>uA</td>
    </tr>
    <tr>
      <td>Current in battery-backup state</td>
      <td>Ta = 25 `C</td>
      <td>.</td>
      <td>0.5</td>
      <td>1</td>
      <td>uA</td>
    </tr>
  </tbody>
</table>
<h4><br>
Frequency characteristics</h4>
<table border="1">
  <tbody>
    <tr>
      <th>Parameter</th>
      <th>Test conditions</th>
      <th>Max</th>
      <th>Unit</th>
    </tr>
    <tr>
      <td>Frequency accuracy</td>
      <td>T=25 `C, Vcc=5V</td>
      <td>5 +/- 20</td>
      <td>ppm </td>
    </tr>
    <tr>
      <td>Temperature characteristics </td>
      <td>T= -10 to 70 `C, Vcc=5V <br>
25 `C reference</td>
      <td>+10<br>
-120</td>
      <td>ppm</td>
    </tr>
    <tr>
      <td>Voltage characteristics</td>
      <td>T fixed, +5V reference</td>
      <td>+/- 5</td>
      <td>ppm/V</td>
    </tr>
    <tr>
      <td>Aging</td>
      <td>T=25 `C, Vcc=5V</td>
      <td>+/- 5</td>
      <td>ppm/Year </td>
    </tr>
  </tbody>
</table>
<h3>
<hr width="100%"></h3>
<h3><a name="IDE pinouts"></a>IDE controller</h3>
<h4>Cable pinout</h4>
<p>40-pins two-row connector:</p>
<pre>RESET*   1 2   GND<br>    D7   3 4   D8<br>    D6   5 6   D9<br>    D5   7 8   D10<br>    D4   9 10  D11<br>    D3  11 12  D12<br>    D2  13 14  D13<br>    D1  15 16  D14<br>    D0  17 18  D15<br>   GND  19     (Missing)<br>  DMAQ  21 22  GND<br> DIOW*  23 24  GND<br> DIOR*  25 26  GND<br> IORDY  27 28  SPSYNC<br> DMACK  29 30  GND<br>   IRQ  31 32  IO16*<br>   DA1  33 34  PDIAG*<br>   DA0  35 36  DA2<br>CS1Fx*  37 38  CS3Fx*<br>  DASP  39 40  GND</pre>
<p>The connections have the following functions:</p>
<pre> #  Name   I/O  Use<br>--  -----  ---  --------------------------------------- <br> 1  RESET*  &gt;   Resets all connected devices when low<br> 2  GND     -   Ground<br> 3  D7      &lt;&gt;  Data bus (D8-D15 only used with data register)<br> 4  D8      &lt;&gt;    " <br> 5  D6      &lt;&gt;    "<br> 6  D9      &lt;&gt;    "<br> 7  D5      &lt;&gt;    "<br> 8  D10     &lt;&gt;    "<br> 9  D4      &lt;&gt;    "<br>10  D11     &lt;&gt;    "<br>11  D3      &lt;&gt;    "<br>12  D12     &lt;&gt;    "<br>13  D2      &lt;&gt;    "<br>14  D13     &lt;&gt;    "<br>15  D1      &lt;&gt;    "<br>16  D14     &lt;&gt;    "<br>17  D0      &lt;&gt;  Least significany bit<br>18  D15     &lt;&gt;  Most significant bit<br>19  GND     -   Ground<br>20   -      -   Missing pin used to prevent missconnecting the cable<br>21  DMAQ    &lt;   DMA request (optional)<br>22  GND     -   Ground<br>23  DIOW*   &gt;   Pulse low to write to the IDE controller<br>24  GND     &lt;   Ground<br>25  DIORD*  &gt;   Pulse low to read from the IDE controller<br>26  GND     -   Ground<br>27  IORDY   &lt;   Access completed, drive ready (optional)<br>28  SPSYNC  &gt;&lt;  Spindle synchronisation between drives (leave open)<br>29  DMACK   &gt;   DMA acknowledge (optional)<br>30  GND     -   Ground<br>31  IRQ     &lt;   Interrupt request from the IDE devices (active high)<br>32  IO16*   &lt;   Used by the controller to signal 16-bit operations (optional)<br>33  DA1     &gt;   Address bus, selects a register among 8<br>34  PDIAG*  &gt;&lt;  Communication between master and slave drive (leave open)<br>35  DA0     &gt;   Address bus, least significant bit<br>36  DA2     &gt;   Address bus, most significant bit<br>37  CS1Fx*  &gt;   Selects the first group of registers <br>38  CS3Fx*  &gt;   Selects the second group of registers <br>39  DASP    &lt;   Drive active/slave present signal<br>40  GND     -   Ground </pre>
<h4><br>
<a name="IDE registers"></a>Registers</h4>
<p>The IDE controller interface consists in 13 registers, all 8-bit
wide
except the data register which is 16-bit. Most are bidirectional, but
there
also are 3 read-only and 3 write-only registers. Generally, a read-only
register shares its address with a write-only register. Registers are
organized
as two blocks of 8 addresses. To access a register, place its address
on
pins A0-A2, and select the proper block by bringing CS1Fx or CS3Fx low.
To read from a register, pulse RD* low. To write to it, pulse WR* low.
All registers are 8-bit wide and communicate via D0-D7, except for the
data register that is 16-bit wide and uses D0-D15. With the IDE card,
all
register map into the least significant byte of a word, the data
register
maps into the whole word.</p>
<table border="1">
  <tbody>
    <tr>
      <th align="right">CS</th>
      <th>A0-A2</th>
      <th>Read</th>
      <th>Write</th>
    </tr>
    <tr>
      <td rowspan="8">CS1Fx</td>
      <td>0</td>
      <td>Data (16-bit)</td>
      <td>Data (16-bit)</td>
    </tr>
    <tr>
      <td>1</td>
      <td>Error register </td>
      <td>Precomp register </td>
    </tr>
    <tr>
      <td>2</td>
      <td>Sector count</td>
      <td>Sector count</td>
    </tr>
    <tr>
      <td>3</td>
      <td>Sector number </td>
      <td>Sector number</td>
    </tr>
    <tr>
      <td>4</td>
      <td>Cylinder lsb</td>
      <td>Cylinder lsb</td>
    </tr>
    <tr>
      <td>5</td>
      <td>Cylinder msb</td>
      <td>Cylinder msb</td>
    </tr>
    <tr>
      <td>6</td>
      <td>Drive/head</td>
      <td>Drive/head</td>
    </tr>
    <tr>
      <td>7</td>
      <td>Status register</td>
      <td>Command register</td>
    </tr>
    <tr>
      <td rowspan="2">CS3Fx</td>
      <td>6</td>
      <td>Alternate status </td>
      <td>Digital output</td>
    </tr>
    <tr>
      <td>7</td>
      <td>Drive address</td>
      <td>-</td>
    </tr>
  </tbody>
</table>
<p><u>Data register<br>
</u>This is the only 16-bit register. It is used to pass data to/from
the
IDE contoller.</p>
<p><u>Sector count register<br>
</u>Used to indicate to the controller how many sectors are to be
transfered
(0 means 256).</p>
<p><u>Sector number register<br>
</u>Originally used to pass the sector number to/from the controller.
With
modern controller, this is just the 4th (least significant) byte of the
LBA (logical block address).</p>
<p><u>Cylinder number lsb register<br>
</u>Originally used to pass the least significant byte of the track
number
(called cylinder with hard drives) to/from the controller. Nowadays its
the 3rd byte of the LBA.</p>
<p><u>Cylinder number msb register<br>
</u>Originally used to pass the most significant byte of the cylinder
number
(and was limited to 6 bits). Now, its the second byte of the LBA.</p>
<p><u>Drive/head register<br>
</u>Originally used to pass the drive number (0 or 1) and the head
number
(0 to 15). If the proper bit is set, it causes the controller to use
logical
block addressing, and the content of the register will be the first
(most
significant) byte of the LBA.</p>
<table border="1">
  <tbody>
    <tr>
      <td>&gt;80</td>
      <td>&gt;40</td>
      <td>&gt;20</td>
      <td>&gt;10</td>
      <td>&gt;08</td>
      <td>&gt;04</td>
      <td>&gt;02</td>
      <td>&gt;01</td>
    </tr>
    <tr>
      <td>1</td>
      <td>LBA</td>
      <td>1</td>
      <td>DRV</td>
      <td colspan="4">Head number</td>
    </tr>
  </tbody>
</table>
<p><b>LBA</b>: a 1 means LBA addressing mode, a 0 means CSH addressing.<br>
<b>DRV</b>: a 0 means master drive, a 1 means slave drive.</p>
<p><u>Write pre-compensation register<br>
</u>Not used. It only exits for backward compatibility, but all IDE
controllers
ignore it.</p>
<p><u>Status register<br>
</u>This is a read only register. It is used by the IDE controller to
return
some information that depends on the command being executed. Common
bits
are:</p>
<table border="1">
  <tbody>
    <tr>
      <td>&gt;80</td>
      <td>&gt;40</td>
      <td>&gt;20</td>
      <td>&gt;10</td>
      <td>&gt;08</td>
      <td>&gt;04</td>
      <td>&gt;02</td>
      <td>&gt;01</td>
    </tr>
    <tr>
      <td>BSY</td>
      <td>RDY</td>
      <td>WFT</td>
      <td>SKC</td>
      <td>DRQ</td>
      <td>COR</td>
      <td>IDX</td>
      <td>ERR</td>
    </tr>
  </tbody>
</table>
<p><b>BSY</b>: a 1 means that the controller is busy executing a
command.
No register should be accessed (except the digital output register)
while
this bit is set.<br>
<b>RDY</b>: a 1 means that the controller is ready to accept a command,
and the drive is spinning at correct speed..<br>
<b>WFT</b>: a 1 means that the controller detected a write fault.<br>
<b>SKC</b>: a 1 means that the read/write head is in position (seek
completed).<br>
<b>DRQ</b>: a 1 means that the controller is expecting data (for a
write)
or is sending data (for a read). Don't access the data register while
this
bit is 0.<br>
<b>COR</b>: a 1 indicates that the controller had to correct data, by
using
the ECC bytes (error correction code: extra bytes at the end of the
sector
that allows to verify its integrity and, sometimes, to correct errors).<br>
<b>IDX</b>: a 1 indicates the the controller retected the index mark
(which
is not a hole on hard-drives).<br>
<b>ERR</b>: a 1 indicates that an error occured. An error code has been
placed in the error register.</p>
<p><a name="error codes"></a><u>Error register<br>
</u>This is a read only register. Its content is only meaningfull when
the ERR bit is set in the status register. </p>
<table border="1">
  <tbody>
    <tr>
      <td>&gt;80</td>
      <td>&gt;40</td>
      <td>&gt;20</td>
      <td>&gt;10</td>
      <td>&gt;08</td>
      <td>&gt;04</td>
      <td>&gt;02</td>
      <td>&gt;01</td>
    </tr>
    <tr>
      <td>BBK</td>
      <td>UNC</td>
      <td>MC </td>
      <td>NID </td>
      <td>MCR</td>
      <td>ABT</td>
      <td>NT0</td>
      <td>NDM</td>
    </tr>
  </tbody>
</table>
<p><b>BBK</b>: 1 = bad block. Sector marked as bad by host.<br>
<b>UNC</b>: 1= uncorrectable data error.<br>
<b>MC</b>: 1 = medium changed (e.g. CD-ROM. Enhanced IDE only).<br>
<b>NID</b>: 1 = No ID mark found.<br>
<b>MCR</b>: 1 = medium change required (Enhanced IDE only).<br>
<b>ABT</b>: 1 = command aborted.<br>
<b>NT0</b>: 1 = No track 0 found.<br>
<b>NDM</b>: 1 = No data mark found.</p>
<p><u>Command register<br>
</u>This is a write-only register. It accepts commands to the IDE
controller.
Note that most commands imply some values to have been placed in the
sector,
cylinder, etc registers. Always sends the command last. Here is a non
exhaustive
list of IDE commands:</p>
<p><u>Digital output register<br>
</u>This is a write-only register. It is used to send advanced
intructions
to the controller. Only two bits are active:</p>
<table border="1">
  <tbody>
    <tr>
      <td>&gt;80</td>
      <td>&gt;40</td>
      <td>&gt;20</td>
      <td>&gt;10</td>
      <td>&gt;08</td>
      <td>&gt;04</td>
      <td>&gt;02</td>
      <td>&gt;01</td>
    </tr>
    <tr>
      <td>-</td>
      <td>-</td>
      <td>-</td>
      <td>-</td>
      <td>-</td>
      <td>-</td>
      <td>RST</td>
      <td>IEN</td>
    </tr>
  </tbody>
</table>
<p><b>RST</b>: when set to 1 issues a reset signal to all connected
drives.
Must be reset to 0 for proper operation.<br>
<b>IEN</b>: when set to 1, the controller won't issue interrupts. When
0, an interrupt is issued after each sector or in advance of the result
phase (command completion).</p>
<p><u>Drive address register<br>
</u>This is a read-only register that provides info on the current
drive
status.</p>
<table border="1">
  <tbody>
    <tr>
      <td>&gt;80</td>
      <td>&gt;40</td>
      <td>&gt;20</td>
      <td>&gt;10</td>
      <td>&gt;08</td>
      <td>&gt;04</td>
      <td>&gt;02</td>
      <td>&gt;01</td>
    </tr>
    <tr>
      <td>-</td>
      <td>WGT</td>
      <td colspan="4">Head*</td>
      <td colspan="2">DS*</td>
    </tr>
  </tbody>
</table>
<p><b>WGT</b>: Status of the write gate. A 0 means the gate is open and
the read/write head is currently wrinting on the disk.<br>
<b>Head*</b>: Currently active head. Caution: the bits are inverted!<br>
<b>DS*</b>: Currently active drive.</p>
<h4><a name="IDE commands"></a>IDE commands</h4>
<p>To be passed to the command register, after having placed the
required
parameters (if any) in the other registers.</p>
<p><b>&gt;1X</b> Recalibrate the disk. All commands &gt;10 to &gt;1F
will
result in a recalibrate disk command being executed. This command has
no
parameters. You simply write the command code to the command register
and
wait for ready status to become active again.</p>
<p><b>&gt;20</b> Read sector, with retry. (<b>&gt;21</b> = read sector
without retry, <b>&gt;22</b> = also pass ECC bytes, <b>&gt;23</b>:
both).
For this command you have to load LBA first. When the command completes
(DRQ goes active) you can read 256 words (16-bits) from the data
register.
Commands &gt;22 and &gt;23 will pass the four error correction code
bytes
after the data bytes.</p>
<p><b>&gt;30</b> Write sector, with retry. (<b>&gt;31</b> = without
retry,
<b>&gt;32</b> = ECC bytes will be passed by host, <b>&gt;33</b>:
both).
Here too you have to load cylinder/head/sector. Then wait for DRQ to
become
active. Feed the disk 256 words of data in the data register. Next the
disk starts writing. When BSY goes not active you can read the status
from
the status register. With commands &gt;30 and &gt;31, the controller
calculates
the four ECC bytes (error correction codes), with commands &gt;32 and
&gt;33
you should provides these four bytes after the data bytes.</p>
<p><b>&gt;40</b> Verify sector, with retry (<b>&gt;41</b> = without
retry).
Reads sector(s) and checks if the ECC matches, but doesn't transfer
data.</p>
<p><b>&gt;50</b> Format track. Extremely dangerous command: if the
controller
performs address translation it may hopelessly mess-up the disk. Don't
use: IDE drives should be formatted in factory.</p>
<p><b>&gt;70</b> Seek. This normally does nothing on modern IDE drives.
Modern drives do not position the head if you do not command a read or
write.</p>
<p><b>&gt;90</b> Diagnostic. Tells the controller to perform a self
test
and to test the drives. Results are passed in the error register:
1=master
ok, 2=format circuit error in master, 3=buffer error in master, 4=ECC
logic
error in master, 5=microprocesssor error in master, 6=interface error
in
master. &gt;80=at least one error in slave.</p>
<p><b>&gt;91</b> Set drive parameters. Lets you specify the logical
geometry
used for address translation. Pass the number of heads (and the drive
of
interest) in the drive/head register, and the number of sectors per
track
in the sector count register.</p>
<p><u>Optional command</u> (enhanced IDE)</p>
<p><b>&gt;3C</b> Write verification.</p>
<p><b>&gt;C4</b> Read multiple sectors.</p>
<p><b>&gt;C5</b> Write multiple sectors.</p>
<p><b>&gt;C6</b> Set multiple mode.</p>
<p><b>&gt;C8</b> DMA read, with retry (<b>&gt;C9</b> without retry).
Reads
sector in direct memory access mode.</p>
<p><b>&gt;CA</b> DMA&nbsp;write, with retry (<b>&gt;CB</b> without
retry).</p>
<p><b>&gt;DB</b> Acknowledge medium change.</p>
<p><b>&gt;DE</b> Lock drive door.</p>
<p><b>&gt;DF</b> Unlock drive door.</p>
<p><b>&gt;E0</b> or <b>&gt;94</b> Standby immediate. Spins down the
drive
at once. No parameters. </p>
<p><b>&gt;E1/&gt;95</b> Idle immediate.</p>
<p><b>&gt;E2/&gt;96</b> and <b>&gt;E3/&gt;97</b> Set standby mode.
Write
in the sector count register the time (5 seconds units) of non-activity
after which the disk will spin-down. Write the command to the command
register
and the disk is set in an auto-power-save modus. The disk will
automatically
spin-up again when you issue read/write commands. &gt;E2 (or &gt;96)
will
spin-down, &gt;E3 (or &gt;97) will keep the disk spinning after the
command
has been given. Example: write &gt;10 in the sector count register,
give
command &gt;E2 and the disk will spin-down after 16*5=80 seconds of
non-activity.</p>
<p><b>&gt;E4</b> Read buffer. Reads the content of the controller
buffer
(usefull for tests).</p>
<p><b>&gt;E5/&gt;98</b> Checks for active, idle, standby, sleep.</p>
<p><b>&gt;E6/&gt;99</b> Set sleep mode.</p>
<p><b>&gt;E8</b> Write buffer. Loads data into the buffer but does not
write anything on disk.</p>
<p><b>&gt;E9</b> Write same sector.</p>
<p><b>&gt;EC</b> Identify drive. This command prepares a buffer (256
16-bit
words) with information about the drive. To use it: simply give the
command,
wait for DRQ and read the 256 words from the drive. </p>
<p><b>&gt;EF</b> Set features.</p>
<p><b>&gt;F2</b> and <b>&gt;F3</b> The same as&gt; E2 and &gt;E3, only
the unit in the sector count register is interpreted as 0.1 sec units.</p>
<p>Codes &gt;80-8F, &gt;9A, &gt;C0-C3, and &gt;F5-FF are manufacturer
dependent
commands. All other codes are reserved for future extension.</p>
<h4><a name="Operating the IDE controller"></a>Operating the IDE
controller</h4>
<p>Lets take the read command as an example. First we should set the
address
of the desired sectors in the sector, cylinder, etc registers. Let's
say
we are using logical block addressing and want to access logical block
&gt;123456.</p>
<p>Sector register &lt;--- 56<br>
Track register &lt;---34<br>
xxx register &lt;---12<br>
Head/drive register &gt;E0 (bit &gt;40 indicates LBA)<br>
Sector size register &lt;--256 (hard drive sectors are 512-byte in
length,
i.e 256 words).</p>
<p>Then we can send the read command to the command register</p>
<p>Status register --&gt; wait till ready and not busy<br>
Command register &lt;--xx<br>
Status register --&gt; wait till ready and not busy (while the
controller
seeks and read data into its buffer).</p>
<p>Now we can read the data</p>
<p>Status register --&gt; wait for DRQ<br>
Data register --&gt; read 256 16-bit words.<br>
Status register--&gt; check ERR: if set check the error register.</p>
<p>The controller triggers its interrupt line each time a sector is
ready
to be read. The IDE card lets you see this signal on CRU bit 0. For
write
operations, the IRQ line is activated each time a sector has been
written
and the controller is waiting for another one (including after the last
sector: when the user can read the registers again). For all other
commands,
an interrupt is issued at the result phase, i.e. when the user can
access
the registers again after command completion.</p>
<p>Note that the controller contains a 512-byte buffer, so when writing
data to the disk, you don't have to wait until each byte is physically
written: just place the data into the buffer and leave the rest to the
controller. You will have to wait between sectors though. Remember that
hard-drive sectors are 512 bytes in length.</p>
<h4><a name="LBA vs CSH"></a>LBA versus CSH</h4>
<p>Hard drives consists in several disks, each accessed via a reading
head.
Each disk contains a number of concentric track and a set of tracks
with
the same number on each disk is called a cylinder. Tracks are
subdivided
in sectors. The number of sector per track may vary from drive to drive
or even from track to track on the same drive (tracks at the inside of
the disk are shorter and can accomodate less data).</p>
<p>Originally, to access a sector you had to know its number on the
track,
the track (or cylinder) number and which head should be used. This was
called CHS (cylinder-head-sector) adressing. It was quite incovenient
because
it requires you to know the physical geometry of the drive (number of
heads,
etc). In addition, the PC BIOS and DOS placed limitations on the
maximum
values that could be sent (e.g. the cylinder number could be 1023 at
max),
whereas other values were limited by the hardware (no track can
accomodate
256 sectors).</p>
<p>The second generation of IDE controllers started to perform "address
translation", i.e. they take the CSH address passed by the user and
adapt it to their internal geometry. For instance, a drive with more
than
16 heads could decide the the most-significant bit of the sector number
should be used to select heads 16-31. This also allowed smart
controllers
to remap deffective tracks: they always are a few extra tracks at the
end
of a disk. When the controller determines that a track is deffective,
it
replaces it with one of the extra track, in a completely
user-transparent
manner (except that it may be a tad longer to move the to extra track
than
to the original one).</p>
<p>The next step was to get rid of CSH altogether and to let the
controller
decide how to arrange data on its disks. This is the concept behind
logical
block addressing (LBA). With LBA you consider your drive as a
collection
of blocks, numbered from 0 to &gt;0FFF FFFF for the master drive, and
from
&gt;1000 0000 to &gt;1FFF FFFF for the slave drive. To access a sector,
just pass its number to the controller and let it determine where the
sector
is physically located. LBA is far easier to handle than CSH as it
places
the burden on the controller, not on the programmer. On top of that, it
is portable from drive to drive, which is a big plus. Finally, it lets
you use the whole address space (no hardware or software limitations),
upto a maximum of 128 gigabytes per drive.</p>
<p>The IDE card can perform both CSH and LBA addressing, but IDEAL 1.0
only knows LBA.</p>
<h4><a name="DMA"></a>Direct memory access</h4>
<p>The LBA controller is able to transfer data directly into the
computer
memory, bypassing the CPU. Unfortunately, this cannot be done with the
TI-99/4A, so the DMA commands should never be used.</p>
<h4><a name="Drive considerations"></a>Drives considerations</h4>
<p>The IDE bus is intended for two devices: a master and a slave. These
could be hard-drives, CD-ROM drives, or even a ZIP-drive. I only have
tested
the card with a single hard-drive, but it should also work with two.
Just
make sure you place the jumpers properly on each drive. If you want to
access a CD drive, you'll have to write your own routines to translate
the PC format. </p>
<p>Your drive must be recent enough to support LBA (logical block
addressing).
This is purely a software requirement: that's what the DSRs are
expecting.
Of course, if you are willing to write CSH addressing routines
yourself,
feel free to do so. The maximum supported size is 128 Gigabytes per
drive.
</p>
<p>Most drives have three jumpers. CS (cable select) is almost never
used,
so your choice is between master and slave. If you have a single drive
leave all jumpers open (some drives allow a "storage" position
for the unused jumper: accross MA and SL). If you want two drives,
install
one as the master, the other as the slave (duh!).</p>
<pre>MA o o            MA o-o         MA o o <br>SL o o            SL o o         SL o-o<br>CS o o            CS o o         CS o o<br>One drive         Master         Slave</pre>
<p>NB: Both devices get their registers written, but only the selected
device will execute commands. Any data or register read will come from
the selected device only.</p>
<h1>
<hr width="100%"><a name="CRU map"></a>Software</h1>
<p><a href="#CRU%20map">CRU map<br>
</a><a href="#Memory%20map">Memory map<br>
</a><a href="#Low-level">Low-level access<br>
</a><a href="#High%20level">High-level access</a></p>
<h3>CRU map</h3>
<table border="2" cellspacing="2" cellpadding="2">
  <tbody>
    <tr>
      <th>Bit</th>
      <th>Write</th>
      <th>Read</th>
    </tr>
    <tr>
      <td>0</td>
      <td>1: turn card on </td>
      <td>IRQ pin of the IDE interface </td>
    </tr>
    <tr>
      <td>1</td>
      <td>= DIP-switch: registers map at &gt;4000-40FF<br>
&lt;&gt; switch: SRAM maps at &gt;4000-40FF</td>
      <td>Reads the position of the DIP-switch </td>
    </tr>
    <tr>
      <td>2</td>
      <td>1: Enable SRAM page switching</td>
      <td>Reads itself</td>
    </tr>
    <tr>
      <td>3</td>
      <td>1: Fixes page #0 at &gt;4000-4FFF</td>
      <td>Reads itself</td>
    </tr>
    <tr>
      <td>4</td>
      <td>1: Enables RAMBO banks in &gt;6000-7FFF</td>
      <td>Reads itself</td>
    </tr>
    <tr>
      <td>5</td>
      <td>1: Write-protects the SRAM</td>
      <td>Reads itself</td>
    </tr>
    <tr>
      <td>6</td>
      <td>not used</td>
      <td>not used</td>
    </tr>
    <tr>
      <td>7</td>
      <td>1: resets the drives (inverted to IDE pin RST*) </td>
      <td>.</td>
    </tr>
  </tbody>
</table>
<h3><br>
<a name="Memory map"></a>Memory map</h3>
<p>When CRU bit 1 matches the position of the DIP-switch (i.e. when you
write back what you read), the address space &gt;4000-40FF is used to
map
the clock and IDE registers. Otherwise, the SRAM maps here, just as in
the rest of the address space (&gt;4100-5FFF).</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre>*---------------------------------------------------------------------<br>*  Check DIP-switch for register mapping, select proper instructions<br>*---------------------------------------------------------------------<br>DIPREG LI   R1,&gt;1D01          This is SBO 1<br>       LI   R2,&gt;1E01          This is SBZ 1<br>       TB   1                 Test DIP-switch<br>       JNE  SK3               <br>       MOV  R1,@REGON         DIP is on<br>       MOV  R2,@REGOFF        Select registers with SBO<br>       B    *R11<br><br>SK3    MOV  R1,@REGOFF        DIP is off<br>       MOV  R2,@REGON         Select registers with SBZ<br>       B    *R11</pre>
      <pre>REGON  NOP                    Register selection instruction <br>REGOFF NOP                    SRAM selection instruction<br>*</pre>
      <pre>       X    @REGON            Maps registers at &gt;4000-40FF</pre>
      <pre>       X    @REGOFF           Maps SRAM at &gt;4000-40FF</pre>
      </td>
    </tr>
  </tbody>
</table>
<h4>Register mapping</h4>
<pre>&gt;4000-401F: clock XRAM<br>&gt;4020: RTC address register<br>&gt;4030: RTC data register<br>&gt;4040: IDE&nbsp;data register (read)<br>&gt;4042: IDE error register (read)<br>&gt;4044: IDE&nbsp;count register (read)<br>&gt;4046: IDE sector register (read)<br>&gt;4048: IDE cylinder lsb register (read)<br>&gt;404A: IDE cylinder msb register (read)<br>&gt;404C: IDE drive+head register (read)<br>&gt;404E: IDE status register (read)<br>&gt;4050: IDE data register (write)<br>&gt;4052: IDE pre-comp register, not used (write)<br>&gt;4054: IDE&nbsp;count register (write) <br>&gt;4056: IDE sector register (write)<br>&gt;4058: IDE cylinder lsb register (write)<br>&gt;405A: IDE cylinder msb register (write)<br>&gt;405C: IDE drive+head register (write)<br>&gt;405E: IDE command register (write)<br>&gt;406C: IDE alternate status register(read)<br>&gt;406E: IDE drive address register (read)<br>&gt;407C: IDE digital output register (write)<br>&gt;407E: IDE drive address register (write)<br>&gt;4080: XRAM page register</pre>
<h3><br>
<a name="Low-level"></a>Low-level access</h3>
<h4>SRAM paging</h4>
<p>To switch pages, all we have to do it to enable switching with CRU
bit
2 and then write to an address in the SRAM. Address lines A8-A14 will
be
used as a page number (although you probably won't need that many
pages,
unless you install 2 Megs of SRAM on board). Just to make sure we don't
mess up any data, it may be a good idea to write-protect the SRAM
beforehand.</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre>*---------------------------------------------------------------------<br>* SRAM page selection routine. Page # in  R1<br>*---------------------------------------------------------------------<br>SELPG  SLA  R1,8             Max 256 pages<br>       SRL  R1,7             A15 is not latched: shift to the left<br>       SBO  5                Write protect SRAM<br>       SBO  2                Enable latching<br>       MOV  R1,@&gt;5F00(1)     Latch page #, from address lines A7-A14<br>       SBZ  2                Disable latching<br>       SBZ  5                Enable writing<br>       SRL  R1,1             Restore page # for caller (optional)<br>       B    *R11</pre>
      </td>
    </tr>
  </tbody>
</table>
<h4><br>
RTC access</h4>
<p>To access a register in the real-time clock, first write the
register
number (&gt;0000 to &gt;3F00) at address &gt;4020. For some reason,
this
number cannot be read back, I'm not sure if it's a characteristic of
the
chip, or a timing problem with my design. The specified register can
then
be accessed byte-wise at address &gt;4030. Remember to stop clock
updates
by setting bit &gt;80 in register B, before you attempt to modify
registers
0 to 9. </p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre>*---------------------------------------------------------------------<br>* Write to a register in the RTC. Register # in R3, data in R1<br>*---------------------------------------------------------------------<br>RTCWR  SLA  R3,8              Put register # in msb<br>       MOVB R3,@&gt;4020         Pass register #<br>       SWPB R3                Restore R3<br>       SLA  R1,8              Put value in msb<br>       MOVB R1,@&gt;4030         Set clock data<br>       SWPB R1                Restore R1<br>       B    *R11</pre>
      <pre>*---------------------------------------------------------------------<br>Read a register from the RTC. Register # in R3, result in R1<br>*---------------------------------------------------------------------<br>RTCRD  SLA  R3,8              Put register # in msb<br>       MOVB R3,@&gt;4020         Pass it<br>       SWPB R3                Restore R3<br>       MOVB @&gt;4030,R1         Get clock data<br>       SRL  R1,8              Make it a word<br>       B    *R11</pre>
      </td>
    </tr>
  </tbody>
</table>
<h4>XRAM access</h4>
<p>The SRAM can be accessed at addresses &gt;4000-401F. To change page,
write the new page number at address &gt;4080. Valid page numbers are
&gt;0000
to &gt;7F00, although other values won't cause any problem (all extra
bits
are ignored). The value can be read back to know what the current page
is.</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre>*---------------------------------------------------------------------<br>* Set XRAM page. Page # in R0<br>*---------------------------------------------------------------------<br>SELXPG SLA  R0,8            Put it in MSB<br>       MOVB R0,@&gt;4080       Set page<br>       MOVB @&gt;4080,R0       Read it back (optional)<br>       SRL  R0,8            Make it a word for caller<br>       B    *R11            Page in now available at &gt;4000-401F</pre>
      </td>
    </tr>
  </tbody>
</table>
<h4>IDE access</h4>
<p>You can read IDE registers at addresses &gt;4040-404E and
&gt;406C-406E.
You can write to them at &gt;4050-405E and &gt;407C-407E. Make sure you
check the status bits before sending a command, otherwise you will read
meaningless data and the controller will ignore your writes. Apart from
the 16-bit data register, all registers are 1 byte long and are
accessed
at odd addressed (i.e. in the least significant byte of a word).</p>
<p>Remember that sectors are 512 bytes in length on a hard disk. This
will
require some manipulation if you want to emulate the 256-byte sectors
of
floppy disks...</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre>*---------------------------------------------------------------------<br>* Send a command to the IDE controller. Command in R0<br>*---------------------------------------------------------------------<br>SENDCM MOV  @&gt;404E,R1         Get status<br>       COC  @STRDY,R1         Check "ready" bit     <br>       JNE  SENDCM            Not set yet: wait<br>       COC  @STBSY,R1         Check "busy" bit<br>       JEQ  SENDCM            Set: wait</pre>
      <pre>       MOV  R0,@&gt;405E         Send command to command register<br>LP2    MOV  @&gt;404E,R1         Read status<br>       COC  @STBSY,R1         Check "busy" bit<br>       JEQ  LP2               Wait till not busy<br>       COC  @STERR,R1         Now check "error" bit<br>       JNE  SK1               Not set<br>       MOV  @&gt;4042,R1         Get error code from error register<br>       B    *R11<br><br>SK1    INCT R11               Skip jump if ok<br>       B    *R11</pre>
      <pre>STBSY  DATA &gt;0080             "Busy" status bit <br>STRDY  DATA &gt;0040             "Ready" status bit<br>STDRQ  DATA&nbsp;&gt;0008             "Data requested" bit<br>STERR  DATA &gt;0001             "Error" status bit</pre>
      <pre>*---------------------------------------------------------------------<br>* Set logical block address. Block # in R0. Base LBA in data (optional)<br>*---------------------------------------------------------------------<br>SETLBA MOV  @&gt;404E,R1          Get status<br>       COC  @STRDY,1R          Check "ready" bit<br>       JNE  SETLBA             Not set yet: wait<br>       COC  @STBSY,R1          Check "busy" bit<br>       JEQ  SETLBA             Set: wait<br><br>*      SRL  R0,1               Optional: if using 256-byte sectors #<br>       A    @LBA3,R0           Add R0 to base LBA<br>       MOV  R0,@&gt;4056          Set LBA address<br>       SRL  R0,8<br>       A    @LBA2,R0<br>       MOV  R0,@&gt;4058<br>       SRL  R0,8<br>       A    @LBA1,R0<br>       MOV  R0,@&gt;405A<br>       SRL  R0,8<br>       A    @LBA0,R0<br>       MOV  R0,@&gt;405C<br>       LI   R0,&gt;0001<br>       MOV  R0,@&gt;4054           Transfer 1 sector<br>       B    *R11</pre>
      <pre>LBA0   DATA &gt;00E0               LBA buffer (only LSB&nbsp;are used)<br>LBA1   DATA &gt;0000<br>LBA2   DATA &gt;0000<br>LBA3   DATA &gt;0000</pre>
      <pre>*---------------------------------------------------------------------<br>Set drive parameters. Must be sent before any other command<br>*---------------------------------------------------------------------<br>SETPAR MOV  R11,R10<br>       LI   R0,&gt;20             (Arbitrary value)<br>       MOV  R0,@&gt;4054          Number of logical sectors/track<br>       LI   R0,&gt;E8             (Arbitrary value)<br>       MOV  R0,@&gt;405C          Number of logical heads<br>       LI   R0,&gt;0091           "Set drive parameters"<br>       BL   @SENDCM            Send command<br>       B    *R10               Skipped if ok<br>       INCT R10                Skip JMP if ok<br>       B    *R10</pre>
      <pre>*---------------------------------------------------------------------<br>* Read a 512-byte sector into buffer in R2, sector # in R0<br>*---------------------------------------------------------------------<br>SECRD2 MOV  R11,R10<br>       BL   @SETLBA           Set LBA for sector # in R0<br>       LI   R0,&gt;0020          "Read sector"<br>       BL   @SENDCM           Send command<br>       B    *R10              Skipped if no error<br><br>LP3    MOV  @&gt;404E,R1         Wait for data to be ready<br>       COC  @STERR,R1         Test error bit<br>       JEQ  UHO               Error<br>       COC  @STDRQ,R1         Test data request bit<br>       JNE  LP3               Not ready yet<br><br>       LI   R0,512<br>LP4    MOV  @DATAR,*R2+       Read 512 bytes<br>       DECT R0<br>       JNE  LP4 <br>       AI   R2,-512           Restore R2<br>       INCT R10               Skip JMP if ok<br>       B    *R10</pre>
      <pre>*---------------------------------------------------------------------<br>*  Write a 512-byte sector from buffer in R2, sector # in R0<br>*---------------------------------------------------------------------<br>SECWR2 MOV  R11,R10<br>       BL   @SETLBA           Set LBA for sector # in R0<br>       LI   R0,&gt;0030          "Write sector"<br>       BL   @SENDCM           Send command<br>       B    *R10              Skipped if no error<br><br>LP5    MOV  @&gt;404E,R1         Wait for data to be ready<br>       COC  @STERR,R1         Test error bit<br>       JEQ  UHO               Error<br>       COC  @STDRQ,R1         Test "data request" bit<br>       JNE  LP5               Not yet<br><br>       LI   R0,512<br>LP6    MOV  *R2+,@&gt;4050       Write 512 bytes<br>       DECT R0<br>       JNE  LP6<br>       AI   R2,-512           Restore buffer ptr<br>       INCT R10               Skip JMP if ok<br>       B    *R10</pre>
      <pre>UHO    MOV  @&gt;4002,R0         Error detected: get error code<br>       B    *R10              And abort</pre>
      </td>
    </tr>
  </tbody>
</table>
<h3><br>
<a name="High level"></a>High-level access</h3>
<p>The card DSR, or disk operating system is known as IDEAL, for IDE
Acess
Layer. A dedicated loader, called IDELOAD, serves to load it into the
card
SRAM. You also have the option to install a boot routine in the clock
XRAM
that will automatically load IDEAL from the hard disk upon power-up.
IDEAL
is described in details on <a href="ideal.htm">another page</a>.</p>
<address><br>
Revision 1. 7/28/00. Preliminary, not for release.<br>
Revision 2. 9/12/00. Added code examples. Still not for release.<br>
Revision 3. 3/19/01. Schematic changed: 74LS85 wiring,clock reset.<br>
Revision 4. 7/2/01. Multiplexer modified, RD pulse genrator added. OK
to
release.<br>
</address>
<center>
<p><br>
<a href="titechpages.htm">Back to the TI-99/4A Tech Pages</a></p>
</center>
</body>
</html>
