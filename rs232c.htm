<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
  <title></title>
  <meta name="Author" content="">
  <meta name="GENERATOR"
 content="Mozilla/3.04Gold (Win95; U) [Netscape]">
</head>
<body>
<h1 align="center"><a
 href="http://www.nouspikel.com/ti99/titechpages.htm"><img
 src="logo.jpg" style="border: 0px solid ; height: 33px; width: 95px;"
 title="Back to main index" alt=""></a></h1>
<h1>The RS232C/PIO interface card</h1>
<p>This card features an 8-bit parallel port and two serial ports. The
parallel port does not follow the Centronics standards, but the serial
ports are compatible with the RS232C standard, also known as V.24 in
Europe.</p>
<p>Here is a commented <a href="rs_card.htm">picture</a> of the card,
including
instructions for modification of its CRU address (to install two cards
in your PE-box).</p>
<p><b>The parallel port<br>
</b><a href="#PIOPinout">Pinout<br>
</a><a href="#PIOTheory">Theory of operation<br>
</a><a href="#PIOCircuit">Circuitery<br>
</a><a href="#PIOSample">Sample programs</a></p>
<p><b>The serial ports<br>
</b><a href="#SerPinout">Pinout<br>
</a><a href="#SerTheory">Theory of operation<br>
</a><a href="#XonXoff">__Xon/Xoff<br>
</a><a href="#RTSCTS">__RTS/CTS<br>
</a><a href="#DSRDTR">__DST/DTR<br>
</a><a href="#DCDRI">__DCD, RI<br>
</a><a href="#Duplex">__Simplex. duplex, half-duplex<br>
</a><a href="#NullModem">__Null-modem connections</a></p>
<p><b>The TMS9902<br>
</b><a href="#Pinout9902">Pinout<br>
</a><a href="#Operating9902">Operating the TMS9902<br>
</a><a href="#ControlReg">_Control register<br>
</a><a href="#IntervalReg">_Interval register<br>
</a><a href="#RateReg">_Rate registers<br>
</a><a href="#Interrupts">_Interrupts<br>
</a><a href="#Errors">_Error detection<br>
</a><a href="#Monitoring">_Transmission monitoring<br>
</a><a href="#SerProgram">Sample program<br>
</a><a href="#Electrical">Electrical characteristics<br>
</a><a href="#Timing">Timing diagrams<br>
</a><a href="#SerCircuit">Circuitery</a></p>
<p><b>CRU interface<br>
</b><a href="#CRU%20map">CRU map</a></p>
<p><b>Card ROMs<br>
</b><a href="#CardROM">The power-up routine<br>
</a><a href="#RomDSR">The DSRs<br>
</a><a href="#RomISR">The ISR</a></p>
<p><br>
</p>
<h2><a name="ParallelPort"></a>Parallel port </h2>
<p>This port, known as PIO (Parallel Input/Output) on the TI-99/4A
card,
features an 8-bit wide bidirectional parallel connection. In addition
there
are two extra output lines (SPAREOUT and HANDSHAKEOUT) and two extra
input
lines (SPAREIN and HANDSHAKEIN).</p>
<h3><a name="PIOPinout"></a>Pinout</h3>
<table border="1">
  <tbody>
    <tr>
      <th>Pin</th>
      <th>I/O</th>
      <th>Function</th>
      <th>Access</th>
    </tr>
    <tr>
      <td>1</td>
      <td>O</td>
      <td>HANDSHAKEOUT</td>
      <td>CRU bit 2</td>
    </tr>
    <tr>
      <td>2</td>
      <td>I/O</td>
      <td>D7 (lsb)</td>
      <td rowspan="8">Byte &gt;5000</td>
    </tr>
    <tr>
      <td>3</td>
      <td>I/O</td>
      <td>D6</td>
    </tr>
    <tr>
      <td>4</td>
      <td>I/O</td>
      <td>D5</td>
    </tr>
    <tr>
      <td>5</td>
      <td>I/O</td>
      <td>D4</td>
    </tr>
    <tr>
      <td>6</td>
      <td>I/O</td>
      <td>D3</td>
    </tr>
    <tr>
      <td>7</td>
      <td>I/O</td>
      <td>D2</td>
    </tr>
    <tr>
      <td>8</td>
      <td>I/O</td>
      <td>D1</td>
    </tr>
    <tr>
      <td>9</td>
      <td>I/O</td>
      <td>D0 (msb)</td>
    </tr>
    <tr>
      <td>10</td>
      <td>I</td>
      <td>HANDSHAKEIN</td>
      <td>CRU bit 2</td>
    </tr>
    <tr>
      <td>11</td>
      <td>-</td>
      <td>Ground</td>
      <td>-</td>
    </tr>
    <tr>
      <td>12</td>
      <td>O</td>
      <td>+5V via 10 Ohm</td>
      <td>-</td>
    </tr>
    <tr>
      <td>13</td>
      <td>I</td>
      <td>SPAREIN</td>
      <td>CRU bit 3</td>
    </tr>
    <tr>
      <td>14</td>
      <td>O</td>
      <td>SPAREOUT</td>
      <td>CRU bit 3</td>
    </tr>
    <tr>
      <td>15</td>
      <td>O</td>
      <td>+5V via 1 KOhm</td>
      <td>-</td>
    </tr>
    <tr>
      <td>16</td>
      <td>-</td>
      <td>Ground</td>
      <td>-</td>
    </tr>
  </tbody>
</table>
<h3><a name="PIOTheory"></a>Theory of operation</h3>
<p>Nothing simpler than a parallel port: the sender just puts a byte of
data on the port and it is transfered to the receiver over 8 parallel
wires,
one per bit. The only problem is that we need some way to tell the
receiver
when a new byte is sent (since we may want to send the same byte
several
times, the receiver cannot just monitor the port for changes). We'll
have
to use an extra line, on which a pulse (strobe) will be sent to
indicate
a new byte. The PIO port has no dedicated strobe line, but we could use
either HANDSHAKEOUT or SPAREOUT for this purpose. Let's say
HANDSHAKEOUT
since the name suggests something like that anyway.</p>
<p>The other control lines can serve several purposes. For instance,
the
receiver may need more time to process the incoming data. The
HANDSHAKEIN
line may thus be used to provide the sender with an acknowledgment
signal:
"OK, I got that. Keep sending data".</p>
<p>The peripheral may also need to signal the sender when an error
condition
occured, such a "printer out of paper". The SPAREIN line may
be used for that purpose.</p>
<p>Finally, since the PIO port is bidirectional, we may want to
establish
a duplex communication, in which the data lines are used by either
device
to send data to the other (this is known as half-duplex, <a
 href="#Duplex">see
below</a>). The SPAREOUT line may be used to decide whose turn it is to
send data.</p>
<p>Once again, these are only suggestions: there is no norm for PIO
port
connections. The extra lines may well be used to operate special
features
of the peripheral controlled via the parallel port. </p>
<h3><br>
<a name="PIOCircuit"></a>Circuitery</h3>
<p>This is the internal wiring for the PIO port in a typical interface
card. For help with the TTL chips, refer to my <a href="ttl.htm">TTL
page</a>.</p>
<table cellspacing="2" cellpadding="2" bgcolor="#cccce6">
  <tbody>
    <tr>
      <td>
      <pre><b>PE-Box</b> <b>bus</b>     74LS259                            74LS251<br><b> </b>             +----------+                       +----------+      <b>PE-Box</b> <b>bus<br></b>A12&gt;----------| S0    Q0 |-----&gt;ROMSEL        nc-| A0    S0 |---------&lt;A14<br>A13&gt;----------| S1    Q1 |-----+PIOOUT-----------| A1    S1 |---------&lt;A13<br>A14&gt;----------| S2    Q2 |---+ |       +---------| A2    S2 |---------&lt;A12<br>              |       Q3 |---|+|       |+--------| A3       |<br>A15&gt;----------| D     Q4 |---|||-------||--------| A4       |<br>              |       Q5 |---|||-CTS1--||--------| A5       |<br>      CRU_O*&gt;-| EN*   Q6 |---|||-CTS2--||--------| A6       |<br>              |       Q7 |---|||-LED+--||--------| A7     Y |----------&gt;CRUIN<br>RESET*&gt;-------| RST*     |   |||    |  ||        |          |<br>              |          |   |||    |  || CRU_I*-| EN*      |<br>              +----------+   |||    |  ||        +----------+<br>                             |||    |  ||                         <b>  PIO Port<br></b>         LED  2N3904         +||----|--||------------------------&gt;HANDSHAKEOUT     <br>   +5V ---&gt;|----\|            +|----|--||------------------------&gt;SPAREOUT<br>                 |-------------|----'  +|---+---------UUU--------&lt;HANDSHAKEIN<br>                /|             |        |   |  10 nF<br>               |               |        |   +---||--- Gnd<br>              Gnd              |        |<br>                               |        +---+---------UUU--------&lt;SPAREIN<br>                               |            |  10 nF<br>                               |            +---||--- Gnd<br>                               |<br>PE-Box bus    74LS245     <b>   </b>  |          74LS373<br>            +----------+       |       +----------+<br>DBIN--------| DIR      |       +-------| OE*      |<br>            |          |    LATCHOUT---| CK*      |             <b>PIO Port<br></b>D0----------| A0    B0 |---+-----------| D0    Q0 |----------+---PIO0<br>D1----------| A1    B1 |---|+----------| D1    Q1 |---------+|---PIO1<br>D2----------| A2    B2 |---||+---------| D2    Q2 |--------+||---PIO2<br>D3----------| A3    B3 |---|||+--------| D3    Q3 |-------+|||---PIO3<br>D4----------| A4    B4 |---||||+-------| D4    Q4 |------+||||---PIO4<br>D5----------| A5    B5 |---|||||+------| D5    Q5 |-----+|||||---PIO5<br>D6----------| A6    B6 |---||||||+-----| D6    Q6 |----+||||||---PIO6<br>D7----------| A7    B7 |---|||||||+----| D7    Q7 |---+|||||||---PIO7<br>            +----------+   ||||||||    +----------+   ||||||||<br>                           ||||||||       74LS373     |||||||| <br>                           ||||||||    +----------+   ||||||||<br>                           +-----------| Q0    D0 |----------+<br>                            +----------| Q1    D1 |---------+<br>                             +---------| Q2    D2 |--------+<br>                              +--------| Q3    D3 |-------+<br>                               +-------| Q4    D4 |------+<br>                                +------| Q5    D5 |-----+<br>                                 +-----| Q6    D6 |----+<br>                                  +----| Q7    D7 |---+<br>                           PIOIN-------| EN*      | <br>                           LATCHIN-----| CK*      |<br>                                       +----------+</pre>
      </td>
    </tr>
  </tbody>
</table>
<p>The PIO port can be accessed at address &gt;5000 once the RS232 card
is active (this is done by setting CRU bit number 0 to 1). Note however
that the card can either send a byte or receive one, but not both
together.
Therefore we must first set the direction of transmission with CRU bit
1, this bit directly controls the DIR pin of the 74LS245 bus
transceiver
that buffers the PR-box bus. To read a byte, first set CRU bit 1 to
'1',
then read address &gt;5000. To send a byte, set CRU bit 1 to '0', then
write a byte to &gt;5000.</p>
<p>As you can see from the above schematic, data to/from the PIO port
is
latched by two 74LS373 D-type latches, one for input and one for
output.The
signals controlling these latches are generated by a custom control
chip,
with the exception of PIOOUT which comes directly from CRU bit 1. The
custom
chip also generates the CRU_I* and CRU_O* that control the CRU
interface
chips. One of the input of this control chip is connected to a jumper
that
allows to select either &gt;1300 or &gt;1500 as a CRU base address for
the card.</p>
<p>CRU bit 2 controls two of the spares lines: HANDSHAKEIN and
HANDSHAKEOUT.
Reading CRU bit 2 returns the current status of the HANDSHAKEIN line,
writting
to this bit sets the status of the HANDSHAKEOUT line.</p>
<p>The SPAREIN and SPAREOUT lines are controled by CRU bit 3, in the
same
manner. </p>
<p>Finally, CRU bit 4 is reflected onto itself. Whatever you write to
it
should be read back from it. This is a way to determine whether a RS232
card is installed.</p>
<p>CRU bits 5 and 6 control the CTS pins of the RS232 serial port,
they'll
be discussed <a href="#SerCircuit">later</a>.</p>
<p>CRU bit 7 turns the card light on in the PE-box, to signal the user
that the card is active. That's an unusual design since most of the
time
the light is controlled by CRU bit 0, together with the ROMs. May be TI
did this so that the light can indicate an ongoing transmission, rather
than just telling when the card is on.</p>
<h3><br>
<a name="PIOSample"></a>Sample programs</h3>
<p>Here are simple exemples on how to send and receive bytes through
the
PIO port, using the HANDSHAKEIN and HANDSHAKEOUT lines for
synchronisation.
This is an adaptation of the routines in the card ROM. The original
routines
check whether to use PIO or RS232, but I'm not including the RS232 part
here. Also R11 is saved in the scratch-pad, not in R10.</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre>* This routine sends 1 byte through the PIO port. The Byte is in R0. <br>* It assumes the card CRU is in R12 (&gt;1300).</pre>
      <pre>PIOUT  MOV  R11,R10        Save return point<br>       SBZ  1              Set PIO port as output <br>LP1    TB   2              See if receiver is ready (HANDSHAKEIN low)<br>       JNE  SK1            Yes, it is<br>       BL   @CLEAR         Test &lt;Clear&gt; key, abort if pressed<br>       JMP  LP1            Keep waiting</pre>
      <pre>SK1    MOVB R0,@&gt;5000      Send the byte <br>       SBZ  2              Set HANDSHAKEOUT low to signal a byte was sent <br>LP2    TB   2              Wait till acknowledged (HANDSHAKEIN high)<br>       JEQ  SK2<br>       BL   @CLEAR         Test &lt;Clear&gt; key, abort if pressed<br>       JMP  LP2            Keep waiting</pre>
      <pre>SK2    SBO  2              Reset HANDSHAKEOUT as high <br>       B    *R10</pre>
      </td>
    </tr>
  </tbody>
</table>
<p>The other computer would run the corresponding routine:</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre>* This routine receives 1 byte through PIO<br>* The byte will be placed in R0<br>* It assumes the card CRU is in R12 (&gt;1300)</pre>
      <pre>PIOIN  TB   2              Wait for HANDSHAKEIN to be high      <br>       JEQ  SK0            OK: sender is ready<br>       BL   @CLEAR         Not yet: test &lt;Clear&gt; key, abort if pressed <br>       JMP  PIOIN          Keep waiting</pre>
      <pre>SK0    SBO  1              Set PIO port as input<br>       SBZ  2              Set HANDSHAKEOUT low: we're ready to receive <br>LP1    TB   2              Did HANDSHAKEIN&nbsp;become low? <br>       JNE  SK1            Yes, it did<br>       BL   @CLEAR         Test &lt;Clear&gt; key, abort if pressed <br>       JMP  LP1            Keep waiting</pre>
      <pre>SK1    CLR  R0             The emmiter signaled a byte was sent <br>       MOV  @&gt;5000,R0      Get byte <br>       SBO  2              Acknowledge reception<br>       B    *R10           Return</pre>
      </td>
    </tr>
  </tbody>
</table>
<p>Of course, these are pretty crude routines. In particular, there is
no way to control the flow, nor to verify the integrity of the
tranmitted
data. Furthermore, they require that you first send the number of bytes
to follow:</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre>* This routine sends a bunch of bytes<br>SENDER LI   R1,NBYTES     Ptr to string of bytes to send <br>       MOV  *R1+,R2       First word is the # of bytes<br>       MOV  R2,R0<br>       BL   @PIOUT        Send the first half of it<br>       SWPB R0<br>       BL   @PIOUT        Send the second half                <br> <br>LP1    MOV  *R1+,R0       Get a byte<br>       BL   @PIOUT        Send it<br>       DEC  R2<br>       JNE  LP1           Next byte<br>       ...                Done</pre>
      <pre>NBYTES DATA &gt;0123         Number of bytes to send <br>       BYTE .....         Bytes to be sent</pre>
      <pre>*This routine receives a bunch of bytes<br>RECVER BL   @PIOIN        Receive # of bytes<br>       MOV  R0,R2         (passed as 2 bytes)<br>       SWPB R2<br>       BL   @PIOIN        Get the second half<br>       MOVB R0,R2<br>       SWPB R2            Make it a word<br>*      CI   R2,512        (Optional) check if we have room enough <br>*      JH   ERROR4        If not issue "memory full" error<br>       MOV  R2,@SIZE      Save size</pre>
      <pre>       LI   R1,BUFFER     Ptr to reception buffer<br>LP2    BL   @PIOIN        Receive a byte<br>       MOVB R0,*R1+       Save it<br>       DEC  R2<br>       JNE  LP2           Next byte<br>       ...                Done</pre>
      <pre>SIZE   DATA 0             Number of bytes that will be received <br>BUFFER BSS  512           Reception buffer<br>       </pre>
      </td>
    </tr>
  </tbody>
</table>
<p>The transmission protocol is thus the following:</p>
<pre><u>Sender                  Receiver     <br></u>                        Check it bit 2 is high (sender ready)<br>Wait for bit 2 low      Set bit 2 low: "ready to receive"<br>Send data               Wait for bit 2 low<br>Set bit 2 low: "sent"   Get the data<br>Wait for bit 2 high     Set bit 2 high: "I got it"<br>Set bit 2 high "ready"</pre>
<p>Note that in this protocol the sender speaks first. I mean that to
send
something we have to wait for the receiver to signal it's ready.
Another
scheme would be for the sender to activate HANSHAKEOUT when it wants to
send something and to wait for the receiver to acknowledge the change.
With the first scheme, the sender constantly checks whether the
receiver
is ready, with the second scheme the receiver constantly checks whether
the sender requests a transmission.</p>
<pre><u>Sender                   Receiver     <br></u>                         Check if bit 2 low (sender calling)<br>Set bit 2 low: "hello?" <br>Wait for bit 2 low       Set bit 2 low: "ready to receive"<br>Send data                Wait for bit 2 high<br>Set bit 2 high: "sent"   Get the data<br>Wait for bit 2 high      Set bit 2 high: "I got it"<br><br></pre>
<h2><br>
<a name="SerialPort"></a>Serial ports</h2>
<p>TheTI interface card comprises two RS232C serial ports combined in a
single connector.</p>
<h3><a name="SerPinout"></a>Pinout</h3>
<table border="1">
  <tbody>
    <tr>
      <th>Pin #</th>
      <th>I/O</th>
      <th>Function</th>
      <th>Access</th>
    </tr>
    <tr>
      <td>1</td>
      <td>-</td>
      <td>Ground</td>
      <td>-</td>
    </tr>
    <tr>
      <td>2</td>
      <td>I</td>
      <td>RD-1, data input</td>
      <td>CRU bits 0-7, base &gt;1340</td>
    </tr>
    <tr>
      <td>3</td>
      <td>O</td>
      <td>TX-1, data output</td>
      <td>CRU bits 0-7, base &gt;1340</td>
    </tr>
    <tr>
      <td>5</td>
      <td>O</td>
      <td>CTS-1, clear to send</td>
      <td>CRU bit 5, base &gt;1300</td>
    </tr>
    <tr>
      <td>6</td>
      <td>O</td>
      <td>DSR, data set ready</td>
      <td>Always 1 (+12V via 1.8 KOhm)</td>
    </tr>
    <tr>
      <td>7</td>
      <td>-</td>
      <td>Ground</td>
      <td>-</td>
    </tr>
    <tr>
      <td>8</td>
      <td>O</td>
      <td>DCD1, data carrier detected</td>
      <td>CRU bits 16, base &gt;1340</td>
    </tr>
    <tr>
      <td>12</td>
      <td>O</td>
      <td>DCD2, data carrier detected</td>
      <td>CRU bits 16, base &gt;1380</td>
    </tr>
    <tr>
      <td>13</td>
      <td>O</td>
      <td>CTS2, clear to send</td>
      <td>CRU bit 6, base &gt;1300</td>
    </tr>
    <tr>
      <td>14</td>
      <td>I</td>
      <td>RD2, data input</td>
      <td>CRU bits 0-7, base &gt;1380</td>
    </tr>
    <tr>
      <td>16</td>
      <td>O</td>
      <td>TX2, data output</td>
      <td>CRU bits 0-7, base &gt;1380</td>
    </tr>
    <tr>
      <td>19 (or 18)</td>
      <td>I</td>
      <td>DTR-2 (to DSR* and CTS*)</td>
      <td>CRU bits 27 or 28, base &gt;1380</td>
    </tr>
    <tr>
      <td>20 (or 11)</td>
      <td>I</td>
      <td>DTR-1 (to DSR* and CTS*)</td>
      <td>CRU bits 27 or 28, base &gt;1340</td>
    </tr>
    <tr>
      <td>4, 9, 15,17<br>
21, 21, 24, 25</td>
      <td>-</td>
      <td>Not connected</td>
      <td>-</td>
    </tr>
  </tbody>
</table>
<p>NB Some cards have jumpers to direct the DTR lines to either pin 19
or 18 and 20 or 11.</p>
<h3><br>
<a name="SerTheory"></a>Theory of operation </h3>
<p>Contrarily to a parallel port, the serial ports send a byte one bit
at a time. This is of course much slower, but it has one advantage: it
requires only one physical connection (two with the ground reference,
three
if you want bidirectional communications). This is much easier to
isolate
than a 8-bit bus and as a result serial transmission is much more
reliable
and works at longer distances than parallel transmission. Also think of
an infrared connector: for parallel transmission we would need 8
infrared
LEDs of different wavewelength in the emmiter and 8 photo-transistors,
each with a filter discriminating for only one LED. Not impossible, but
quite tricky. By contrast, a serial transmission requires only one LED
in the emmiter and one phototransistor in the receiver. The price to
pay
is that we need some kind of hardware to serialize a byte in the sender
and pack the received bits back in a byte in the receiver. Fortunately,
there are dedicated chips for that purpose: UART (Universal
Assynchronous
Receiver/Transmitter) and USRT (Universal Synchronous
Receiver/Transmitter).
There are also USART, i.e. chips that can operate either synchronously
or asynchronously. Synchronous serial transmission uses one more line
to
send a clock signal used to synchronized the sender and the receiver.
In
a way, it is already a first step toward parallelism... </p>
<p>Texas Instruments created their own UART chip, the TMS9902, and
their
USRT, the TMS9903, for use with the TMS9900 line of products. The
interface
card has two TMS9902 each in charge of a serial port.</p>
<h4>Signal encoding</h4>
<p>Here is a typical signal send over an asynchronous serial line:</p>
<pre>______      _________________________________________________      Logic 1<br>      |<u> st | D7 | D6 | D5 | D4 | D3 | D2 | D1 | D0 | Pa </u>| Sp |____ Logic 0<br><br></pre>
<h4>Data bits</h4>
<p>As you can see, 8 data bits were transmitted. This is by no mean an
absolute requirement:, we could have transmitted any number of data
bits:
5, 6, 7, 8, 9, 10, 11, etc. The only requirement is that the sender and
the receiver agree in advance on the number of bits that will be sent
as
a "character". Generally it will be 7 or 8. This is because a
byte is 8 bits on a computer. However, the ASCII code is limited to
characters
32-127, thus only 7 bits are needed to transmit pure text and setting
serial
transmission as 7-bit words will gain some time (about 10% when
compared
to 8-bit).. The TMS9902 can handle between 5 and 8 bits. Note that data
bits are transmitted starting with the least significant one, bit 7
according
to TI numbering convention.</p>
<h4>Start bit</h4>
<p>You will have noted that the data bits are enclosed between extra
bits:
a start bit (st) and a stop bit (Sp). One says that the transmitted
character
is "framed" by these control bits. The start bit is necessary
so that the receiver knows where the data starts: as there are only two
voltage levels, there is no way to differentiate an idle line from a
"space"
(logic 1 in our exemple). For instance, imagine that we send the
following
char 11001010, what the receiver sees is 00 0 0 and how shall it know
whether
we meant 00101011, 10010101 or 11001010? In other words, we must find a
way to mark the leading ones. We could use an extra connection that
would
provide a clock signal each time a bit is sent: this is called
synchronous
transmission and is dealt with by specialized chips: USRTs.
Asynchronous
transmissions use a different trick: a start bit is placed in front of
the others: <b>0</b>11001010. Now the receiver sees <b>0</b> 00 0 0,
knows
that the first 0 is the start bit and interprets the next two spaces as
1s: 11001010. Elegant, isn't it?</p>
<h4>Stop bit</h4>
<p>Similarly, a stop bit is appended at the end of the byte (Sp in the
scheme). A stop bit is merely the absence of a start bit: it just
provides
a pause to let the receiver resynchronize with the sender. Detection of
a low signal during that time generally indicates that sender and
receiver
are using different transmission speeds and results in an error
condition
(framing error). In the above example the stop bit has the same size
than
a regular bit, but it is possible for the TMS9902 to send a stop bit
equal
to 1.5 or 2 regular bits. </p>
<p>The start bit for the next char should come right after the stop
bit.
If this does not happen whithin a short time, the receiver interprets
it
as a "break" signal.</p>
<h4>Parity bit</h4>
<p>The parity bit (Pa in the scheme) is used to check for the integrity
of the transmission. The hardware counts the bits set as "1"
(not including start and stop) and uses the parity bit to tell the
receiver
whether the total of "1"s is odd or even. The receiver performs
the same check: if a bit was mangled during transmission the parity
will
be wrong. If more than one bit were affected, there is one chance out
of
two that the parity bit will be incorrect. The receiver can then issue
an error and ask the sender to transmit that byte again. </p>
<p>There are 5 possibly parity options: </p>
<ul>
  <li>Space: The parity bit is always 0. </li>
  <li>Mark: The parity bit is always 1. </li>
  <li>Even parity: The parity bit is 0 if there is an even number of 1s
in
the transmitted char. </li>
  <li>Odd parity: The parity bit is 0 if there is an odd number of 1s
in
the transmitted char. </li>
  <li>No parity: The parity bit is not sent.</li>
</ul>
<p>The first two types of parities are rarely used and the TMS9902 does
not support them. The next two are very common. With odd parity the
number
of "1" bits in the char plus the parity bit itslef will always
be odd (the harware adjusts the parity bit so that this is always
true).
With even parity, the number of "1" bits in the char plus the
parity bit itself is always even. Here also, sender and receiver must
agree
on what type of parity check will be used.</p>
<h4>Transmission rate</h4>
<p>The last issue is speed. This is not appearant from the diagram
above,
but the same sequence of bits could be sent at different speeds. Serial
transmission speeds are measured in bps (bits per second).
Transmissions
over a phone line are measured in bauds (the name comes from the french
mathematician J.M.E. Baudot). For low values bauds equal bps, however
there
is an upper limit to the number of bauds for a phone line. Todays
high-speed
modems manage to overcome that limit by using sophisticated compression
techniques, so you can have 28000 bps or even 56000 bps modems, but
strictly
speaking these aren't 28000 or 56000 bauds! Once more, sender and
receiver
must agree on the transmission speed prior to any transmission. </p>
<p>In summary the sender and the receiver must aggree on: transmission
speed, number of bits per char, parity type, number of stop bits. All
this
is often expressed in cryptic expressions like: 9600 8N1. This simply
means:
9600 bps, 8 bits per word, No parity, 1 stop bit.</p>
<h3><br>
<a name="Protocols"></a>Transmission protocols </h3>
<p>Now we have a way to reliably transfer one byte over a serial line
(or
on a parallel connection), but what if we want to transfer more than
one.
How does the sender tell the receiver where the byte stream starts or
ends?</p>
<h4><br>
<a name="XonXoff"></a>Xon/Xoff </h4>
<p>One way is to reserve special characters to serve as
start-of-message
and end-of-message marks. This is called the Xon/Xoff protocol and is
widely
used over so-called "null modems" (i.e.using no other connections
than the data lines). The major pain in the butt, is that the special
characters
cannot be part of the transmitted message. That's fine if we are
transmitting
text (since ASCII characters only use values from 32 to 127), but we'll
be in trouble if we want to send binary data.</p>
<p>Here is a list of all special characters reserved by the ASCII
convention.
Those were usefull for teletypes: terminals that could only
send/receive
characters. The "keyboard" column indicates the key combination
that will generate that code on the TI-99/4A (keyboard type 4).</p>
<table border="1">
  <tbody>
    <tr>
      <th>Hex</th>
      <th>Code</th>
      <th>Meaning</th>
      <th>Keyboard</th>
    </tr>
    <tr>
      <td>01</td>
      <td>SOH</td>
      <td>Start of heading</td>
      <td>Ctrl-A</td>
    </tr>
    <tr>
      <td>02</td>
      <td>STX</td>
      <td>Start of text</td>
      <td>Ctrl-B</td>
    </tr>
    <tr>
      <td>03</td>
      <td>ETX</td>
      <td>End of text</td>
      <td>Ctrl-C</td>
    </tr>
    <tr>
      <td>04</td>
      <td>EOT</td>
      <td>End of tasnmission</td>
      <td>Ctrl-D</td>
    </tr>
    <tr>
      <td>05</td>
      <td>ENQ</td>
      <td>Enquiry</td>
      <td>Ctrl-E</td>
    </tr>
    <tr>
      <td>06</td>
      <td>ACQ</td>
      <td>Acknowledge</td>
      <td>Ctrl-F</td>
    </tr>
    <tr>
      <td>07</td>
      <td>BEL</td>
      <td>Generate a beep</td>
      <td>Ctrl-G</td>
    </tr>
    <tr>
      <td>08</td>
      <td>BS</td>
      <td>Backspace</td>
      <td>Ctrl-H</td>
    </tr>
    <tr>
      <td>09</td>
      <td>HT</td>
      <td>Horizontal tab</td>
      <td>Ctrl-I</td>
    </tr>
    <tr>
      <td>0a</td>
      <td>LF</td>
      <td>Line feed (next line)</td>
      <td>Ctrl-J</td>
    </tr>
    <tr>
      <td>0b</td>
      <td>VT</td>
      <td>Vertical tab</td>
      <td>Ctrl-K</td>
    </tr>
    <tr>
      <td>0c</td>
      <td>FF</td>
      <td>Form feed (next page)</td>
      <td>Ctrl-L</td>
    </tr>
    <tr>
      <td>0d</td>
      <td>CR</td>
      <td>Carriage return (to first column)</td>
      <td>Ctrl-M</td>
    </tr>
    <tr>
      <td>0e</td>
      <td>SO</td>
      <td>Shift out</td>
      <td>Ctrl-N</td>
    </tr>
    <tr>
      <td>0f</td>
      <td>SI</td>
      <td>Shift in</td>
      <td>Ctrl-O</td>
    </tr>
    <tr>
      <td>10</td>
      <td>DLE</td>
      <td>Data link escape</td>
      <td>Ctrl-P</td>
    </tr>
    <tr>
      <td>11</td>
      <td>DC1</td>
      <td>Device Control 1</td>
      <td>Ctrl-Q</td>
    </tr>
    <tr>
      <td>12</td>
      <td>DC2</td>
      <td>Device Control 2</td>
      <td>Ctrl-R</td>
    </tr>
    <tr>
      <td>13</td>
      <td>DC3</td>
      <td>Device Control 3</td>
      <td>Ctrl-S</td>
    </tr>
    <tr>
      <td>14</td>
      <td>DC4</td>
      <td>Device Control 4</td>
      <td>Ctrl-T</td>
    </tr>
    <tr>
      <td>15</td>
      <td>NAK</td>
      <td>Negative acknowledge</td>
      <td>Ctrl-U</td>
    </tr>
    <tr>
      <td>16</td>
      <td>SYN</td>
      <td>Synchronous idle</td>
      <td>Ctrl-V</td>
    </tr>
    <tr>
      <td>17</td>
      <td>ETB</td>
      <td>End of transmission block</td>
      <td>Ctrl-W</td>
    </tr>
    <tr>
      <td>18</td>
      <td>CAN</td>
      <td>Cancel </td>
      <td>Ctrl-X</td>
    </tr>
    <tr>
      <td>19</td>
      <td>EM</td>
      <td>End of medium</td>
      <td>Ctrl-Y</td>
    </tr>
    <tr>
      <td>1a</td>
      <td>SUB</td>
      <td>Substitute</td>
      <td>Ctrl-Z</td>
    </tr>
    <tr>
      <td>1b</td>
      <td>ESC</td>
      <td>Escape</td>
      <td>Ctrl .</td>
    </tr>
    <tr>
      <td>1c</td>
      <td>FS</td>
      <td>File separator</td>
      <td>Ctrl :</td>
    </tr>
    <tr>
      <td>1d</td>
      <td>GS</td>
      <td>Group separator</td>
      <td>Ctrl =</td>
    </tr>
    <tr>
      <td>1e</td>
      <td>RS</td>
      <td>Record separator</td>
      <td>Ctrl-9</td>
    </tr>
    <tr>
      <td>1f</td>
      <td>US</td>
      <td>Unit separator</td>
      <td>Ctrl-8</td>
    </tr>
  </tbody>
</table>
<p>The "Old" and "Save" DSR routines in the TI interface
card make use of SYN, ACQ and NAK (see <a href="#RomDSR">below</a>).</p>
<h4><a name="RTSCTS"></a>RTS and CTS</h4>
<p>A way to overcome the necessity for special characters is to have
extra
connections that serve as handshake lines. This introduces some more
parallelism
into our serial connection, but it has the advantage of speeding the
transmission
a little. The RS232C standard defines two such pins: RTS send for
"Request
To Send" ("Can I send you data"), and CTS stands for "Clear
To Send" ("OK, send it"). </p>
<p>The sender initiates the transmission by activating the RTS line,
waits
for the receiver to answer by activating the CTS line. The sender then
sends data and wait for the receiver to ackowledge it by reseting the
CTS
line. </p>
<pre><u>Sender          Receiver     <br></u>                Wait for RTS <br>Activate RTS   <br>Wait for CTS    Activate CTS <br>Send data       Receive data <br>Reset RTS      <br>Wait for CTS    Reset CTS</pre>
<h4><br>
<a name="DSRDTR"></a>DSR and DTR </h4>
<p>These two extra lines provide a different type of handshake: they
are
meant to insure that both sender and receiver are online and ready to
operate.
DSR stands for "Data Set Ready" and is used by the receiver to
indicates that it's ready to operate. DTR stands for "Data Terminal
Ready" and is used by the sender to indicate that it's operational.
In other words, DSR and DTR are used by two devices to establish a
connection.
Once this is done, they can begins sending/receiving data and use the
RTS/CTS
protocol to control the flow of data.</p>
<pre><u>Sender                Receiver                 <br></u>                      Set DTR active <br>                      Check DSR <br>Wait for DTR <br>Set DSR active <br></pre>
<h4><a name="DCDRI"></a>DCD, RI and DSRD</h4>
<p>Those lines are meant for use with a modem. DCD stands for "Data
Carrier Detected" and is used by the modem to indicate that it is
receiving a carrier, i.e. a sound wave modulated to carry data bits.
DCD
should remain active as long as the connection is established.</p>
<p>RI stands for "Ring Indicator" and is used by the modem to
indicate that the phone is ringing. It thus signals that an external
device
would like to send data to the computer.</p>
<p>DSRD stands for "Data Signal Rate Detector". It is not always
present on RS232C plugs (it is on PCs 25-pins sockets, but not on 9-pin
sockets). This signal is used by either device to signal a change in
transmission
rate.</p>
<p>In the TI card, DCD is internally connected to DTR. RI and DSRD are
not implemented.</p>
<h4><a name="Duplex"></a>Simple vs duplex</h4>
<p>Two devices can communicate either in simplex mode, half-duplex or
dull-duplex
mode. </p>
<p>In simplex mode, one device is a dedicated sender and the other is a
dedicated receiver. By definition there will be only one data line (8
for
parallel ports), and possibly some synchronisation lines. Duplex means
that both devices can either send or receive data. With half-duplex
there
is still only one data line shared by both devices. This implies using
extra control lines so that the devices can agree on who is sending and
who is receiveing. By contrast, with full-duplex there are two data
lines:
one is used by device A to send data to B, the other is used by B to
send
data to A. Additional control lines may be used, but are optional.</p>
<p>This is a typical wiring for simplex connections: for instance a
printer
hooked to computer. The printer does not need to send data, at the most
a control line is used so that the printer can tell the computer when
data
is arriving too fast. </p>
<pre>               <b>Sender                             Receiver<br></b>       Sends data TX-----------------------------&gt;RD Receive data<br>                  RD&lt;-- nc                   nc---TX<br>    Always active RTS---.....(may be nc).......--&gt;RTS<br>                  CTS&lt;--.....(may be nc).......---CTS Always active<br>                  DCD&lt;----------------------------DCD Always inactive<br>Active when ready DTR----------------------------&gt;DTR<br>                  DSR&lt;----------------------------DSR Always active (or active when called)</pre>
<p>Half-duplex connections are much more tricky:</p>
<pre>               <b>Sender                             Receiver<br></b>       Sends data TX---+----------------------+--&gt;RD Receives data<br>    Receives data RD&lt;--'                      '---TX Sends data<br>   Active to send RTS----------------------------&gt;RTS<br>                  CTS&lt;----------------------------CTS Active to receive<br>                  DCD&lt;----------------------------DCD Active when needs to send<br>Active when ready DTR----------------------------&gt;DTR<br>                  DSR&lt;----------------------------DSR Always active (or active when called)</pre>
<p>Finally, here is an example of a full-duplex connection.</p>
<pre>               <b>Sender                             Receiver<br></b>       Sends data TX-----------------------------&gt;RD Receives data<br>    Receives data RD&lt;-----------------------------TX Sends data<br>    Always active RTS---.....(may be nc).......---&gt;RTS<br>                  CTS&lt;--.....(may be nc).......---CTS Always active<br>                  DCD&lt;----------------------------DCD <br>Active when ready DTR----------------------------&gt;DTR<br>                  DSR&lt;----------------------------DSR Always active (or active when ready)</pre>
<p>Here is an exemple of a duplex transmission between a computer and a
modem:</p>
<pre><u>Sender (computer)                   Receiver (modem)                                   <br></u>Standby: (DTR, RTS inactive)        Standby: RI, DCD inactive. (DSR, CTS inactive)<br>                                    Incoming call: activate RI<br>Acknowledge: Active DTR             Activate DSR<br>                                    Remote connection established: Activate DCD<br>Receive data on RD                  Sends data on RD<br>Wants to send: Activate RTS         Acknowledge: Activate CTS<br>Sends data over TX                  Receives data on TX<br>Break connection: inactivate DTR    Or hangup: inactivate DCD or DSR</pre>
<h4><a name="NullModem"></a>Null-modem connections</h4>
<p>A so-called null-modem designs a simple connection in which no
control
lines have been implemented. Concretely, the lines are reflected on the
machine they came from, so that it looks like the remote device is
always
answering immediately. Here is an example of a null-modem connection
between
a computer and a printer. Since the printer won't send any data to the
computer, the RD connection is not necessary. On the other hand, the
printer
may need to tell the computer to hold the flow of data until it had
caught
up with printing it. To this end, the BUSY pin on the printer may be
connected
to DSR on the computer.</p>
<pre>               <b>Sender (computer)                  Receiver (printer)<br></b>       Sends data TX-----------------------------&gt;RD Receives data<br>                  RD&lt;--------(optional)-----------TX <br>                  RTS---,                     ,---RTS<br>                  CTS&lt;--'                     '--&gt;CTS <br>                  DCD&lt;--, nc                  ,---DCD <br>                  DTR---+ nc                  +--&gt;DTR<br>                  DSR---'                     '---DSR <br>                  Gnd-----------------------------Gnd</pre>
<pre>    ( Optionally DSR&lt;----------------------------BUSY Hold transmission while printing)</pre>
<p>Here is a more complicated exemple: a null-modem connection between
two computers. In this case, the problem is that RTS in an output pin
on
both machines (as opposed to a dedicater receiver, like a printer,
where
RTS is an input pin). Conversely DCD is an input pin on both devices
(whereas
it is an ouput pin on a modem), etc. In other words, there is a sender
at both end of the connection! We therefore need some creativity in our
wiring if we want to respect the RS232C standards. If we don't care
about
that, the previous wiring will do just fine (without the BUSY line of
course).</p>
<pre>               <b>Sender (computer A)               Sender (Computer B)<br></b>       Sends data TX-----------------------------&gt;RD Receives data<br>    Receives data RD&lt;-----------------------------TX Sends data<br>                  RTS---+------------------------&gt;DCD                    <br>                  CTS&lt;--'<br>                  DCD&lt;-----------------------+----RTS<br>                                             '---&gt;CTS <br>                  DTR------------------------+---&gt;DSR<br>                                             '---&gt;RI <br>                  DSR&lt;--+-------------------------DTR<br>                  RI&lt;---'<br>                  Gnd-----------------------------Gnd</pre>
<h3><br>
<a name="TMS9902"></a>The TMS9902 </h3>
<p>This UART is meant to be used with a TMS9900 or equivalent CPU. All
the CPU access is performed via the CRU. There are 64 CRU bits
available,
some are read-only, some are write-only and some have different
meanings
whether read or written to.</p>
<p>The chip contains several registers: a read-only Receive buffer (8
bits)
and a write-only Emit buffer (8 bits) are used to store data
before/after
serialisation. Two Rate registers (11 bits) are used to specify the
transmission
speed, one for emission, one for reception. Generally both rates will
be
equal, but that's not always the case: the french Minitel system for
instance
has a high reception speed, but a slow emission speed. The TMS9902 also
comprises an Interval register (8 bits) that can be used as a countdown
timer and a Control register (8 bits) used to control several functions
of the chip.</p>
<p>The TMS9902 can generate interrupts on its INT* pin upon several
conditions:
when a bit arrives, when the buffer is full, when the timer fires, etc.
These interrupts are fed to the console via the EXTINT line and
processed
by the TMS9901 in the console as peripheral interrupts. The main
interrupt
service routine (ISR) in the console then scans every peripheral card
for
ISR and branches to it. The ISR in the TI interface card only deals
with
reception interrupts (<a href="#RomISR">see below</a>).</p>
<h4><a name="Pinout9902"></a>Pinout</h4>
<pre>       +----+--+----+ <br>  INT* |1 o       18| Vcc <br>  XOUT |2    T    17| CE*<br>   RIN |3    M    16| PHI*<br> CRUIN |4    S    15| CRUCLK <br>  RTS* |5         14| S0<br>  CTS* |6    9    13| S1<br>  DSR* |7    9    12| S2 <br>CRUOUT |8    0    11| S3<br>   GND |9    2    10| S4 <br>       +------------+</pre>
<p><u>Power supply<br>
</u><b>Vcc</b>: +5V <br>
<b>GND </b>: ground</p>
<p><u>CPU interface<br>
</u><b>CE*</b>: Chip enable. This pin is active (low) when the CRU
address
corresponds to the base address of the chip (&gt;134x or &gt;138x).<br>
<b>S0</b>-<b>S4</b>: These 5 input pins serve to select the proper CRU
bit to be accessed.<br>
<b>CRUIN</b>:<b> </b>This output line is used by the CPU to read CRU
bits
from the TMS9902<br>
<b>CRUOUT</b>:<b> </b>This input line is used by the CPU to write to a
CRU bit inside the TMS9902.<br>
<b>CRUCLK</b>:. CRU clock: this input line is activated by the CPU upon
CRU write operations, so that the TMS9902 can distinguish them from
regular
memory access.<br>
<b>INT*</b>: This output line is used by the TMS9902 to send an
interrupt
signal to the CPU.<br>
<b>PHI*</b>: This pin is used to input the main clock signal.</p>
<p><u>Serial interface<br>
</u><b>RIN</b>: Serial data input pin.<br>
<b>XOUT</b>: Serial data output pin.<br>
<b>RTS*</b>: This output pin is used by the TMS9902 to carry a
request-to-send
signal to the peripheral.<br>
<b>CTS*</b>: This input pin is used by the peripheral to tell the
TMS9902
it is clear to send data.<br>
<b>DSR*</b>: This input pin is used by the peripheral to tell the
TMS9902
that it is active (data set ready).<br>
Note: CTS* and DSR* are connected together in the TI card! They get
their
input from the DTR (data terminal ready) pin of the RS232 connector.</p>
<h4><a name="Operating9902"></a>Operating the TMS9902 </h4>
<p>All four write-only register map to the same CRU bits: the first 11
bits in the CRU address space of the chip (although some registers use
less than 11 bits). To write a value in a register, you must first tell
the TMS9902 which register you want to access. This is done with CRU
bits
11 to 14: </p>
<dt>CRU bit 14: Set as 1 to load the Control register. Then load 8
bits,
starting with CRU bit 0. <br>
CRU bit 13: Set as 1 to load the Interval register. Then load 8 bits
starting,
with CRU bit 0.</dt>
<dt>CRU bit 12: Set as 1 to load the Reception Rate register. Then load
11 bits, starting with CRU bit 0.</dt>
<dt>CRU bit 11: Set as 1 to load the Emission Rate register. Then load
11 bits, starting with CRU bit 0</dt>
<dt>When bits 11-14 are all 0, the emit register will be accessed: load
upto 8 bits, starting with CRU bit 0. </dt>
<dt>Each time you load the last bit of a register, the address changes
so that the next loading operation will access the next register. Thus,
if we first set bit 14 we can load all registers at a turn, with five
successive
LDCR instructions: first the control register, then the intervall
register,
then the two rate registers, and finally the emission register. (Note:
You can load both rate registers with a single LDCR operation, by
setting
both bit 12 and 11 to 1. The ROM routines in the TI card make use of
this
feature).</dt>
<h4><a name="ControlReg"></a>Control register</h4>
<p>This register is used to set various transmission parameters.</p>
<table border="2" cellspacing="2" cellpadding="2">
  <tbody>
    <tr>
      <th>Bit #</th>
      <td>7</td>
      <td>6</td>
      <td>5</td>
      <td>4</td>
      <td>3</td>
      <td>2</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>Name</th>
      <td>SBS1*</td>
      <td>SBS2</td>
      <td>PENA</td>
      <td>PODD</td>
      <td>CLK4M</td>
      <td>RCL2</td>
      <td>RCL1</td>
      <td>RCL0</td>
    </tr>
    <tr>
      <th>Meaning</th>
      <td colspan="2">00: 1.5 stop bit<br>
01: 2 stop bits<br>
1x: 1 stop bit</td>
      <td>0: No parity<br>
1: Parity enabled</td>
      <td>0: Even parity<br>
1: Odd parity</td>
      <td>0: 1/3 freq<br>
1: 1/4 freq</td>
      <td colspan="3">Record lenght: # of bits per char<br>
000=5, 001=6, 010=7, 011=8, <br>
      </td>
    </tr>
  </tbody>
</table>
<p>SBS1-2: Number of stop bits: 00=1.5, 01=2, 10=1.<br>
PENA: Parity enable: 0=no parity, 1=use parity.<br>
PODD: Parity odd/even: 0=even, 1=odd.<br>
RCL0-2: Number of bits per word.000=5, 001=6, 010=7, 011=8, 100=9 (?) .<br>
CLK4M: Console clock frequency divider. 0= divide PHI* by 3 to get the
main frequency, 1= divide PHI* by 4.<br>
*: Loading SBS1 cause the next load operation to access the interval
register.</p>
<p>Note: I've arranged bits in descending order because the LCDR
instruction
always starts loading with the least significant bit of the source
argument.
The table thus shows the bits as they need to be in the source of a
LCDR
instruction, which makes it easier to use.</p>
<h4><a name="RateReg"></a>Emission/Reception rate registers </h4>
<p>These registers are used to specify the speed of transmission for
reception:</p>
<table border="2" cellspacing="2" cellpadding="2">
  <tbody>
    <tr>
      <th>Bit #</th>
      <td>10</td>
      <td>9</td>
      <td>8</td>
      <td>7</td>
      <td>6</td>
      <td>5</td>
      <td>4</td>
      <td>3</td>
      <td>2</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>Name</th>
      <td>RDV8 *</td>
      <td>RDR9</td>
      <td>RDR8</td>
      <td>RDR7</td>
      <td>RDR6</td>
      <td>RDR5</td>
      <td>RDR4</td>
      <td>RDR3</td>
      <td>RDR2</td>
      <td>RDR1</td>
      <td>RDR0</td>
    </tr>
    <tr>
      <th>Meaning</th>
      <td>Div by 8</td>
      <td colspan="10">Frequency divider</td>
    </tr>
  </tbody>
</table>
<p>And for emission:</p>
<table border="2" cellspacing="2" cellpadding="2">
  <tbody>
    <tr>
      <th>Bit #</th>
      <td>10</td>
      <td>9</td>
      <td>8</td>
      <td>7</td>
      <td>6</td>
      <td>5</td>
      <td>4</td>
      <td>3</td>
      <td>2</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>Name</th>
      <td>XDV8</td>
      <td>XDR9</td>
      <td>XDR8</td>
      <td>XDR7</td>
      <td>XDR6</td>
      <td>XDR5</td>
      <td>XDR4</td>
      <td>XDR3</td>
      <td>XDR2</td>
      <td>XDR1</td>
      <td>XDR0</td>
    </tr>
    <tr>
      <th>Meaning</th>
      <td>Div by 8</td>
      <td colspan="10">Frequency divider</td>
    </tr>
  </tbody>
</table>
<p>RDR0-9: Divide the main frequency by this number to get the
reception
frequency.<br>
RDV8: Further divide the reception frequency by 8.<br>
XDR0-9: Divide the main frequency by this number to get the emission
frequency.<br>
XDV8: Further divide the emission frequency by 8.<br>
*: Loading RDV8 causes the next load operation to access the emission
rate
register.</p>
<h4>Frequency calculation</h4>
<li>The TMS9902 uses the PHI3 clock signal from the console as its main
frequency. The big drag is that there were two types of TI-99 consoles:
some have 3 mHz clocks, others have 2.5 mHz clocks. The latter are
pretty
rare, but still we cannot assume that the clock will always be 3 MHz,
we
must check for that. Fortunately, the clock speed is specified in the
console
ROM, at byte &gt;000C: if this byte is &gt;30 the console has a 3 MHz
clock,
if it's &gt;28 the clock is 2.5 MHz.</li>
<li>The TMS9902 divides this signal by 2 to derive its main frequency.</li>
<li>If the CLK4M bit is set in the control register, the main frequency
is further divided by 4, otherwise it is divided by 3. This comes handy
to produce some odd rates that are not powers of two.</li>
<li>If the RDV8 (or XDV8) bit is set in the rate register, the
frequency
is further divided by 8. </li>
<li>Finally, the frequency is divided by the number specified in the
rate
register, to get the transmission speed.</li>
<p>In summary, the transmission frequency can be calculated as:</p>
<pre>Ftrans = <u>       Fmain       </u>         <br>         2  * (8**RDV8) * RDR       </pre>
<pre>Fmain = <u>Phi3</u> or <u>Phi3</u> depending on CLK4M<br>         3       4</pre>
<pre>Phi3 = 3 Mhz or 2.5 Mhz depending on the console</pre>
<p>Here are the values to program in the rate register for the most
common
transmission rates (as used in the interface card ROM):</p>
<table border="1">
  <tbody>
    <tr>
      <th>Clock</th>
      <th colspan="2">2.5 MHz</th>
      <th colspan="2">3.0 MHz</th>
    </tr>
    <tr>
      <th>Rate (bps)</th>
      <th>CLK4M</th>
      <th>Rate register</th>
      <th>CLK4M</th>
      <th>Rate register</th>
    </tr>
    <tr>
      <td>110</td>
      <td>1</td>
      <td>&gt;563</td>
      <td>1</td>
      <td>&gt;5AA</td>
    </tr>
    <tr>
      <td>300</td>
      <td>1</td>
      <td>&gt;482</td>
      <td>1</td>
      <td>&gt;49C</td>
    </tr>
    <tr>
      <td>600</td>
      <td>1</td>
      <td>&gt;209</td>
      <td>1</td>
      <td>&gt;271</td>
    </tr>
    <tr>
      <td>1200</td>
      <td>0</td>
      <td>&gt;15B</td>
      <td>0</td>
      <td>&gt;1A1</td>
    </tr>
    <tr>
      <td>2400</td>
      <td>1</td>
      <td>&gt;082</td>
      <td>1</td>
      <td>&gt;09C</td>
    </tr>
    <tr>
      <td>4800</td>
      <td>1</td>
      <td>&gt;041</td>
      <td>1</td>
      <td>&gt;04E</td>
    </tr>
    <tr>
      <td>9600</td>
      <td>0</td>
      <td>&gt;02B</td>
      <td>1</td>
      <td>&gt;027</td>
    </tr>
  </tbody>
</table>
<h4><br>
<a name="IntervalReg"></a>Interval register</h4>
<p>This register can be used as a countdown timer. </p>
<table border="2" cellspacing="2" cellpadding="2">
  <tbody>
    <tr>
      <th>Bit #</th>
      <td>7</td>
      <td>6</td>
      <td>5</td>
      <td>4</td>
      <td>3</td>
      <td>2</td>
      <td>1</td>
      <td>0</td>
    </tr>
    <tr>
      <th>Name</th>
      <td>TMR7 *</td>
      <td>TMR6</td>
      <td>TMR5</td>
      <td>TMR4</td>
      <td>TMR3</td>
      <td>TMR2</td>
      <td>TMR1</td>
      <td>TMR0</td>
    </tr>
    <tr>
      <th>Meaning</th>
      <td colspan="8">Timer: # of cycles to countdown (1 for 64 clock
ticks)</td>
    </tr>
  </tbody>
</table>
<p>TMR0-7: countdown value. <br>
*: Loading TMR7 causes the next load operation to access the reception
rate register.</p>
<p>The counter will be decremented every 64 tick of the main clock (i.e
Phi/3 or Phi/4). When it reaches 0, CRU bit 25 is set to 1. If timer
interrupts
were enabled (by writing 1 to CRU bit 20), an interrupt is sent and CRU
bit 19 is set to 1 (as well as CRU bit 31, which is set by any
interrupt).
The countdown then resumes from the original value. If it reaches 0
again
and the previous countdown was not acknowledged (.e. CRU bit 25 was not
reset by writing to CRU bit 20), then an error occurs and CRU bit 24 is
set to 1. This way the user can know that the timer has cycled more
than
once.</p>
<p><u>In summary:<br>
</u>Writing to CRU bit 20 enables/disables timer interrupts.<br>
Loading the Interval register starts the timer (or stops it if 0 is
loaded).<br>
CRU bit 25 is set to 1 when the time has elapsed.<br>
CRU bit 24 is set to 1 when the time has elapsed and CRU bit 25 was
already
1.<br>
CRU bit 19 is set to 1 when the time has elapsed and timer interrupts
were
enabled.<br>
CRU bit 31 is set to 1 if an interrupt occured.<br>
CRU bits 19, 24 and 25 can be reset by writing to CRU bit 20.</p>
<p>For a 3 MHz console, the minimum interval on the timer is 64
micoseconds
and the maximum is 16.32 milliseconds, with a resolution of 64
microseconds.
By setting the CLK4M bit in the control register, these values become
48
microseconds to 12.24 milliseconds with a resolution of 48
microseconds.
I'll leave it to you to do the calculations for a 2.5 MHz console.</p>
<h4><br>
<a name="Interrupts"></a>Interrupts</h4>
<p>There are many conditions that may cause the TMS9902 to issue an
interrupt
. Each type of interrupt can be enabled/disabled by writing to a
specific
CRU bit. Also, each type of interrupt will set a specific CRU bit,
which
allows the user to determine the cause of the interrupt. Most of the
time,
reading the culprit bit will clear the interrupt condition and reset
that
bit.</p>
<table border="1">
  <tbody>
    <tr>
      <th>Interrupt issued when</th>
      <th>Set with</th>
      <th>Signaled by</th>
      <th>Signal cleared by</th>
    </tr>
    <tr>
      <td>Reception buffer is loaded</td>
      <td>CRU bit 18 </td>
      <td>CRU bit 16 </td>
      <td>CRU bit 18</td>
    </tr>
    <tr>
      <td>Emission buffer is empty</td>
      <td>CRU bit 19</td>
      <td>CRU bit 17</td>
      <td>Loading emission register</td>
    </tr>
    <tr>
      <td>Timer reached 0</td>
      <td>CRU bit 20</td>
      <td>CRU bit 19</td>
      <td>CRU bit 20</td>
    </tr>
    <tr>
      <td>CTS or DSR changed</td>
      <td>CRU bit 21</td>
      <td>CRU bit 20</td>
      <td>CRU bit 21</td>
    </tr>
    <tr>
      <td>Any of the above occured</td>
      <td>Always set</td>
      <td>CRU bit 31</td>
      <td>Reseting that interrupt</td>
    </tr>
  </tbody>
</table>
<h4><br>
<a name="Errors"></a>Error detection</h4>
<p>The TMS9902 can detect a variety of error conditions and several CRU
bits are used to indicate which error occured. </p>
<table border="1">
  <tbody>
    <tr>
      <th>Error condition</th>
      <th>Signaled by</th>
      <th>Signal cleared by</th>
    </tr>
    <tr>
      <td>Reception error (any of the next 3)</td>
      <td>CRU bit 9</td>
      <td>Error condition is cleared</td>
    </tr>
    <tr>
      <td>Parity error</td>
      <td>CRU bit 10</td>
      <td>Receiving a char with good parity</td>
    </tr>
    <tr>
      <td>Overflow (new bit received when buffer full)</td>
      <td>CRU bit 11</td>
      <td>Reception buffer is read</td>
    </tr>
    <tr>
      <td>Frame error (0 received instead of stop bit)</td>
      <td>CRU bit 12</td>
      <td>Receiving a char with correct stop bit</td>
    </tr>
    <tr>
      <td>Timer error (time elapsed twice)</td>
      <td>CRU bit 24</td>
      <td>Writing to CRU bit 20</td>
    </tr>
  </tbody>
</table>
<h4><br>
<a name="Monitoring"></a>Transmission monitoring</h4>
<p>If you need more sophisticated control over the transmission than
the
automated function provided by the UART, more CRU bits can be used for
this purpose.</p>
<table border="1">
  <tbody>
    <tr>
      <th>CRU bit</th>
      <th>I/O</th>
      <th>Function</th>
    </tr>
    <tr>
      <td>13</td>
      <td>I</td>
      <td>0: first data bit of a char has arrived<br>
1: all bits have arrived</td>
    </tr>
    <tr>
      <td>14</td>
      <td>I</td>
      <td>1: first data bit has arrived</td>
    </tr>
    <tr>
      <td>15</td>
      <td>I</td>
      <td>Logic level of the RIN pin</td>
    </tr>
    <tr>
      <td>21</td>
      <td>I</td>
      <td>1: Receive buffer contains a char<br>
(Reset by writing to bit 18)</td>
    </tr>
    <tr>
      <td>22</td>
      <td>I</td>
      <td>1: The emission buffer is empty<br>
0: A char has been loaded in the buffer</td>
    </tr>
    <tr>
      <td>23</td>
      <td>I</td>
      <td>0: Char emission in progress<br>
1: Nothing is emitted (XOUT is high)</td>
    </tr>
    <tr>
      <td>26</td>
      <td>I</td>
      <td>Logic level of the RTS pin (inverted)</td>
    </tr>
    <tr>
      <td>27</td>
      <td>I</td>
      <td>Logic level of the DSR pin (inverted)</td>
    </tr>
    <tr>
      <td>28</td>
      <td>I</td>
      <td>Logic level of the CTS pin (inverted)</td>
    </tr>
    <tr>
      <td>29</td>
      <td>I</td>
      <td>1: DSR or CTS has changed and is stable for 2 clock cycles<br>
(Reset by writing to bit 21)</td>
    </tr>
    <tr>
      <td>30</td>
      <td>I</td>
      <td>1: A register is being loaded or the break bit (17) is 1.</td>
    </tr>
    <tr>
      <td>15</td>
      <td>O</td>
      <td>1: Test mode RTS--&gt;CTS, XOUT--&gt;RIN, DSR=low,<br>
interval timer decremented every 2nd cycle (32x faster)</td>
    </tr>
    <tr>
      <td>16</td>
      <td>O</td>
      <td>1: Activate RTS (low)<br>
0: Inactivate RTS once emission is completed (and break bit is 0)</td>
    </tr>
    <tr>
      <td>17</td>
      <td>O</td>
      <td>1: Break on. XOUT=low, emission buffer cannot be loaded</td>
    </tr>
    <tr>
      <td>31</td>
      <td>O</td>
      <td>1: Reset. Set bits 11-14 to 1. Set bits 17-20 to 0 (no
interrupts)<br>
Empty emission and reception buffers, clear timer. No break, RTS=high<br>
No operation allowed for 11 clock cycles.</td>
    </tr>
  </tbody>
</table>
<h3><br>
<a name="SerProgram"></a>Sample programs</h3>
<p>Here is an example on how to set transmission parameters. For
routines
that <a href="#send">send</a> and <a href="#receive">receive</a> a
byte,
see below. For examples dealing with the interval register, see the <a
 href="#RomISR">interrupt
routine</a>.</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre>* This routine sets the transmission conditions for the first TMS9902 on card 1<br>      LI   R12,&gt;1300               CRU address of first interface card (use &gt;1500 for the second card, if any)<br>      SBO  0                       Turn card on<br>      AI   R12,&gt;0040               Address of first TMS9902 (use &gt;0080 for the second chip)<br>      SBO  14                      We want to load the control register<br>      LI   R0,&gt;0800                Divide Phi3 by 4                      <br>      ORI  R0,&gt;3000                Odd parity<br>      ORI  R0,&gt;0300                8 bits per char<br>      ORI  R0,&gt;8000                1 stop bit<br>      LDCR R0,8                    Load the control register<br>      SBO  12                      Let's skip the interval register<br>      LI   R0,&gt;009C                This boils down to 2400 bps<br>      LDCR R0,11                   Load the reception rate register<br>      LDCR R0,11                   Load same value in the emission rate register<br>      B    *R11</pre>
      </td>
    </tr>
  </tbody>
</table>
<h3><br>
<br>
<a name="Electrical"></a>Electrical characteristics</h3>
<h4>Absolute maximum ratings</h4>
<pre>Supply voltage:        -0.3 to +10V<br>Input/output voltages: -0.3 to +10V<br>Power dissipation:            0.55W<br>Free air temperature:    0 to 70 `C<br>Storage temperature:  -65 to 150 `C</pre>
<h4><br>
<br>
Recommended operating conditions</h4>
<table border="1">
  <tbody>
    <tr>
      <th>Parameter</th>
      <th>Min</th>
      <th>Nom</th>
      <th>Max</th>
      <th>Unit</th>
    </tr>
    <tr>
      <td>Supply voltage Vcc</td>
      <td>4.5</td>
      <td>5</td>
      <td>5.5</td>
      <td>V</td>
    </tr>
    <tr>
      <td>Supply voltage Vss</td>
      <td>.</td>
      <td>0</td>
      <td>.</td>
      <td>V</td>
    </tr>
    <tr>
      <td>High-level input voltage</td>
      <td>2</td>
      <td>.</td>
      <td>Vcc</td>
      <td>V</td>
    </tr>
    <tr>
      <td>Low-level input voltage </td>
      <td>Vss-0.3 </td>
      <td>.</td>
      <td>0.8</td>
      <td>V</td>
    </tr>
    <tr>
      <td>Free air temp</td>
      <td>0</td>
      <td>.</td>
      <td>70</td>
      <td>'C</td>
    </tr>
  </tbody>
</table>
<h4><br>
Characteristics under recommended conditions</h4>
<table border="1">
  <tbody>
    <tr>
      <th>Parameter</th>
      <th>Test conditions </th>
      <th>Min</th>
      <th>Typ</th>
      <th>Max</th>
      <th>Unit</th>
    </tr>
    <tr>
      <td>High-level output voltage </td>
      <td>I= -100 uA<br>
I= -200 uA</td>
      <td>2.4<br>
2.2</td>
      <td>.</td>
      <td>Vcc<br>
Vcc</td>
      <td>V</td>
    </tr>
    <tr>
      <td>Low-level output voltage</td>
      <td>I=3.2 mA</td>
      <td>Vss</td>
      <td>.</td>
      <td>0.4</td>
      <td>V</td>
    </tr>
    <tr>
      <td>Input current (any input)</td>
      <td>0 - Vcc</td>
      <td>.</td>
      <td>.</td>
      <td>10</td>
      <td>uA</td>
    </tr>
    <tr>
      <td>Average Vcc supply</td>
      <td>tc=330ns, TA=70'C </td>
      <td>.</td>
      <td>.</td>
      <td>100</td>
      <td>mA</td>
    </tr>
    <tr>
      <td>Small signal input capacitance </td>
      <td>f = 1 MHz</td>
      <td>.</td>
      <td>.</td>
      <td>15</td>
      <td>pF</td>
    </tr>
  </tbody>
</table>
<h3><br>
<a name="Timing"></a>Timing diagrams</h3>
<h4>CRU output</h4>
<pre>    |<u>tc=30</u>0-500 |_____   12-3<u>0  12</u>-30    _____  <br>____/  a  \<u>  b  </u>/    |\____|/    |\_____/     \________ PHI*<br><u>          __                      __           |25|    <br>X|  bit address n        |   bit address n+1      |XXXX</u> CRU address<br><u> |   </u> &gt;180 ns   |<br>     \<u> &gt;150 ns  |                                      </u> CE*<br>                  ___                     ___ <br>_________________/ c \___________________/   \_________ CRUCLK<br><u>          __                      __                   <br>X|  bit data out n       |   bit data out n+1    |XXXXX</u> A15/CRUOUT<br> |    &gt;180 ns   |</pre>
<pre>a) 0.45 - 0.55 Tc<br>b) 0.45 - 0.55 Tc<br>c) &gt;0.37 Tc</pre>
<h4><br>
CRU input</h4>
<pre>     <u>     </u>       <u>     </u>       <u>     </u>       <u>     </u>          <br>____/     \<u>     </u>/     \_____/     \_____/     \________ PHI*<br><u>          __                      __                   <br>X|  bit address n        |   bit address n+1      |XXXX</u> CRU address<br><u> |   </u> &lt;260 ns  |<br>     \<u> &lt;240 ns |                                       </u> CE*<br>               |                                       <br><u>               |                                       </u> CRUCLK<br><u>          __   |                   __                  <br>XXXXXXXXXXXXXXX| bit n |XXXXXXXXXXXXXXXX|bit n+1|XXXXXX</u> CRUIN<br></pre>
<h3><br>
<a name="SerCircuit"></a>Circuitery</h3>
<p>What I did not mention above, is that a serial port uses different
voltage
values than a parallel port. Typically, for a parallel port a logic 1
is
+5V and a logic 0 is 0V (gnd). However, for serial input connections a
logical 1 is any voltage between +3 to +15V and a logical 0 is an
voltage
between -3V and -15V. For output connections, a logical 1 is +5V to
+15V
and a logical 0 is -5V to -15V. These values are known as EIA signal
level
and allows for better transmission over longer distances. However, it
necessitates
special chips to handle the interface, since standard TTL chips only
operate
in the range 0 to +5V. The PE-Box power supply provides peripheral
cards
with +5V, +12V and -12V, therefore the serial ports on the card will
generate
+12V and -12V signals. They should however be able to input higher
voltage
values. </p>
<p>The interface chips used for output are two operational amplifiers,
TL082 and TL084, powered by +12V and -12V instead of +5V and 0V. For
input,
the card uses a 75189 Schmidt-trigger inverter. Other possibilities for
output would be: SN75150, SN75188, or MC1488. And for input: SN75152,
SN75154,
SN75189, SN75189A, MC1489, or MC1489A. All these guaranty transfer
rates
upto 20 kB over a 50-foot connection.</p>
<table cellspacing="2" cellpadding="2" bgcolor="#cccce6">
  <tbody>
    <tr>
      <td>
      <pre><b>PE-Box bus</b>      TMS9902                                               <b>RS232 plug<br></b>              +------------+      75189   330 Ohm        4.7K          <br>A10&gt;----------|S0      RIN |-------o&lt;|----www------------------------------&lt;RD-1<br>A11&gt;----------|S1      CTS*|---,  75189   330 Ohm  ,------www-----+5V <br>A12&gt;----------|S2      DSR*|---+---o&lt;|----www------+-----------------------&lt;DTR-1<br>A13&gt;----------|S3          |                       '-------||-----Gnd      <br>A14&gt;----------|S4          |  ,--www--+5V      36K     10 nF <br>A15/CRUOUT&gt;---|CRUOUT      |  |  1.8K       ,--www---, <br>CRUCLK&gt;-------|CRUCLK      |  |    10K      |   |\   |  150 Ohm   150 Ohm <br>CRUIN&lt;--------|CRUIN   XOUT|--+----www------+---|-\__+---www---+---www-----&gt;TX-1<br>              |            |               ,----|+/            '---||--Gnd <br> SEL*---------|CE*         |               |    |/TL084           10 nF <br>              |            |  ,--www--+5V  |   36K <br>PHI3*&gt;--------|PHI*        |  | 1.8K       | ,-www---, <br>           +--|INT*        |  |    10K     | |  |\   |  150 Ohm   150 Ohm <br>           |  |        RTS*|--+----www-----|-+--|-\__+---www---+---www-----&gt;DCD-1 <br>           |  +------------+               +----|+/            '---||--Gnd <br>           |                               |    |/TL084            10 nF <br>  INT*     |______74LS21                   | <br>  on other  +5V==<u>=</u>|)--+            200 Ohm |        200 Ohm <br>  TMS9902-------'     |      Gnd----www----+--------www---+5V <br>                      |                    | <br>EXTINT*&lt;--------------&lt;|---Gnd             |    |\TL082 <br>                   74LS125         10K     '----|+\__+---www---+---www-----&gt;CTS-1<br>  Cru bit 5-------------------+----www------+---|-/  | 150 Ohm |   150 Ohm <br>  (6 for CTS-2)               |             |   |/   |         '---||--Gnd <br>                              | 1.8K        '--www---'             10 nF <br>                              '--www--+5V      36K                 1.8K<br>                                                           +12V----www-----&gt;DSR</pre>
      </td>
    </tr>
  </tbody>
</table>
<p><u>Notes<br>
</u>This circuit exists in duplicate: one per TMS9902 chip (except for
DSR: there is only one).<br>
The SEL* signals are provided by the custom control IC that decodes the
CRU addresses. </p>
<h2><br>
<a name="CRU map"></a>CRU map</h2>
<p>Let's summarize the above in a map of the CRU bits used to access
the
interface card. Remember that the card base address is &gt;1300. It can
be set as &gt;1500 if you have two cards in a PE-Box, but for this you
need to physically modify the card. Nothing too difficult, just locate
the resistor labelled R5 and move it to the place labelled PTH1 (it
should
be just below it). Here is a <a href="rs_cru.jpg">picture</a> of a
card
bearing such a modification. </p>
<p>The second card will respond to DSRs RS232/3, RS232/4 and PIO/2, but
only if the first card is also installed, otherwise it will respond to
RS232, RS232/2 and PIO, just as if it were not modified.</p>
<p>Bits 0 through 7 control the card directly. The two TSM9902 are
installed
at &gt;1340 and &gt;1380 respectively. In the table below, I chose to
renumber
the bits from 0 in each chip, since this makes things easier to
understrand.
Furthermore, this is generally what the programmer will do: set R12 as
&gt;1340 instead of &gt;1300 so that LCDR and STCR instructions can be
used to load and read registers.</p>
<table border="1">
  <tbody>
    <tr>
      <th>Bit</th>
      <th>R12 address</th>
      <th>Meaning when read</th>
      <th>Effect when written</th>
    </tr>
    <tr>
      <td>0</td>
      <td>&gt;1300</td>
      <td>Always 0</td>
      <td>1: Turn card ROMs on</td>
    </tr>
    <tr>
      <td>1</td>
      <td>&gt;1302</td>
      <td>PIO direction 0=output 1=input</td>
      <td>0: Set PIO as output 1: Set PIO as input</td>
    </tr>
    <tr>
      <td>2</td>
      <td>&gt;1304</td>
      <td>Status of HANSHAKEIN pin (PIO)</td>
      <td>Set HANSHAKEOUT pin ( PIO)</td>
    </tr>
    <tr>
      <td>3</td>
      <td>&gt;1306</td>
      <td>Status of SPAREIN pin (PIO)</td>
      <td>Set SPAREOUT pin (PIO)</td>
    </tr>
    <tr>
      <td>4</td>
      <td>&gt;1308</td>
      <td>Read itself</td>
      <td>Writes to itself</td>
    </tr>
    <tr>
      <td>5</td>
      <td>&gt;130A</td>
      <td>Status of CTS1 pin</td>
      <td>Set CTS1 pin</td>
    </tr>
    <tr>
      <td>6</td>
      <td>&gt;130C</td>
      <td>Status of CTS2 pin</td>
      <td>Set CTS2 pin</td>
    </tr>
    <tr>
      <td>7</td>
      <td>&gt;130E</td>
      <td>Lamp status</td>
      <td>1: Lamp on</td>
    </tr>
    <tr>
      <td>0-7</td>
      <td>&gt;1340-134E</td>
      <td>Content of Receive buffer (8 bits)</td>
      <td rowspan="4">Value to load in selected register (11 bits)</td>
    </tr>
    <tr>
      <td>8</td>
      <td>&gt;1350</td>
      <td>-</td>
    </tr>
    <tr>
      <td>9</td>
      <td>&gt;1352</td>
      <td>1: Reception error (bit 10/11/12 =1)</td>
    </tr>
    <tr>
      <td>10</td>
      <td>&gt;1354</td>
      <td>1: Parity error</td>
    </tr>
    <tr>
      <td>11</td>
      <td>&gt;1356</td>
      <td>1: Overflow (bit arrived when buffer full)</td>
      <td>1: Load Emission-Rate register</td>
    </tr>
    <tr>
      <td>12</td>
      <td>&gt;1358</td>
      <td>1: Frame error (0 received as stop bit)</td>
      <td>1: Load Reception-Rate register (reset upon loading)</td>
    </tr>
    <tr>
      <td>13</td>
      <td>&gt;135A</td>
      <td>1: First bit has arrived</td>
      <td>1: Load Interval register (reset upon loading)</td>
    </tr>
    <tr>
      <td>14</td>
      <td>&gt;135C</td>
      <td>1: Receiving byte (for test purposes)</td>
      <td>1: Load Control register (reset upon loading)</td>
    </tr>
    <tr>
      <td>15</td>
      <td>&gt;135E</td>
      <td>1: Status of RIN pin</td>
      <td>1: Test mode (RTS-&gt;CTS, XOUT-&gt;RIN, timer*32)</td>
    </tr>
    <tr>
      <td>16</td>
      <td>&gt;1360</td>
      <td>1: Reception interrupt occured<br>
(reset by writing to bit 18)</td>
      <td>Set RTS pin (RTS=1 only if input bits 22+23=0)</td>
    </tr>
    <tr>
      <td>17</td>
      <td>&gt;1362</td>
      <td>1: Emission interrupt occured<br>
(reset by loading emission register)</td>
      <td>1: Abort transmission (XOUT=0 if bits 22+23=0)</td>
    </tr>
    <tr>
      <td>18</td>
      <td>&gt;1364</td>
      <td>-</td>
      <td>1: Enable reception interrupts</td>
    </tr>
    <tr>
      <td>19</td>
      <td>&gt;1366</td>
      <td>1: Timer interrupt occured<br>
(reset by writing to bit 20)</td>
      <td>1: Enable emission interrupts</td>
    </tr>
    <tr>
      <td>20</td>
      <td>&gt;1368</td>
      <td>1: CTS or RTS interrupt occured<br>
(reset by writing to bit 21)</td>
      <td>1: Enable timer interrupts</td>
    </tr>
    <tr>
      <td>21</td>
      <td>&gt;136A</td>
      <td>1: Receive register full<br>
(reset by writing to bit 18)</td>
      <td>1: Enable interrupts when CTS or DSR change</td>
    </tr>
    <tr>
      <td>22</td>
      <td>&gt;136C</td>
      <td>1: Emission register empty<br>
(reset by loading emission register)</td>
      <td>-</td>
    </tr>
    <tr>
      <td>23</td>
      <td>&gt;136E</td>
      <td>1: No data currently sent<br>
(shift register is empty)</td>
      <td>-</td>
    </tr>
    <tr>
      <td>24</td>
      <td>&gt;1370</td>
      <td>1: Timer error (time elapsed twice)<br>
(reset by writning to bit 20)</td>
      <td>-</td>
    </tr>
    <tr>
      <td>25</td>
      <td>&gt;1372</td>
      <td>1: Time elapsed<br>
(reset by writning to bit 20)</td>
      <td>-</td>
    </tr>
    <tr>
      <td>26</td>
      <td>&gt;1374</td>
      <td>Status of RTS pin (inverted)</td>
      <td>-</td>
    </tr>
    <tr>
      <td>27</td>
      <td>&gt;1376</td>
      <td>Status of DSR pin (inverted)</td>
      <td>-</td>
    </tr>
    <tr>
      <td>28</td>
      <td>&gt;1378</td>
      <td>Status of CTS pin (inverted)</td>
      <td>-</td>
    </tr>
    <tr>
      <td>29</td>
      <td>&gt;137A</td>
      <td>1: Change of DSR or CTS detected<br>
(reset by wrinting to bit 21)</td>
      <td>-</td>
    </tr>
    <tr>
      <td>30</td>
      <td>&gt;137C</td>
      <td>1: Register being loaded<br>
      </td>
      <td>-</td>
    </tr>
    <tr>
      <td>31</td>
      <td>&gt;137E</td>
      <td>1: An interrupt occured</td>
      <td>1: Reset. Output bits 11-14=1, bits 17-20=0<br>
Input bits 22,23=1, bits 13,21,25=0</td>
    </tr>
    <tr>
      <td>0-31</td>
      <td>&gt;1380-13BE</td>
      <td>Same at &gt;1340-137E for 2nd chip</td>
      <td>Ditto for second chip (RS232/2)</td>
    </tr>
  </tbody>
</table>
<p><br>
</p>
<h2><a name="CardROM"></a>The card ROM</h2>
<p>The TI interface card comprises 4096 bytes of ROM which provides the
software to use with the card. The ROM contains an interrupt routine
and
several DSR (device service routines) for file access. There is also a
power-up routine, but no subprograms. You'll find a commented
disassembly
listing of the whole ROM on my <a href="download.htm#disass">download </a>page.</p>
<h3>The power-up routine</h3>
<p>This is an extremely simple routine. All it does is:</p>
<ul>
  <li>Turn the light on.</li>
  <li>Set PIO as output (<tt>SBZ 1</tt>)</li>
  <li>Set HANDSHAKEOUT high (<tt>SBO 2</tt>).</li>
  <li>Reset both TMS9902 (by writing 1 to bit 31 in each chip).</li>
  <li>Turn the light off.</li>
  <li>Return with <tt>B *R11</tt>.</li>
</ul>
<h3><a name="RomDSR"></a>The DSRs</h3>
<p>The card ROM contains the following DSRs:</p>
<p><b>PIO</b>, <b>PIO/1</b>: Access to parallel port<br>
<b>PIO/2</b>: Ditto, on second card<br>
<b>RS232</b>,<b> RS232/1</b>: Access to first serial port on first card<br>
<b>RS232/2</b>: Access to second serial port on first card<br>
<b>RS232/3</b>: Access to first serial port on second card<br>
<b>RS232/4</b>: Access to second serial port on second card</p>
<p>As you can see, the DSRs are written to take into account the
possibility
of a second interface card installed in the PE-Box. A resistor on the
second
card is used to change its CRU address from &gt;1300 to &gt;1500
(although
the software will work with any pair of CRU addresses). When only one
card
is installed, it answers to the first set of DSRs, no matter what its
CRU
is. When two cards are present, the one with the highest CRU address
answers
to the second set of DSRs.</p>
<p>Changing the CRU address involves a small hardware modification:
transplanting
a resistor. It is described in <a href="rs_card.htm#CRU%20modif">here</a>.</p>
<p>When the console scanning routine calls a DSR, it has some key
values
stored at well defined places:</p>
<dt>&gt;8356 points to the first character after the DSR name in the
VDP
memory. This often will be a decimal point.</dt>
<dt>&gt;8354 contains the size of the DSR name, not counting any
decimal
pont.</dt>
<dt>R12 (&gt;83F8) contains the CRU of the card being called. This
information
is also saved in word &gt;83D0</dt>
<dt>R2 (&gt;83E4) contains the address of next link in the chain of DSR
routines. This information is also saved in word &gt;83D2</dt>
<dt>R9 (&gt;83F4) contains the address of the routine being called.</dt>
<dt>R11 (&gt;83F6) contains the return address to the scanning routine</dt>
<dt>R1(&gt;83E2) contains the number of time a routine with that name
was
called. Normally it is 1.</dt>
<ul>
  <li>The card DSR check the DSR name in VDP memory to know if the user
is
accessing the first card (RS232, RS232/1, RS232/2, PIO or PIO/1) or the
second (RS232/3, RS232/4, PIO/2). </li>
  <li>If the call is meant for the second card, the routine checks the
content
of R1 and returns with B *R11 if it is 1. This will cause the DSR
scanning
routine to keep looking for cards with the same DSR name in their ROMs.</li>
  <li>If the content of R1 matches the card number, the DSR is executed.</li>
</ul>
<p>Several modifiers can be appended to the DSR name, using decimal
points
as separators:</p>
<dt><b>.BA=xxx</b> Where xxx is the transmission speed. Legal values
are:
110, 300, 600, 1200, 2400, 4800 and 9600.</dt>
<dt><b>.DA=n</b> Where n is the number of bits per word. Accepted
values
are 7 and 8.</dt>
<dt><b>.TW</b> Causes two stop bits to be used. Otherwise only 1 is
issued.
No provision is made to use 1.5 stop bit, although the TMS9902 would
allow
for it.</dt>
<dt><b>.CH</b> Check for parity upon reception.</dt>
<dt><b>.PA=c </b>Parity type. Where c is N: no parity, E:even parity
or
O: odd parity.</dt>
<dt><b>.CR</b> Prevents a character 0d (CR) from being appended to each
record sent.</dt>
<dt><b>.LF</b> Prevents a character 0a (LF) and 0d (CR) from being
appended
to each record sent.</dt>
<dt><b>.EC</b> Echo off. When echo is on each character received will
be
sent back to the sender.<br>
.<b>NU</b> Append 6 null characters (&gt;00) to the end of Dis/Var
records.</dt>
<p>These parameters are stored in the scratch-pad RAM at the following
addresses:</p>
<p>&gt;834A-8353: Copy of PAB<br>
&gt;8354-5: Length of DSR name<br>
&gt;8356-7: Point after DSR name in the PAB (in VDP memory)</p>
<p>&gt;8358: Echo off (.EC)<br>
&gt;8359: No CR nor LF (.CR)<br>
&gt;835A: No LF (.LF)<br>
&gt;835B: Check for parity (.CH)<br>
&gt;835C: Add null chars (.NU)<br>
&gt;835D: Use interrupts (opcode &gt;80)</p>
<p>&gt;835E-F: Current rec #<br>
&gt;8360-1: Current rec size<br>
&gt;8364-D: Five buffers to save R11, used by different routines.</p>
<p>&gt;83DA-B: Copy of the Control register contents<br>
&gt;83DE-F: Copy of the Interval register contents</p>
<p>The DSR executes the following file operations: Open, Close, Read,
Write,
Load, and Save.The other opcodes (Rewind, Delete, Scratch and Status)
generate
an I/O error 3. In addition, the DSR accepts a special "Open"
opcode, &gt;80, that turns interrupts on.</p>
<p>If you are not familiar with PABs and their opcodes, <a
 href="headers.htm#PAB">read
this first</a>.</p>
<h4>Interrupt (&gt;80)</h4>
<ul>
  <li>Set the interrupt flag (&gt;835D)</li>
  <li>Branch to Open</li>
</ul>
<h4>Open (&gt;00)</h4>
<ul>
  <li>Set default flags as 300 7O1 (300 bps, 7 bits/char, odd parity, 1
stop
bit).</li>
  <li>Check for modifiers after the DSR name and adjust flags
accordingly.</li>
  <li>For PIO: set it as ouput with HANDSHAKEOUT high</li>
  <li>For RS232: reset the adequate TMS9902, then set its transmission
parameters
(with interrupts if opcode was &gt;80).</li>
  <li>Set default record length as 80, if 0 was specified in the PAB.</li>
  <li>Generate an I/O error 2 if the record type is relative.</li>
  <li>Branch to Exit.</li>
</ul>
<h4>Close (&gt;01)</h4>
<ul>
  <li>Set default flags as 300 7O1 (300 bps, 7 bits/char, odd parity, 1
stop
bit).</li>
  <li>Check for modifiers after the DSR name and adjust flags
accordingly.</li>
  <p><b>Exit</b>:</p>
  <li>Update the error flags (byte 1) and the character count (byte 5)
in
the PAB</li>
  <li>Set HANDSHAKEOUT high, PIO as output, turn the light off</li>
  <li>Return with INCT R11, B *R11</li>
</ul>
<h4>Read (&gt;02)</h4>
<ul>
  <li>Set default flags as 300 7O1 (300 bps, 7 bits/char, odd parity, 1
stop
bit).</li>
  <li>Check for modifiers after the DSR name and adjust flags
accordingly.</li>
  <li>If the file is internal, receive 1 byte (record size), generate
an
I/O error 4 if it's larger than the record length specified in the PAB.
Return if it is 0. </li>
  <li>If file is display, get the record size from the PAB.</li>
  <li>Receive the above number of chars. For each one do:</li>
  <ul>
    <li>If the file is internal (fixed of variable), save the char in
VDP buffer.</li>
    <li>If the file is display variable and echo is off: save the char
in VDP
buffer unless it is a CR. If it is CR update the number of characters
received
and branch to Exit.</li>
    <li>If the file is display variable and echo is on: emit that byte
then
save it in VDP buffer, unless it is CR (&gt;0D), DEL (&gt;7F) or FF
(&gt;12).</li>
    <ul>
      <li>If it is CR, update the number of characters received and
branch to
Exit. </li>
      <li>If it is FF, emit an end-of-record (&gt;0D, &gt;0A and 6x
&gt;00 according
to the .CR, .LF and .NU flags), then emit all bytes received until now.</li>
      <li>If it is DEL, decrement the VDP buffer pointer, emit the
previously
received char. If it was CR emit an end-of-record. Then receive next
char.</li>
    </ul>
    <li>If the file is display fixed and echo is off: save the char in
the
VDP buffer.</li>
    <li>If the file is display fixed and echo is on: emit that byte
then save
it in VDP buffer, unless it is DEL (&gt;7F) or FF (&gt;12).</li>
    <ul>
      <li>If it is FF, emit an end-of-record (&gt;0D, &gt;0A and 6x
&gt;00 according
to the .CR, .LF and .NU flags), then emit all bytes received until now.</li>
      <li>If it is DEL, decrement the VDP buffer pointer, emit the
previously
received char. If it was CR emit an end-of-record. Then receive next
char.</li>
    </ul>
  </ul>
  <li>Branch to close</li>
</ul>
<h4>Write (&gt;03)</h4>
<ul>
  <li>Set default flags as 300 7O1 (300 bps, 7 bits/char, odd parity, 1
stop
bit).</li>
  <li>Check for modifiers after the DSR name and adjust flags
accordingly.</li>
  <li>If the file is internal, emit the number of characters to be sent.</li>
  <li>Send the specified number of characters from the VDP buffer.</li>
  <li>If the file is Dis/Var emit an end-of-record: </li>
  <ul>
    <li>Emit a CR (&gt;0D) unless the .CR flag was specified.</li>
    <li>Emit six NULL (&gt;00) if the .NU flag was specified.</li>
    <li>Emit a LF (&gt;0A) unless the .CR or the .LF flag was specified.</li>
  </ul>
  <li>Branch to Close.</li>
</ul>
<h4>Save (&gt;06)</h4>
<p>Save is meant to transfer a whole file (in program format) to
another
TI-99/4A that will receive it with Load. Load sends the SYN character
to
signal the beginning of a transmission however since "program"
files can contain any character, none can be reserved as an end-of-file
mark. Therefore, Save must always send first the number of bytes that
will
follow (sent as a 2-byte number).</p>
<p>To ensure that transmission worked well, Save and Load use a CRC
(cyclic
redundency check) checking mechanism. Load sends either the ACK or the
NAK character to indicate whether thr CRC matches or not. </p>
<ul>
  <li>Set default flags as 300 8N1 (300 bps, 8 bits/char, no parity, 1
stop
bit). </li>
  <li>Check for modifiers after the DSR name and adjust flags
accordingly.
Only the following modifiers are recognized: .BA=n, .PA=c, .TW, .CH </li>
  <li>For PIO: set it as ouput with HANDSHAKEOUT high.</li>
  <li>For RS232: reset the adequate TMS9902, then set its transmission
parameters
  </li>
  <li>Synchronize with Load on the other machine: </li>
  <ul>
    <li>Receive characters until it is SYN (char &gt;16). </li>
    <li>For PIO, wait 14 usec (Why??) </li>
  </ul>
  <li>Send size:</li>
  <ul>
    <li>Emit the number of chars to be sent, as two bytes (msb, then
lsb).
    </li>
    <li>Calculate the CRC. </li>
    <li>Emit the CRC as two bytes. </li>
    <li>Receive 1 char. If it is not ACK (&gt;06), send size and CRC
again.
    </li>
  </ul>
  <li>Send the file by chunks of 256 bytes: </li>
  <ul>
    <li>Emit a chunk of 256 bytes (or what is left in last chunk). </li>
    <li>Calculate the CRC. </li>
    <li>Emit the CRC as two bytes. </li>
    <li>Receive 1 char. If it is not ACK (&gt;06) send the same chunk
(and
CRC) again. With PIO, first wait for 14 usec. </li>
  </ul>
  <li>Branch to Close </li>
</ul>
<h4>Load (&gt;05)</h4>
<ul>
  <li>Set default flags as 300 8N1 (300 bps, 8 bits/char, no parity, 1
stop
bit). </li>
  <li>Check for modifiers after the DSR name and adjust flags
accordingly.
Only the following modifiers are recognized: .BA=n, .PA=c, .TW, .CH </li>
  <li>For PIO: set it as ouput with HANDSHAKEOUT high </li>
  <li>For RS232: reset the adequate TMS9902, then set its transmission
parameters
  </li>
  <li>Synchronise with Save on the other machine: </li>
  <ul>
    <li>Emit the SYN character (&gt;16) </li>
    <li>Wait for HANDSHAKEIN (for PIO) or for DSR and character
received (for
RS232). Meanwhile check if Fctn-4 is pressed, abort if it is. </li>
    <li>If nothing happens, emit SYN again and keep waiting. </li>
  </ul>
  <li>Receive number of bytes to be transfered:</li>
  <ul>
    <li>Receveive two bytes.</li>
    <li>Calculate the CRC. </li>
    <li>Receive two bytes: CRC for the previous two. </li>
    <li>If if does not match the calculated one, emit NAK (char &gt;15)
and
try again. </li>
    <li>Check if the number of byte fits the buffer size. If not issue
I/O
error 4. If ok emit ACK (char &gt;06). </li>
  </ul>
  <li>Receive the appropriate number of bytes, 256 bytes at a time: </li>
  <ul>
    <li>Receives a chunk of 256 bytes (or what is left in the last
chunk).</li>
    <li>Calculate the CRC </li>
    <li>Receives two bytes: CRC for the previous 256. For PIO: wait 14
usec
(Why?) </li>
    <li>If CRC does not match the calculated one, emit NAK (&gt;15) and
try
again. Else emit ACK (&gt;06). </li>
  </ul>
  <li>Branch to close </li>
</ul>
<p><u>Correspondence between Load and Save</u></p>
<pre><b>Save                          Bytes       Load<br></b>Emit &lt;SYN&gt;                   ---1---&gt;     Wait for &lt;SYN&gt;<br>Emit size  &lt;------------+    ---2---&gt;     Receive size     &lt;-------------------------+<br>Emit CRC                |    ---2---&gt;     Receive CRC                                |<br>                        |                 If CRC wrong: emit &lt;NAK&gt; and retry---------+<br>Receive 1 char          |    &lt;--1---      else: emit &lt;ACK&gt;<br>If not &lt;ACK&gt;, resend----+                       </pre>
<pre>Emit 1 chunk &lt;----------+    --256--&gt;     Receive 1 chunk  &lt;--------------------------+<br>Emit CRC                |    ---2---&gt;     Receive CRC                                 |<br>                        |                 If CRC wrong: emit &lt;NAK&gt; and receive same --+<br>Receive 1 char          |    &lt;--1---      else: send &lt;ACK&gt;                            |<br>If not &lt;ACK&gt; send same--+                                                             |<br>Next chunk -------------+                 Next chunk ---------------------------------+<br>Close                                     Close</pre>
<p><br>
CRC calculation routine</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre>* This routine updates the current CRC value.<br>* R6 contains the byte received/emmited.<br>* The CRC value is in R9, it is initialised as &gt;FFFF (SETO R9)</pre>
      <pre>DOCRC  MOV  R6,R1         <br>       ANDI R1,&gt;FF00     Mask irrelevant bits<br>       XOR  R1,R9        XOR with CRC value<br>       MOV  R9,R1<br>       SRL  R1,4         Shift by 4<br>       XOR  R9,R1        XOR with new CRC value<br>       ANDI R1,&gt;FF00     Mask irrelevant bits<br>       SRL  R1,4         Shift by 4<br>       XOR  R1,R9        XOR with same CRC value<br>       SRC  R1,7         Shift by 7 (circular)<br>       XOR  R1,R9        XOR with new CRC value<br>       SWPB R9           Shift by 8 (circular)<br>       B    *R11</pre>
      </td>
    </tr>
  </tbody>
</table>
<p>If I'm not mistaken, this should correspond to a polynomial of x<sup>15</sup>+x<sup>11</sup>+x<sup>7</sup>+1.
See the disk controller page for a <a href="disks.htm#CRC">discussion </a>of
CRCs.</p>
<h4><br>
<a name="receive"></a>Serial reception routine</h4>
<p>The following is an adaptation of the reception routine in the card
ROM. The original routine checks whether to branch to use PIO or RS232,
but I'm only including the RS232 part. Also the two tests between LP1
and
SK1 are in a separate subroutine. Finally, R11 is saved in the
scratch-pad,
not in R10.</p>
<table bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre>* This routine receives 1 byte from the RS232 port<br>* It sssumes the port was properly set, and R12 contains the CRU base<br>* of the appropriate TMS9902 (i.e. &gt;1340 or &gt;1380)</pre>
      <pre>REC1BY MOV  R11,10           Save return point<br>LP1    TB   27               Test DSR pin (i.e. DTR on the connector)<br>       JNE  SK1              Line is high   <br>       TB   21               Line is low: test receive buffer<br>       JEQ  SK2              A byte is ready<br>SK1    BL   @CLEAR           Check &lt;Clear&gt; key, abort if pressed<br>       JMP  LP1              Else keep waiting</pre>
      <pre>SK2    CLR  R6               A byte was received<br>       STCR R6,8             Get it<br>       SBZ  18               Reset buffer bit 21 (use SBO 18 to allow interrupts)  <br>       TB   11               Was there an overflow?<br>       JEQ  ERROR6           Yes: I/O error #6<br>       TB   12               Was there a frame error (stop bit read as 0)?<br>       JEQ  ERROR6           Yes<br>       MOVB @PARCHK,R11      Flag: shall we check parity?<br>       JEQ  SK3              No<br>       TB   10               Yes: was there a parity error?<br>       JEQ  ERROR6           Yes<br>SK3    B    *R10             Return</pre>
      </td>
    </tr>
  </tbody>
</table>
<h4><br>
<a name="send"></a>Serial emission routine</h4>
<p>The following is an adaptation of the reception routine in the card
ROM. The original routine checks whether to branch to use PIO or RS232,
but I'm only including the RS232 part. Also R11 is saved in the
scratch-pad,
not in R10.</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre>* This routine sends 1 byte to the RS232 port. Byte is in R6.<br>* It sssumes the port was properly set, and R12 contains the CRU base<br>* of the appropriate TMS9902 (i.e. &gt;1340 or &gt;1380)</pre>
      <pre>EMI1BY MOV  R11,R10          Save return point<br>LP2    SBO  16               Set RTS pin low (DCD on the connector)<br>       TB   27               Test DSR pin (DTR on the connector)<br>       JNE  SK5              It's high: no answer yet<br>       TB   22               It's low: is emission buffer empty yet?<br>       JEQ  SK6              Yes: send previous byte now<br>SK5    BL   @CLEAR           Test &lt;Clear&gt; key, abort if pressed<br>       JMP  LP2              Keep waiting</pre>
      <pre>SK6    LDCR R6,8             Load next byte in emission buffer<br>       SBZ  16               Set RTS/DCD high (effective once buffer is empty) <br>       B    *R10             Return</pre>
      </td>
    </tr>
  </tbody>
</table>
<p>The expected connections are as follow:</p>
<pre>      Sender                           Receiver<br><u>TMS9902  Connector</u>                <u>Connector   TMS9902<br></u>XOUT-----&gt;TX -----------------------&gt;RD------&gt;RIN<br>RTS*-----&gt;DCD-----------------------&gt;DTR--+--&gt;DSR*<br>DSR*&lt;--,                                  '--&gt;CTS* <br>CTS*&lt;--+--DTR&lt;-----------------------DCD&lt;-----RTS*<br>RIN&lt;------RD&lt;------  optional  ------TX&lt;------XOUT</pre>
<p>and the transmission protocol is the following:</p>
<pre><u>Sender                            Receiver <br></u>                                  Check if DTR is low<br>Set DCD low                       <br>Wait for DTR to be low<br>Wait until done with previous     Wait for byte to fully arrive                 <br>Send next byte                    Read byte<br>                                  Check for transmission errors<br>Will set DCD high once done</pre>
<p>To send a whole bunch of bytes, there are two options: 1) First send
the number of bytes to be sent, then send them or 2) send all bytes
then
generate a break signal by keeping the line inactive for a time.</p>
<h3><br>
<a name="RomISR"></a>The ISR</h3>
<p>The interrupt service routine in the peripheral card is fairly
primitive,
some may even call it buggy...</p>
<ul>
  <li>It checks whether a reception interrupt occured, by testing CRU
bit
16 (reception interrupt, should be 1).</li>
  <ul>
    <li>If not, it checks if any interrupt came from the card, by
testing CRU
bit 31 (is 1 if an interrupt was issued).</li>
    <ul>
      <li>If not, it returns with <tt>B *R11,<font color="#000000"> </font></tt><font
 color="#000000">after
enabling interrupts in the second TMS9902 chip</font> (nasty bug!).</li>
      <li>If yes, it resets the card by executing the power-up routine
(big pain
in the butt!). Returns with <tt>B *R11</tt></li>
    </ul>
    <li>If a reception interrupt occured, the ISR saves the incoming
byte in
a circular buffer in VDP memory. The buffer address is in word
&gt;8300-01,
its size in byte &gt;8302.</li>
    <ul>
      <li>It gets a buffer write pointer from byte &gt;8304 (offset
from &gt;8300)
and increments it (or clears it, if it equals &gt;8302). This points to
the next available space in the circular buffer.</li>
      <li>It checks the buffer read pointer in byte &gt;8303 (offset
from &gt;8300).
If it was reached the buffer is full: the ISR replaces the previous
byte
with &gt;FE as a flag, and returns without modifying &gt;8304.</li>
      <li>Else it gets the incoming byte from CRU bits 0-7 and saves it
in the
buffer.</li>
      <li>If a reception error occured, it places &gt;FF in the buffer
instead
of the byte.</li>
      <li>It returns with<tt> B *R11.</tt></li>
    </ul>
  </ul>
</ul>
<p>As you can see, this routine is buggy: if the interrupt did not come
from the card, the second TMS9902 in the card will start generating
interrupts
whether this was intended or not!</p>
<p>Apart from this bug, the main trouble with this routine is that,
once
more, the TI engineers decided that we won't be allowed to use other
features
than the ones they have planed us to use. That's what I call the
MacIntosh
philosophy: "The average user is a complete moron. Let's make sure
he/she won't be allowed to fool around with our wonderfull machine".
In the present case, it means that we cannot use the interval timer to
generate an interrupt. We could set the timer, but when the interrupt
occurs
nothing will happen: the chip will just be reset.</p>
<p>There is a way around that for those of us that have an Horizon
Ramdisk:
the guys who wrote the DSRs for that disk did an incredibly good job
and
they notably allow the user to install a custom ISR on disk. If we set
the CRU address of the Ramdisk below that of the RS232 card, its ISR
will
be called before that of the RS232. It could thus check whether the
interrupt
was issued by the timer on the interface card. The routine should
install
itself in the memory expansion since the custom control chip may
require
interface card to be turned on (with CRU bit 0) for proper operation,
which
forces us to first turn off the Ramdisk.</p>
<p>Assuming all the above, here is what we would do:</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre>* Set the timer<br>SETIMR LI   R12,&gt;1340          Address of first TMS9902 on card 1<br>       SBO  31                 (Optional) Reset it<br>       LI   R0,&gt;xxxx           Delay = &gt;xxxx * 64 * 333 ns (for a 3 MHz console) <br>       SBO  13                 Next load will be in interval timer<br>       LCDR R0,11              Load value<br>       SBO  20                 Enable timer interrupts<br>       B    *R11</pre>
      <pre>* ISR installed in Ramdisk memory<br>MYISR  LI   R3,TIMISR          Points to timer ISR<br>       LI   R4,&gt;2000           Where to put it, in memory expansion<br>       LI   R5,ENDISR-TIMISR   Size in words<br>LP0    MOV  *R3+,*R4+          Copy ISR to low memory expansion<br>       DECT R5<br>       JNE  LP0<br>       B    @&gt;2000             Branch to it</pre>
      <pre>* This will run in the low memory expansion<br>TIMISR SBZ  0                  Turn Ramdisk off<br>       MOV  R12,R10            Save for return<br>       LI   R12,&gt;1300          CRU address of the card<br>       SBO  0                  Turn card on<br>       LI   R12,&gt;1340          CRU address of the first TMS9902<br>       TB   31                 Does the interrupt come from this chip?<br>       JNE  NOTME              Nope<br>       TB   19                 (Optional) Was it a timer interrupt?<br>       JNE  NOTME              Let the RS232 card ISR deal with reception interrupts <br>       TB   24                 Was there an overflow (missed interrupt)?<br>       JEQ  ERROR2             Do something if more time than expected has elapsed <br>       ...                     Do what needs to be done when timer fires<br>       SBO  20                 Reset flag (by enabling timer interrupts again)<br>*      C&nbsp;&nbsp;  *R11+,*R11+        Do not scan other cards (must do SBZ 0 ourselves)</pre>
      <pre>NOTME  LI   R12,&gt;1300          CRU address of the card<br>       SBZ  0                  Turn interface card off<br>       MOV  R10,R12            Restore old CRU base<br>       SBO  0                  Turn ramdisk back on<br>       B    *R11               Leave ISR<br>ENDISR</pre>
      </td>
    </tr>
  </tbody>
</table>
<address><br>
Preliminary version. 3/8/99. Not for release<br>
Revision 1. 5/31/99 Checked serial subroutines, ok to release<br>
Revision 2. 6/16/00 Got the TMS9902A manual! Added timing + electical
characteristics,
corrected pinout.</address>
<address>Revision 3. 8/28/00 Added a note on the ISR bug.<br>
Revision 4. 8/26/01 Added links to pictures page.<br>
Revision 5. 5/2/03 Corrected a typo: bit PIOOUT should be '0' for
output.<br>
<br>
</address>
<center>
<p><a href="titechpages.htm">Back to the TI-99/4A Tech Pages</a></p>
</center>
</body>
</html>
