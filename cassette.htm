<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
  <title></title>
  <meta http-equiv="Content-Type"
 content="text/html; charset=iso-8859-1">
  <meta name="GENERATOR"
 content="User-Agent: Mozilla/3.04Gold (Macintosh; I; PPC)">
</head>
<body>
<h1 align="center"><a
 href="http://www.nouspikel.com/ti99/titechpages.htm"><img
 src="logo.jpg" style="border: 0px solid ; height: 33px; width: 95px;"
 title="" alt=""></a></h1>
<h1>Cassette tape interface</h1>
<p>The TI-99/4A was issued with a built-in interface for cassette tape
recorders. This was meant as a cheap alternative to a disk drive. The
console
contains the necessary hardware to read from, write to, and control the
motor of two tape recorders. The relevant software is located in the
console
ROMs and GROMs. </p>
<p>Texas Instruments originally recommended the following recorders,
but
many others will work. I even used the one on my stereo, with
tune-tracking
system, etc. Most of the time the volume control should be set at
mid-range,
and the tone control (if any) at the highest possible pitch. <br>
&nbsp; </p>
<table border="1">
  <tbody>
    <tr>
      <th>Brand</th>
      <th>Model</th>
      <th>Volume set</th>
      <th>Tone set</th>
    </tr>
    <tr>
      <td>Superscope</td>
      <td>C2L00LP</td>
      <td>8.0</td>
      <td>N/A</td>
    </tr>
    <tr>
      <td>Panasonic</td>
      <td>RQ2309A</td>
      <td>5.0</td>
      <td>10</td>
    </tr>
    <tr>
      <td>Sears</td>
      <td>2165</td>
      <td>Mid Range</td>
      <td>N/A</td>
    </tr>
    <tr>
      <td>Sears</td>
      <td>21686</td>
      <td>Mid Range</td>
      <td>HI</td>
    </tr>
    <tr>
      <td>JC Penney</td>
      <td>6568</td>
      <td>Mid Range</td>
      <td>High</td>
    </tr>
  </tbody>
</table>
<p><b>Hardware<br>
</b><a href="#Connector">Connector</a> <br>
<a href="#Internal%20circuitery">Internal circuitery</a> <br>
<a href="#CRU%20map">CRU map</a> </p>
<p><b>Software<br>
</b><a href="#Direct%20control">Direct control</a> <br>
<a href="#Cassette%20tape%20format">Cassette tape format</a> <br>
<a href="#ROM%20routines">ROM routines</a> <br>
<a href="#DSRs%20in%20GROM">DSRs in GROM</a> </p>
<h2><br>
Hardware</h2>
<h3><a name="Connector"></a>Connector</h3>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ___________&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ( 1 2 3 4 5 )&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \ 6 7 8 9 /&nbsp;<br># I/O Use&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \_______/&nbsp;<br>- --- -------&nbsp;<br>1&nbsp; &gt;&nbsp; Cass 1 motor control<br>2&nbsp; &gt;&nbsp; Ditto (negative)<br>3&nbsp; &gt;&nbsp; Output to tape 1 or 2 (neg)<br>4&nbsp; &gt;&nbsp; Audio gate<br>5&nbsp; &gt;&nbsp; Output to tape 1 or 2&nbsp;<br>6&nbsp; &gt;&nbsp; Cass 2 motor control<br>7&nbsp; &gt;&nbsp; Ditto (negative)<br>8&nbsp; &lt;&nbsp; Input from tape 1<br>9&nbsp; &lt;&nbsp; Ditto (neg)</pre>
<p>Texas Instruments marketed a connection cable, with a 9-holes
connector
at one end, and 5 jacks at the other (three for one tape recorder, two
for the other). <br>
Pins 5 and 3 go to two jacks (on red cables) to be plugged in the the
microphone&nbsp;socket
on each recorder.&nbsp; Pins 8 and 9 go to a jack (on a white cable) to
be plugged in the "ear-plug" socket of&nbsp; recorder #1. Finally
pins 1 and 2 go to a smaller jack (on a black cable) to be plugged into
the remote control socket on recorder #1, while pins 6 and 7 play the
same
role for recorder #2. </p>
<p>As you see, only one recorder can be read from. I'm not sure why.
May
be because, if the output lines of two recorders are connected
together,
there is a risk that one is damaged when the other is outputing sound?<br>
</p>
<p>An important point is that the connections are polarised (see
circuitery
below). In particular, the remote-control jacks are connected to
transistors,
not to relays. This may cause some tape recorders to malfunction if
their
polarity is inverted with respect to that of the cassette jack. But
it's
a trivial job to build an adapter: get a male and a female jack and
just
cross their wires. I think you can even buy such adapters.</p>
<h3><br>
<a name="Internal circuitery"></a>Internal circuitery</h3>
<h4>Motor control</h4>
<table bgcolor="#cdcde6">
  <tbody>
    <tr>
      <td>
      <pre>TMS9901<br>----+<br>    |       ,---+5V<br>  P6|_____|/         Opto-isolator<br>    |     |\ TIS92    TIL119                         F<br>    |       V__________    ,---------+----+---------uuu---&gt; Pin 1<br>    |                  <u>|</u> |/          |    |   1nF         <b>CS1 motor<br></b>    |                  <u>V</u> |\________|/     '---||---Gnd    <b>jack<br></b>    |                  |           |\                     <br>    |                 Gnd      TIS92 V___,----------------&gt; Pin 2  <br>    |                                    |   1nF<br>    |       ,---+5V                      '---||---Gnd               <br>  P7|_____|/         Opto-isolator       <br>    |     |\ TIS92    TIL119                         F<br>    |       V__________    ,---------+----+---------uuu---&gt; Pin 6   <br>    |                  <u>|</u> |/          |    |   1nF         <b>CS2 motor<br></b>    |                  <u>V</u> |\________|/     '---||---Gnd    <b>jack</b>     |                  |           |\                     <br>----+                 Gnd      TIS92 V____,---------------&gt; Pin 7  <br>                                          |   1nF<br>                                          '---||---Gnd</pre>
      </td>
    </tr>
  </tbody>
</table>
<h4><br>
Magnetic output</h4>
<table bgcolor="#cdcde6">
  <tbody>
    <tr>
      <td>
      <pre>TMS9901<br>----+<br>    |   6.8K      1nF  5.6K<br>  P9|---WWW---+---||---WWW---+-------------------+---&gt; Pin 5<br>    |         |              |   200 Ohm         |   <b>Microphone</b>     |         = 0.1uF        +---WWW---Gnd   1nF =   <b>jacks<br></b>    |         |                                  |   <b>CS1 + CS2<br></b>----+        Gnd                           Gnd---+---&gt; Pin 3<br></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4><br>
Magnetic input</h4>
<table bgcolor="#cdcde6">
  <tbody>
    <tr>
      <td>
      <pre>                                  220pF<br>                               +---||---+<br>TMS                            |  39K   |<br>9901             120K          +--WWW---+ <br>---+          +--WWW---+       |    /|  | 6.8K  10nF           F<br>   |          |    /|  |  6.8K |   /6|--+--WWW--||--+---+-----uuu----&lt; Pin 8<br>   |     2.2K |   /3|--+--WWW--+__/7 |              |   |            <b>Ear-plug</b> P11|--+--WWW--+__/1 |  |          \  |              |   +--||--Gnd   <b>jack</b>    |  <u>|</u>          \  |  = 0.22uF    \5|--Gnd         |           F    <b>CS1<br></b>   |  <u>^</u> PG3992    \2|--+            \|              |       +--uuu---&lt; Pin 9<br>   |  |            \|  |           4558             | 15 Ohm|<br>   | Gnd         4558 Gnd                 ,---------+--WWW--+--||--Gnd<br>   |                                      |           5.6K  |  1nF<br>   |               +---WWW----------------'      Gnd---WWW--'<br>   |               |   10K<br>   |               |         +---WWW---+5V<br>   |               |         |   9.1K  <br>   |   12K     ,---+---WWW---+--------------------WWW-------+--------&gt; Pin 4<br> P8|---WWW---|/    |   10K   |    Sound chip      5.6K      |<br>   |         |\    = 10nF    |     TMS9919                  =<br>   |    TIS92  V___|         |   +---------+                |<br>   |               |         '---|AUDIOIN  |               Gnd<br>---+              Gnd            |         |<br>                                 +---------+</pre>
      </td>
    </tr>
  </tbody>
</table>
<h3><br>
<a name="CRU map"></a>CRU map</h3>
<table border="1" cellspacing="2" cellpadding="2">
  <tbody>
    <tr>
      <th>Bit</th>
      <th>R12 addr</th>
      <th>I/O</th>
      <th>Usage</th>
    </tr>
    <tr>
      <td>22</td>
      <td>&gt;002C</td>
      <td>O</td>
      <td>1: Turn motor on for recorder #1</td>
    </tr>
    <tr>
      <td>23</td>
      <td>&gt;002E</td>
      <td>O</td>
      <td>1: Turn motor on for recorder #2</td>
    </tr>
    <tr>
      <td>24</td>
      <td>&gt;0030</td>
      <td>O</td>
      <td>Audio gate 1: Silent input</td>
    </tr>
    <tr>
      <td>25</td>
      <td>&gt;0032</td>
      <td>O</td>
      <td>Data output to recorders #1 and #2</td>
    </tr>
    <tr>
      <td>27</td>
      <td>&gt;0036</td>
      <td>I</td>
      <td>Data input from recorder #1</td>
    </tr>
  </tbody>
</table>
<h2><br>
<br>
Software</h2>
<h3><a name="Direct control"></a>Direct control</h3>
<p>You can control the tape recorders directly, using the CRU bits
mentionned
above. Note that it does not have to be tape recorders... I'm thinking
of using the cassette port to hook-up two TI consoles and have a
debugger
program running on one and monitor the other. Communications would be
slow
(in serial mode by definition), but it would not require accessing any
peripheral card.</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre>* This routine performs some dummy cassette tape operations<br>* It assumes recorder #1 is set to record, and #2 to replay.    </pre>
      <pre>CSTEST LI   R12,&gt;0000             CRU address of the TMS9901<br>       SBO  23                    Turn motor on, recorder #2<br>       BL   @WAIT                 Let it reach cruising speed <br>       SBO  25                    Toggle output<br>       BL   @DELAY                Leave it so, for a while<br>       SBZ  25                    Toggle back<br>       ...                        etc.</pre>
      <pre>CSTES2 CLR  R12                   CRU address = &gt;0000<br>       SBO  22                    Motor on, recorder #1<br>       BL   @WAIT<br>       TB   27                    Get data from recorder<br>       JEQ  ...                   Do something<br>       JNE  ...   </pre>
      </td>
    </tr>
  </tbody>
</table>
<h3><br>
<br>
<a name="Cassette tape format"></a>Cassette tape format</h3>
<p>Texaz Instruments adopted a frequency modulation encoding system to
store data on tape. This is only a convention, and you may come up with
another, if you feel like it. Similarly, TI defined the format the data
should have whithin a tape file. Again, this is only a convention. <br>
&nbsp; </p>
<h4>Data encoding</h4>
<p>Bits are encoded by output level <i>changes</i>. With a 3 MHz
console,
the output toggles every 725.3 microseconds. To encode a 1, invert the
output in the middle of this time period:</p>
<pre> <u> 0 </u>&nbsp; 0&nbsp; _1&nbsp; _<u>0</u>_&nbsp; 1_&nbsp;&nbsp;1_&nbsp;&nbsp;0     Bits to encode<br>|   |___| |_|&nbsp;&nbsp; |_| |_| |___|&nbsp;&nbsp; Output (low/high)&nbsp;<br>c&nbsp;&nbsp; c&nbsp;&nbsp; c&nbsp;&nbsp; c&nbsp;&nbsp; c&nbsp;&nbsp;&nbsp;c   c   c   Clock intervals</pre>
<p><img src="sndgraph.jpg" alt="sound graph" height="155" width="426"><br>
<font size="-2">Courtesy Dean Corcoran</font></p>
<p>This results in frequencies of 689.37 Hz for a space (0) and 1379 Hz
for a mark (1) which is well within the audio range, thus suitable for
a tape player. In addition, I was told that you can connect the
cassette
port to a PC sound card and save/load programs as .wav files (The
"Scott
Adams compilation" CD ROM by Frank Traut uses this trick, if I'm well
informed).<br>
&nbsp; </p>
<h4>File format</h4>
<pre>Name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # of bytes Content&nbsp;<br>--------- ---------- --------&nbsp;<br>File sync&nbsp;&nbsp;&nbsp;&nbsp; 768&nbsp;&nbsp;&nbsp; &gt;00&nbsp;<br><br>Data mark&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp; &gt;FF&nbsp;<br>Size&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp; # of records&nbsp;<br>Repeat size&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp; ditto</pre>
<pre>Rec sync&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp; &gt;00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;<br>Data mark&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp; &gt;FF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } Rec 1&nbsp;<br>Data&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 64&nbsp;&nbsp;&nbsp; data bytes&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;<br>Checksum&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp; sum of the 64 data bytes&nbsp; }</pre>
<pre>Repeat rec 1</pre>
<pre>Rec 2&nbsp;<br>Repeat rec 2</pre>
<pre>etc.</pre>
<p><br>
At the beginning of the files are 768 zeros (&gt;300), for
synchronisation
purposes. The motor speed can vary a little from recorder to recorder
(not
too much, otherwise you would notice it when listening to music). So
the
tape reading routine in the console ROMs uses this stretch of zeros to
time the tape recorder. Once it has determine how long a "0"
bit lasts, it is a simple matter to detect a "1" which cuts this
interval in half. </p>
<p>The data mark signals the end of the sync stretch. It is followed by
the number of records, repeted twice (to ensure reading is correct). </p>
<p>Each record in the file is repeted twice. It begins with a short
sync
stretch of 8 zeros, followed by an &gt;FF data mark. The only allowed
file
format is Dis/Fix 64, so there is always 64 data bytes&nbsp; in a
record.
The record ends with a checksum: this is the sum of all 64 data bytes:
it is likely to be greater than 256, and thus requires two bytes.
However,
only the least significant byte is recorded on tape. </p>
<p>The tape reading routine calculates its own checksum while reading
data,
then compares it with the recorded value. If it does not match, the
routine
will get another chance, as the record repeats. If the checksum matches
the first time, the second repeat is just ignored. This format slows
down
cassette operations by a factor of two, but is more user-friendly:
since
a tape recorder is by definition sequential, a bad record that aborts
reading
forces you to start all over again, from the beginning of the file. In
the worst case, it means the file cannot be read. At least with this
method,
even if a record is unreadable its copy might still be good. The
probabilty
that both copies go bad is very low (the square of the probability that
one record goes bad). </p>
<p>There is no special end-of-file mark. Recording just stops after the
second repeat of the last record. <br>
&nbsp; </p>
<h3><br>
<a name="ROM routines"></a>ROM routines</h3>
<p>There are three cassette operating routines in the console ROM:
cassette
write, cassette read and cassette verify. All three can be called by
the
GPL opcode "I/O", with respectively 3, 4 or 5 as a source argument.
The destination argument consists in two words: the number of bytes to
transfer, and the VDP buffer address.</p>
<table border="1">
  <tbody>
    <tr>
      <th>Operation</th>
      <th>GPL I/O</th>
      <th>Address in ROM</th>
    </tr>
    <tr>
      <td>Write</td>
      <td>3</td>
      <td>&gt;1346</td>
    </tr>
    <tr>
      <td>Read</td>
      <td>4</td>
      <td>&gt;142E</td>
    </tr>
    <tr>
      <td>Verify</td>
      <td>5</td>
      <td>&gt;1426</td>
    </tr>
  </tbody>
</table>
<p>For obvious reasons, they all require precise timing and this is
done
by using the built-in timer in the TMS9901 interface controller chip,
which
is part of the console. The cassette routines enable the interrupt
function
of the TMS9901, which requires taking control of the interrupt service
routine. This is done by setting a flag bit (value &gt;20) in byte
&gt;83FD.
From now on, the console main ISR will treat any interrupt as issued by
the TMS9901 and branch to the cassette ISR at &gt;1404. If you are not
familiar with the concept of interrupts service routines (ISR) you may
want to have a look at the page on <a href="ints.htm">interrupts</a>,
as
well as at the page describing the <a href="tms9901.htm">TMS9901</a>.</p>
<p>What all this implies is that no other interrupt should be allowed,
and cassette routines begin by masking them off (by setting CRU bit 1
and
2 to 0 in the TMS9901). This would be necessary anyway, given the
nature
of a tape recorder: once you start reading you can't stop and come back
later, as the tape keeps running! A temporary interruption would mean
skipping
one or more records, which would force the user to start the cassette
operation
all over again.</p>
<table bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre>* This routine prepares for cassette interrupts<br>* It is adapted from the one in the console ROM (at &gt;13CC-13E0)</pre>
      <pre>SETCS  LI   R3,&gt;0023       Timer value (&gt;0011) plus clock bit, inverted<br>       CLR  R1             Flag: no vector in R6<br>       CLR  R12            Console CRU base<br>       SOC  @H0020,R14     Set bit &gt;0020 in &gt;83FD (WS is &gt;83E0 in GPL)<br>       SBZ  2              Disable VDP interrupts<br>       SBZ  12             This pin is not connected (INT12: +5V pull-up)<br>       LDCR R3,15          Load &gt;0011 in decrementer<br>       SBZ  0              Leave clock mode<br>       SBZ  1              Disable peripheral interrupts<br>       SBO  3              Enable clock interrupts<br>       B    *R11</pre>
      <pre>* This routine returns to normal operations<br>* It is found at &gt;155E-1570 in the console ROM</pre>
      <pre>CLRCS  SZC  @H0010,R14    Clear read/verify flag<br>       SZC  @H0020,R14    Clear cassette ints flag (byte &gt;83FD)<br>       SBZ  3             Disable cassette interrupts<br>       SBO  12            Enable interrupts by pin INT12 (nc)<br>       SBO  1             Enable VDP interrupts<br>       SBO  2             Enable peripheral interrupt<br>       B    *R11          The real routine returns to the GPL interpreter: <br>*      B    @&gt;0070</pre>
      </td>
    </tr>
  </tbody>
</table>
<h4>Cassette write</h4>
<p>Upon writing, the timing is ensured by loading &gt;0011 (i.e. 17)
into
the clock register of the TMS9901 chip. The resulting delay is: </p>
<pre>&nbsp;<u>&nbsp;&nbsp;&nbsp;&nbsp; 17&nbsp;&nbsp;&nbsp;&nbsp;</u> = 363.6 usec&nbsp;<br>&nbsp;(3MHz / 64)</pre>
<p>The write subroutine writes to the output by toggling CRU bit 19 and
entering a forever loop:</p>
<table bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre>HERE  JMP  HERE </pre>
      </td>
    </tr>
  </tbody>
</table>
<p>The only way to get out of this loop is via the interrupt that will
occur once the timer has elapsed. The cassette ISR checks whether the
main
program is trapped into such a loop and (if this is the case) returns
to
the next instruction, thereby effectively jumping out of the loop.</p>
<table bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre>* This routine writes a byte to the cassette. The byte is in R4. <br>* R8 contains either &gt;1E19 which means SBZ 19<br>* or &gt;1D19 which means SBO 19<br>* This routine is located in the console ROM at &gt;13E2-1402</pre>
      <pre>EMITBY LI    R6,&gt;0008      Bit counter: 8 bits per byte<br>       INV   R4            Invert the byte<br>LP1    JMP   LP1           Wait for an interrupt</pre>
      <pre>       X     R8            Toggle CRU bit 19<br>       XOR   @H0200,R8     Change SBZ to SBO and conversely<br>LP2    JMP   LP2           Wait for an interrupt</pre>
      <pre>       MOV   R4,R4         Test leftmost bit<br>       JLT   SK1           It's "1" (was "0" before inversion)<br>       X     R8            It's "0" (was "1"): toggle CRU bit 19<br>       XOR   @H0200,R8     Change SBO to SBZ and conversely<br>SK1    SLA   R4,1          Next bit<br>       DEC   R6            More to do?<br>       JNE   LP1           Yes<br>       B     *R11          No: return. R8 is ready for next byte</pre>
      </td>
    </tr>
  </tbody>
</table>
<p>And here is the infamous cassette-specific interrupt service routine:</p>
<table bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre>* Cassette ISR, located at &gt;1404-1422 in the console ROM.<br>* The main ISR enters it with WS &gt;83E0 if bit &gt;0020 is set in &gt;83FD</pre>
      <pre>CASISR SBZ  0              Make sure we're not in timer mode<br>       SBO  3              Clear pending interrupt (remain enabled) <br>       MOV  R1,R1          Flag: is there a vector in R6?<br>       JLT  SK2            Yes<br>       LWPI &gt;83C0          Back to ISR workspace<br>       C    *R14,@HERE     Is instruction at return point a forever loop? <br>       JNE  SK2            No: branch to vector in R6 (crashes if none!!)<br>       INCT R14            Skip the HERE JMP HERE<br>       RTWP                Return just outside the loop</pre>
      <pre>SK2    LWPI &gt;83C0          Branch to vector in R6, with ISR workspace<br>       MOV  @&gt;83E6,R14     AAAARGH! Overwrites the return address!!!<br>       RTWP                Branch, with no hope of return</pre>
      </td>
    </tr>
  </tbody>
</table>
<p>Now, all Write has to do is to use the above routines to send the
appropriate
bytes. Please refer to <a href="#Cassette%20tape%20format">file format</a>,
above.</p>
<ul>
  <li>Get # of bytes (round in up to next 64, derive the # of records)
and
the buffer address in VDP memory</li>
  <li>Initialize cassette interrupts (with SETCS above)</li>
  <li>Allow interrupts with <tt>LIMI 1</tt></li>
  <li>Send &gt;300 times byte &gt;00 (file synchronisation)</li>
  <li>Send byte &gt;FF once</li>
  <li>Send # of records, twice</li>
  <li>Send data in 64 bytes records. Each record is sent twice:</li>
  <ul>
    <li>Send 8 times byte &gt;00 (record sync)</li>
    <li>Send byte &gt;FF once</li>
    <li>Send 64 bytes</li>
    <li>Send checksum as two bytes</li>
  </ul>
  <li>Wait for interrupt</li>
  <li>Branch to CLRCS (return to GPL interpreter, which resets LIMI 0)</li>
</ul>
<h4><br>
Cassette read</h4>
<p>The Read subroutine also makes use of the timer to time the
stretches
of "0" bits in the sync field at the beginning of each record.
First it loads the maximum value (&gt;3FFF) in the TMS9901 timer and
waits
for 8 bits to arrive. Then it reads the timer and see how much time has
elapsed. It uses 8 bits rather than just one to get an average value.</p>
<table bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre>* This routine checks whether the input toggled. <br>* If yes, it returns with B *R11<br>* If no, it returns with INCT R11, B *R11<br>* R1(lsb) contains the previous value of the input (&gt;xx00 or &gt;xxFF)<br>* It's located at &gt;15BA-15D2 in the console ROM </pre>
      <pre>ISTOGL TB   27            Check tape input port<br>       JEQ  ISONE         It's 1<br>       CZC  @H00FF,R1     It's 0. What was it before?<br>       JEQ  NOTOGL        It was 0: no toggle<br>TOGGLE XOR  @H00FF,R1     Save new value<br>       B    *R11          Return, signaling a toggle</pre>
      <pre>ISONE  CZC  @H00FF,R1     Input is 1. What was it before?<br>       JEQ  TOGGLE        It was 0: toggle detected<br>NOTOGL INCT R11           It was 1: signal no toggling <br>       B    *R11          Return</pre>
      <pre>* This routine makes use of the above to time the cassette recorder <br>* It assumes a &gt;00 byte is coming and waits for the input to<br>* toggle 8 times.</pre>
      <pre>TIMECS LI   R9,&gt;7FFF      Timer value &gt;3FFF, plus clock bit    <br>       LI   R8,&gt;0008      Count 8 toggling<br>       LDCR R9,15         Load the decrementer<br>       SBZ  0             Leave clock mode (which starts the timer)<br>       SBO  3             Enable interrupts (in case no toggle occurs) <br>LP3    @ISTOGL            Check if input toggled<br>       JMP  YES           Yes, it did<br>       JMP  LP3           Not yet<br>YES    DEC  R8            More to count?<br>       JNE  LP3           Yes</pre>
      <pre>       SBO  0             Enter clock mode<br>       STCR R3,15         Get value remaining in timer<br>       S    R3,R9         Calculate # of times it was decremented <br>       MOV  R9,R3         Multiply by 5<br>       SLA  R9,2<br>       A    R9,R3<br>       SRL  R3,6          Divide by 64<br>       ORI  R3,&gt;0001      Add clock bit<br>       CI   R3,&gt;001F      Check if resonnable value<br>       JLT  AGAIN         Too fast (not &gt;00): reinit and try again<br>       ...                (Actually, jumps to SK3 in GETBIT, below)<br>       LDCR R3,15         Load new value<br>       SBZ  0             Leave clock mode<br>       SBO  3             Enable timer interrupts<br>       ...<br></pre>
      </td>
    </tr>
  </tbody>
</table>
<p>Once this value has been determined, it is fed to the timer for
further
reading operations. If the timer fires before the output toggles, the
incoming
bit is a "0". If the output toggles while the timer is still
mid-way to zero, the incoming bit is a "1". Simple enough, no?</p>
<table bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre>* This routine receives a bit. It uses the toggle detection routine above.<br>* Once done, it resets the timer with the value calculated above (in R3).<br>* It is located at &gt;1572-159E in the console ROM</pre>
      <pre>GETBIT MOV  R11,R10<br>LP0    JMP  LP0           Wait for interrupt  <br>       BL   @ISTOGL       Check if input toggled<br>       INCT R10           No: bit is "0"</pre>
      <pre>       ORI  R1,&gt;FF00      Flag for ISR: use vector in R6 if times out<br>SK3    CZC  @H00FF,R1     What is the detected input status?<br>       JEQ  LP5           It's 0<br>LP4    TB   27            It's 1. We must wait until it toggles again<br>       JNE  LP5           It did. Now wait for a 1<br>       JMP  LP4           Not yet, keep waiting</pre>
      <pre>LP5    TB   27            Wait till input toggles back to 1<br>       JNE  LP5           Not yet, keep waiting</pre>
      <pre>       LDCR R3,15         Reload delay in clock<br>       SBZ  0             Leave clock mode<br>       SBO  3             Enable timer interrupts<br>       ANDI R1,&gt;00FF      Clear ISR flag<br>       XOR  @H00FF,R1     Update last input bit<br>       B    *R10</pre>
      <pre>* This routine receives a byte. <br>* It uses the above one to build the byte in R4. <br>* It is located at &gt;15A0-15B8 in the console ROM.</pre>
      <pre>GETBY  LI   R8,&gt;0008      Bit counter: 8 bits per byte<br>       CLR  R4            Init byte<br>       MOV  R11,R9        Save return point<br>LP6    SLA  R4,1          Next bit<br>       BL   @GETBIT       Get it<br>       JMP  SK4           It was a "0"<br>       INC  R4            It was a "1": put it in R4<br>SK4    DEC  R8            More to do?<br>       JNE  LP6           Yes<br>       A    R4,R7         Build checksum in R7<br>       B    *R9           Return</pre>
      </td>
    </tr>
  </tbody>
</table>
<p>Now, here is how Read works:</p>
<ul>
  <li>Get max # of bytes (derive max # of records) and buffer address</li>
  <li>Initialize cassette interrupts (see SETCS above) with a default
delay
of &gt;0015</li>
  <li>Receive all records:</li>
  <ul>
    <li>Allow interrupts with LIMI 1</li>
    <li>Set ISR vector in R6 to come here</li>
    <li>Wait a long time. If it is elapsed, return with Cnd bit set in
&gt;837C.</li>
    <ul>
      <li>Receive bytes until 6 in a row are &gt;00 (12 for top of file)</li>
      <li>Times the tape recorder with TIMECS, put the new value in
timer</li>
      <li>Receive bits until 8 are "1" (i.e. the &gt;FF mark arrived)</li>
      <li>Set ISR vector to "try once more, then error"</li>
      <li>At top of file, get the number of records:</li>
      <ul>
        <li>Receive one byte</li>
        <li>If higher than max # allowed, return with Cnd bit and error
bit (&gt;01)
in &gt;837C</li>
        <li>Receive the 2nd copy. If different return with error</li>
      </ul>
      <li>Elsewhere, get a record:</li>
      <ul>
        <li>Receive 64 bytes, transfer them to VDP buffer</li>
        <li>Receive the checksum byte. Check if it matches</li>
        <ul>
          <li>If not try once more. Then return with Cnd bit and error
bit in &gt;837C</li>
          <li>If checksum matches the first time, skip the repetition
of the record</li>
        </ul>
      </ul>
    </ul>
    <li>Next record</li>
  </ul>
  <li>Branch to CLRCS</li>
</ul>
<h4><br>
Cassette verify</h4>
<p>This routine is nothing more than a cassette read that compares the
incoming data with the content of the buffer, instead of filling the
buffer
with them. If a mismatch occurs, the routine returns with bits &gt;21
set
in &gt;837C (GPL status byte).</p>
<ul>
  <li>Set flag to indicate verify: bit &gt;0010 in R14 (byte &gt;83FD)</li>
  <li>Set VDP to read from data buffer, rather than to write to it</li>
  <li>Enter the Read subroutine</li>
</ul>
<h3><br>
<a name="DSRs in GROM"></a>DSRs in GROM</h3>
<p>There are two DSR in the first console GROM: <b>CS1 </b>and <b>CS2</b>.
They can be found as GROM addresses: &gt;1320-16DC. As you might
expect,
CS1 deals with the first tape recorder, and CS2 with the second. These
are unusually high-level DSRs, that directly interact with the user.
For
instance, they display prompting messages on screen and wait for the
user
to press a key. It is one of the rare occurences when byte 8 in the PAB
is effectively used to pass a screen bias to a DSR. </p>
<p>By the way, the prompting messages are send by calling a subprogram,
whose name is &gt;03. It must be called with the screen address in
&gt;8364
and the a string number in &gt;8362. This number (0 to 32, by steps of
2) is an offset into a table of 2-byte long string pointers located at
GROM address &gt;15A0. For some strings, the subprogram also adds the
cassette
number (CS1 or CS2) to the string and displays "then press enter".
In any case it beeps by calling the "accept tone" GROM routine
at &gt;0034. </p>
<p>As mentionned above, the file type must be display, variable 64, and
sequential. In addition, CS2 can only be opened for output (as recorder
#2 cannot be read from). </p>
<h4>Open </h4>
<ul>
  <li>Set record length to 64, of none is provided in the PAB. Else
round
it up to 64</li>
  <li>If file "variable" or "relative" return with "Illegal
opcode" code in PAB byte 1</li>
  <li>If file is opened as "update" or "append" return
with "Illegal opcode" code in PAB byte 1</li>
  <li>If file is opened as "input":</li>
  <ul>
    <li>If cassette is CS2, return with "Illegal opcode" code in
PAB byte 1</li>
    <li>Turn motor on. Wait for 30 VDP interrupts (0.5-0.6 sec).</li>
    <li>Display "Rewind cassette tape. Then press enter". Beep</li>
    <li>Call GETKEY</li>
    <li>Turn motor off. Wait for 30 VDP interrupts (0.5-0.6 sec). Beep</li>
    <li>Display "Press cassette play. Then press enter". Beep</li>
  </ul>
  <li>If file is opened as "output":</li>
  <ul>
    <li>Turn motor on. Wait for 30 VDP interrupts (0.5-0.6 sec).</li>
    <li>Display "Rewind cassette tape. Then press enter". Beep</li>
    <li>Call GETKEY</li>
    <li>Turn motor off. Wait for 30 VDP interrupts (0.5-0.6 sec). Beep</li>
    <li>Display "Press cassette record. Then press enter". Beep</li>
  </ul>
  <li>Call GETKEY</li>
  <li>Turn motor on.. Wait for 30 VDP interrupts (0.5 sec. 0.6 sec for
european
consoles).</li>
  <li>Wait for 300 VDP interrupts (10 seconds. 12 sec for european
consoles).</li>
  <li>Turn motor off.. Wait for 30 VDP interrupts (0.5-0.6 sec).</li>
  <li>Goto EXIT</li>
  <p><b>EXIT</b></p>
  <li>Turn motor on. Wait for 30 VDP interrupts (0.5-0.6 sec)</li>
  <li>Scroll up one line, move cursor to column 1</li>
  <li>Return to Basic (or caller, whatever it is)</li>
  <p><b>GETKEY</b></p>
  <li>Wait for a key to be pressed</li>
  <li>If it is &lt;enter&gt; </li>
  <ul>
    <li>Return to caller</li>
  </ul>
  <li>If it is &lt;R&gt;:</li>
  <ul>
    <li>Re-enter DSR from the beginning</li>
  </ul>
  <li>If it is &lt;C&gt;:</li>
  <ul>
    <li>Goto CHECK</li>
  </ul>
  <li>If it is &lt;E&gt;:</li>
  <ul>
    <li>Set error code for "Device error" in PAB byte 1</li>
    <li>Display "Press cassette stop. Then press enter". Beep</li>
    <li>Call GETKEY</li>
    <li>Goto EXIT</li>
  </ul>
  <li>If another key was pressed, keep waiting</li>
  <p><b>CHECK</b></p>
  <li>Display "Rewind cassette tape. Then press enter". Beep</li>
  <li>Call GETKEY</li>
  <li>If &lt;enter&gt; was pressed. turn motor off. Wait for 30 VDP
interrupts
(0.5-0.6 sec). Beep</li>
  <li>Display "Checking". Beep</li>
  <li>Wait for the beep to end</li>
  <li>Call cassette verify ROM routine with GPL opcode I/O 6</li>
  <li>If no error occured:</li>
  <ul>
    <li>Display "Data OK". Beep</li>
    <li>Goto Close</li>
  </ul>
  <li>If an error occured:</li>
  <ul>
    <li>Turn motor off. Wait for 30 VDP interrupts (0.5-0.6 sec). Beep</li>
    <li>Check the error bit (value &gt;01) was set in &gt;837C:</li>
    <ul>
      <li>If set, display "Error detected in data". Beep</li>
      <li>Else display "Error - no data found". Beep</li>
    </ul>
    <li>Check opcode:</li>
    <ul>
      <li>For "Save", display "Press R to record, C to check,
E to exit". Be-be-beep</li>
      <li>For others, display "Press R to read, C to check, E to exit".
Be-be-beep</li>
    </ul>
    <li>Call GETKEY</li>
    <li>Re-enter DSR from the beginning</li>
  </ul>
</ul>
<h4><br>
Close </h4>
<ul>
  <li>Turn motor off. Wait for 30 VDP interrupts (0.5-0.6 sec).</li>
  <li>Display "Press cassette stop. Then press enter". Beep</li>
  <li>Call GETKEY</li>
  <li>Goto EXIT</li>
</ul>
<h4><br>
Read </h4>
<ul>
  <li>Copy record length in character count</li>
  <li>Turn motor on. Wait for 30 VDP interrupts (0.5-0.6 sec).</li>
  <li>Call the ROM routine, with GPL opcode I/O 5. Number of bytes
taken
from record length.</li>
  <li>If Cnd bit set when returning, an error occured:</li>
  <ul>
    <li>Set error code for "Device error" in PAB byte 1</li>
    <li>Display "Press cassette stop. Then press enter". Beep</li>
    <li>Call GETKEY</li>
    <li>Goto EXIT.</li>
  </ul>
  <li>Else turn motor off. Wait for 30 VDP interrupts (0.5-0.6 sec).</li>
  <li>Goto EXIT</li>
</ul>
<h4><br>
Write </h4>
<ul>
  <li>Turn motor on. Wait for 30 VDP interrupts (0.5-0.6 sec).</li>
  <li>Call the ROM routine, with GPL opcode I/O 4. Number of bytes
taken
from record length.</li>
  <li>If Cnd bit set when returning, an error occured:</li>
  <ul>
    <li>Display "Press cassette stop. Then press enter". Beep</li>
    <li>Call GETKEY</li>
    <li>Goto EXIT.</li>
  </ul>
  <li>Turn motor off. Wait for 30 VDP interrupts (0.5-0.6 sec).</li>
  <li>Goto EXIT</li>
</ul>
<h4><br>
Restore</h4>
<ul>
  <li>Same as Open</li>
</ul>
<h4><br>
Load</h4>
<ul>
  <li>If cassette is CS2, return with "Illegal opcode" code in
PAB byte 1</li>
  <li>Turn motor on. Wait for 30 VDP interrupts (0.5-0.6 sec).</li>
  <li>Display "Rewind cassette tape. Then press enter". Beep</li>
  <li>Call GETKEY</li>
  <li>Turn motor off. Wait for 30 VDP interrupts (0.5-0.6 sec). Beep</li>
  <li>Display "Press cassette play. Then press enter". Beep</li>
  <li>Wait for the beep to end</li>
  <li>Call the ROM "Read" routine, with GPL opcode I/O 5. Number
of bytes PAB bytes 6-7.</li>
  <li>If Cnd bit set when returning, an error occured:</li>
  <ul>
    <li>Turn motor off. Wait for 30 VDP interrupts (0.5-0.6 sec). Beep</li>
    <li>Check the error bit (value &gt;01) was set in &gt;837C:</li>
    <ul>
      <li>If set, display "Error detected in data". Beep</li>
      <li>Else display "Error - no data found". Beep</li>
    </ul>
    <li>Display "Press R to read, C to check, E to exit". Be-be-beep</li>
    <li>Call GETKEY</li>
    <li>Re-enter DSR from the beginning</li>
  </ul>
  <li>If no error occured, display "Data OK". Beep</li>
  <li>Goto Close</li>
</ul>
<h4><br>
Save</h4>
<ul>
  <li>Turn motor on. Wait for 30 VDP interrupts (0.5-0.6 sec).</li>
  <li>Display "Rewind cassette tape. Then press enter". Beep</li>
  <li>Call GETKEY</li>
  <li>Turn motor off. Wait for 30 VDP interrupts (0.5-0.6 sec). Beep</li>
  <li>Display "Press cassette record. Then press enter". Beep</li>
  <li>Wait for 600 VDP interrupts, i.e 10 seconds (12 sec for european
consoles).</li>
  <li>Call the ROM routine, with GPL opcode I/O 4. Number of bytes
taken
from PAB bytes 6+7.</li>
  <li>Turn motor off. Wait for 30 VDP interrupts (0.5-0.6 sec).</li>
  <li>Display "Press cassette stop. Then press enter". Beep</li>
  <li>Call GETKEY</li>
  <li>If cassette is CS2, goto EXIT</li>
  <li>Display "Check tape (Y or N)?".Beep</li>
  <li>Wait for &lt;Y&gt; or &lt;N&gt; to be pressed:</li>
  <ul>
    <li>If &lt;N&gt; goto EXIT</li>
    <li>If &lt;Y&gt; goto CHECK</li>
  </ul>
</ul>
<h4><br>
Delete </h4>
<ul>
  <li>Same as Close</li>
</ul>
<h4><br>
Scratch record</h4>
<ul>
  <li>Set error flags for "Illegal opcode" in PAB, byte 1.</li>
  <li>Goto EXIT</li>
</ul>
<h4><br>
Status&nbsp; </h4>
<ul>
  <li>Clear byte 6 in PAB (should be byte 8, but used for bias)</li>
  <li>Goto EXIT</li>
</ul>
<address><br>
Preliminary 4/1/99 </address>
<address>Revision 1 4/3/99 Polished, OK to release<br>
&nbsp; </address>
<center>
<p><a href="titechpages.htm">Back to the TI-99/4A Tech Pages</a></p>
</center>
</body>
</html>
