<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
  <title></title>
  <meta name="Author" content="">
  <meta name="GENERATOR"
 content="Mozilla/3.04Gold (Win95; U) [Netscape]">
</head>
<body>
<h1 align="center"><a
 href="http://www.nouspikel.com/ti99/titechpages.htm"><img
 src="logo.jpg" style="border: 0px solid ; height: 33px; width: 95px;"
 title="Back to main index" alt=""></a></h1>
<h1>Multitasking the TI-99/4A</h1>
<p>This page introduces the concept of multitasking and describes a
package
that I put together to let you write multitasked programs in the
following
languages:</p>
<ul>
  <li>TI-Basic (with the Editor/Assembler or Mini-memory cartridge
plugged
in)</li>
  <li>Extended Basic</li>
  <li>Assembly language</li>
  <li>GPL </li>
</ul>
<p>The package can be downloaded as a zip file: <a href="tasks.zip">tasks.zip</a>.
It should expand into three "disks" files on your PC: one contains
the Basic &amp; Extended Basic sub-package, the second contains the
Assembly
and the third the GPL sub-package. (Due to lack of space one of the
assembly
files, <tt>TASKS/EQU</tt>, was placed on the GPL disk). See my <a
 href="download.htm">download</a>
page for instructions on how to transfer them to your TI-99/4A. </p>
<p>In addition, the zip file contains a Winword file called
"multitasking.doc"
which is the reference manual for this package. The rest of this page
is
basically an "HTML-ized" version of said manual.</p>
<p><b>An introduction to multitaking<br>
</b><a href="#Package">Contents of the package<br>
</a><a href="#principles">General principles<br>
</a><a href="#coop%20vs%20preemptive">Cooperative vs preemptive<br>
</a><a href="#critical">Critical sections<br>
</a><a href="#priority">Task priority<br>
</a><a href="#Synchro">Tasks synchronization<br>
</a><a href="#Instances">Instances<br>
</a><a href="#Using%20schedulers">Using the schedulers</a></p>
<p><b>Multitasking Basic and Extended Basic<br>
</b><a href="#Basic">Introduction<br>
</a><a href="#sync">Tasks synchronization<br>
</a><a href="#critic%20&amp;%20endcri">Critical sections<br>
</a><a href="#Basic">I</a><a href="#instances&amp;local">nstances and local
variables</a></p>
<p><b>Multitasking Assembly language<br>
</b><a href="#Assembly">Introduction<br>
</a><a href="#set%20priority">Setting priorities<br>
</a><a href="#task%20sync">Task synchronization<br>
</a><a href="#critical%20&amp;%20coop">Critical sections<br>
</a><a href="#switch-time">Switch-time routine<br>
</a><a href="#instances&amp;local%20mem">Instances &amp; local memory<br>
</a><a href="#TCBs">TCB: Task control blocks</a></p>
<p><b>Multitasking GPL<br>
</b><a href="#GPL">Introduction<br>
</a><a href="#context%20saving">Context saving<br>
</a><a href="#XMLs">XML routines</a></p>
<h2><br>
<a name="intro"></a>Introduction to multitasking</h2>
<p>Multitasking is the art of executing simultaneously several
programs,
or executing several lines of execution within the same program, which
is called multithreading. True multitasking is only possible on
computers
that have more than one processor. On most home computers there is only
one processor, so only one task can run at a time. In such a case, the
best substitute for true multitasking is time-sharing, i.e. each task
will
run for a fraction of a second, then the computer switches to the next
task. When switching occurs 50 times per second or so, the human user
is
under the illusion that tasks run simultaneously (except that of
course,
each task runs more slowly than if it were the only task on board).</p>
<h3><a name="Package"></a>Contents of this package</h3>
<p>This multitasking package consists in four schedulers, i.e. programs
that distibute execution time among several tasks. One scheduler is to
be used with Basic with the Editor/Assembler or the Mini-memory
cartridge
plugged in, the second with Extended Basic, the third with assembly
programs
and the last one with GPL. All can perform either preemptive
(recommended)
or cooperative multitasking. They come with a set of demo programs that
are written as a tutorial, and that you should examine in sequence. </p>
<p>To be honest, there are only two different programs: the Basic and
Extended
Basic schedulers are one and the same. They just have different file
formats
and minute differences. Similarly, the GPL scheduler is only a thin
wrapper
around the Assembly one.</p>
<p>Also in the package is the present file, a reference manual that
describes
each scheduler in all excrutiating details. It may therefore look a bit
intimidating. Thus, I would advise you to follow this strategy: </p>
<ol>
  <li>Finish reading this intoduction, upto the point marked "enjoy
it". </li>
  <li>Pick either the Basic or the Extended Basic scheduler and run
trough
the demo programs. They are arranged in sequence as a tutorial, so you
should take them in order. List each program and study it till you
understand
how it works. </li>
  <li>Read the Extended Basic section of this manual. Go back to the
tutorial
if needed, and see if now you understand this or that point more
clearly.</li>
  <li>Experiment with writing your own multitasked Basic programs. Keep
them
simple to start with... </li>
  <li>Do the same for assembly language. The assembly scheduler is more
complex,
but gives you a finer control than the Extended Basic one. You may have
to move back and forth between the tutorial and the manual (i.e. to
multitask
yourself!). Make sure you do the exercises before you move to the next
demo (don't cheat: if you can't come up with a solution, go through the
manual before you look up the answer at the bottom of the demo file). </li>
  <li>Once you mastered assembly multitasking, read the GPL section of
this
manual. It will appear very easy for you, since all it does is
basically
to call the scheduler's assembly routines in a GPL-compatible way.
There
is only one demo file for GPL that shows how to load the scheduler from
GPL and how to call the various assembly routines. A good exercise
would
then be to translate the assembly demo files into GPL...</li>
</ol>
<h3><br>
<a name="principles"></a>General principles</h3>
<p>Multitasking is as easy as 1-2-3!</p>
<ol>
  <li>Initialise multitasking: load the scheduler, call the INITSK
routine.
  </li>
  <li>Create tasks: use the FORK routine. </li>
  <li>End tasks: use the KILL or DIE routines.</li>
</ol>
<p>Some more sophistication is provided for your convenience: </p>
<ol>
  <li>Tasks can be assigned a priority that affects the way they are
scheduled.</li>
  <li>Semaphores can be used to synchronize tasks with respect to each
other.
Use the GRAB, DROP, WAIT, RAISE, and BARIER routines.</li>
  <li>Tasks can save the local context (VDP address, GROM address,
local
memory, etc) when switched off, and retrieve it when switched on.</li>
  <li>The same routine(s) can be run within several tasks, without each
instance
interfering with the others.</li>
</ol>
<h3><br>
<a name="coop vs preemptive"></a>Cooperative versus preemptive</h3>
<p>There are two ways to implement time-sharing: cooperative
multitasking
or preemptive multitasking. With cooperative multitasking, each task
decides
when it's time to switch, and does so by returning control to a
scheduler,
which sets up the next task. Typically, this is done by calling the
YIELD
routine.</p>
<p>With preemptive multitasking, the scheduler snatches control away
from
the current task and forces a task switch whenever it wants to. The
advantage
is that a sloppy task, that never returns control to the scheduler,
will
not stall the whole system, as it would with cooperative multitasking.
Typically, preemptive multitasking is achieved with interrupts. On the
TI-99/4A, the VDP interrupt is very convenient for that purpose.</p>
<p>The TI-99/4A has two tasks running in parallel (yeah, it already has
multitasking!). One task is the main line of execution: title screen
==&gt;
main menu ==&gt; whatever cartridge you select ==&gt; whatever program
you run. The other task is called 60 times per second by the VDP
interrupt
service routine: it can move sprites in auto-motion, play a sound list,
test the &lt;quit&gt; key, and time-out the screen.</p>
<p>So is this cooperative or preemptive multitasking? Well, it depends
whether interrupts are enabled or not. In assembly language they are
generally
disabled (TI recommends that you do so). If you want to use the second
task, you must briefly enable interrupts with a LIMI 2, LIMI 0 loop.
Under
these conditions, assembly language is cooperative. By contrast GPL
features
preemptive multitasking, as the GPL interpreter briefly enables
interrupts
in between each instruction. And so does any language that is
interpreted
by a program written in GPL (such as Basic and Extended Basic):
interrupts
can occur anywhere whithin a statement.</p>
<h3><br>
<a name="critical"></a>Critical sections</h3>
<p>In a preemptive multitasking situation, there are cases when you
absolutely
do not want a task to be interrupted. For instance, if you are
performing
time-critical operations, such as writing to a disk. A good scheduler
lets
you define "critical sections" within your program and will never
interrupt a task that has entered such a section.</p>
<p>In essence, a critical section is an island of cooperative
multitasking
in a sea of preemptive multitasking.</p>
<h3><br>
<a name="priority"></a>Task priority</h3>
<p>By assigning a priority to a task, you affect the way it will be
selected
by the scheduler. When it is time to switch tasks, the scheduler will
preferentially
select a task with a high priority to run next.</p>
<p>There are two basic strategies to implement priority: </p>
<li>The task with the highest priority is always selected. No task will
run as long as another task with a higher priority is able to run (i.e.
is not waiting for a semaphore). </li>
<li>The probability that a task is selected depends on its priority.
The
higher the priority, the more often it runs, but tasks with lower
priority
also have their chances.</li>
<p>The Basic/Extended Basic scheduler is based on the second strategy
with
255 levels of priority: the higher the level, the more likely a task is
to be selected for running. The Assembly/GPL scheduler implements both
strategies. There are four priority classes, and within each level 64
different
priorities. The assembly scheduler only runs the tasks in the currently
highest class. It dispenses execution time among them according to
their
priority withing the class. In other words, classes implement the first
stategy and within-class priority implements the second.</p>
<h3><br>
<a name="Synchro"></a>Task synchronization</h3>
<p>Not all task are completely independent from each other. In fact,
it's
quite common that you will want a task to wait for another. For
instance,
a printing task should wait until data is available to print.
Conversely,
the data-preparing task should not feed them to the printing task
faster
than they can be printed.</p>
<p>Semaphores are variables that can be used by a task to send a
message
to another. What's so special about them? Nothing: they are numeric
variables
like any other. The only trick is that you access them via special
routines
that are immune to task switches. This is required so a task switch
does
not change the value of a semaphore between the moment you check it and
the moment you modify it.</p>
<h4><br>
Mutex semaphores</h4>
<p>The simplest kind of semaphore is the "mutex" or mutually
exclusive semaphore. You can think of it as a flag that can only be
grabbed
by one person at a time. Once a task has grabbed the mutex, any other
task
that wants to grab the same flag will have to wait until the first task
has dropped it. The GRAB subroutine is serving this purpose: a task
that
calls it will be suspended (and control transfered to another task) if
the semaphore it wants is not available. Once it finally is, the task
will
resume and will be the unique owner of this mutex semaphore. Once the
task
is done, it should release the mutex with the DROP subroutine.</p>
<p>There are other subroutines that let you affect semaphores: WAIT
waits
for a semaphore to be free, but does not grab it when it is. RAISE is
used
to mark a semaphore as busy (i.e. to raise the flag), regardless of
whether
it was free or not. With RAISE, the task will never be suspended, even
if the semaphore was already grabbed.</p>
<h4><br>
Numeric semaphores</h4>
<p>Not all semaphores are simple mutex flags. It is possible to have
numeric
semaphores, i.e. semaphores that can be grabbed by an arbitrary number
of tasks. Once this number is reached, any additional task that tries
to
GRAB the same semaphore will be suspended. Its execution will resume
once
one of the current tasks DROPs the semaphore. As you can see, a mutex
is
just a special case of semaphore for which the maximum count is one.</p>
<p>An example of numeric semaphore would be a sound playing routine.
Since
the TI-99/4A has three sound generators, there could be upto three
tasks
that each play a sound. If a fourth task wants to access the sound
generator,
it will have to wait until one of the other three tasks is done.
Several
of the demo files that come with the assembly scheduler are based on
this
example.</p>
<h4><br>
Barriers</h4>
<p>A barrier is kind of the opposite of a counting semaphore: it is
closed
until a predefined number of tasks have reached it (i.e. called the
BARIER
subroutine), then it opens and releases all the waiting tasks. This may
be usefull for instance when exiting your program: you want to make
sure
that every task has completed its job. Or think of a game in which the
player must complete several distinct missions before he can proceed to
the next level.</p>
<h3><br>
<a name="Instances"></a>Instances</h3>
<p>There are cases when several tasks execute the same portion of your
program. Think of a Pacman game for instance: there are three "bad
guys" who each follow the same basic strategy and try to catch the
human player. They only differ by their colors and current screen
location.
It seems silly to write three identical routines to handle them. A
better
solution is to write only one routine, and run it in three different
tasks.
It is said that you now have three "instances" of this routine.</p>
<p>The main problem with "instanciation" is that, since tasks
share the same code, they will affect the same variables (e.g. the
screen
position, in the Pacman example). That's clearly not acceptable and
there
should be a way to let each task have its own copy of the variables. </p>
<p>Come to think of it, Basic and Extended Basic both use a value stack
in VDP memory, on which they save the return point of a <tt>GOSUB </tt>subprogram,
the parameters of a <tt>FOR-NEXT</tt> loop, etc. Clearly, this is
something
that should be private to each task. And in GPL, you may want each task
to have its own copy of the current GROM address, of the subroutine
stack,
etc. Globally, this is known as "context switching".</p>
<p>The schedulers in this package handle context switching
automatically.
In addition, they provide support for you to define extra variables
that
you want to be local to a task. This is done with the LOCAL subroutine
in Basic, and by modifying the task control block in assembly.</p>
<h3><br>
<a name="Using schedulers"></a>Using the schedulers</h3>
<p>As mentionned above, this package contains several schedulers.
Although
the mechanisms are the same in (Extended) Basic, in GPL, and in
Assembly,
the syntax is of course different. So from now on, each scheduler will
be discussed separately. </p>
<p>At this point, I would advise you to go ahead and try multitasking
in
(Extended) Basic. Just go through the demo files in order, their
contents
are listed hereafter. The demos can be run either in TI-Basic with the
Editor/Assembler or Mini-memory cartridge plugged in, or in Extended
Basic.
Just make sure that you load the proper scheduler: TASKXB/O for
Extended
Basic and TASKBA/O for TI-Basic (together with MMR/O if you're using
the
Editor/Assembler cartridge). You should find the corresponding <tt>CALL
LOAD</tt> around line 150 in each demo file. Be aware that Extended
Basic
is awfully slow at loading assembly...</p>
<p>Enjoy it!</p>
<h2>
<hr width="100%"><a name="Basic"></a>Multitasking TI-Basic and Extended
Basic</h2>
<p>The following files are provided with the package:</p>
<pre><u>Filename        Type    Contents                          <br></u>TAKSBA/O        DF80    TI-Basic scheduler<br>MMR/O           DF80    Extra routines for Editor/Assembler<br>TASKXB/O        DF80    Extended Basic scheduler<br>TASKDEMO1       Prog    Tutorial: Cooperative multitasking<br>TASKDEMO2       Prog    Tutorial: Preemptive multitasking<br>TASKDEMO3       Prog    Tutorial: Critical sections<br>TASKDEMO4       Prog    Tutorial: Priorities<br>TASKDEMO5       Prog    Tutorial: Mutex semaphores<br>TASKDEMO6       Prog    Tutorial: Numeric semaphores<br>TASKDEMO7       Prog    Tutorial: Barriers<br>TASKDEMO8       Prog    Tutorial: Local variables (numeric)<br>TASKDEMO9       Prog    Tutorial: Local variables (strings)<br>TASKDEMO10      Prog    Tutorial: Local value stack<br></pre>
<p>The scheduler is the same for both languages, however it comes in
two
different files. TASKXB/O is for use with Extended Basic, TASKBA/O with
TI-Basic and either the Editor/Assembler or the Mini-memory cartridge.
This is because Basic and Extended Basic have different error numbers
so
I had to adapt the error codes in each version of the scheduler. Also,
TAKSBA/O comes in a compressed format, which is smaller and faster to
load
but that Extended Basic cannot handle.</p>
<p>The problem with Editor/Assembler is that it does not provide any
routine
to read or modify Basic variables, so I had to add these in the MMR/O
file
(I lifted them directly from the Mini-Memory ROMs, hence the filename).
If you are using the Mini-memory, comment out the <tt>CALL
LOAD("DSK1.MMR/O")</tt>
lines with a REM in the demo files.</p>
<p>If you are using Extended Basic, delete the line loading MMR/O and
replace
TASKBA/O with TASKXB/O in the next line. </p>
<h3><br>
Loading the scheduler</h3>
<pre>100 CALL INIT<br>110 CALL LOAD("DSK1.MMR/O") with Ed/Assm only<br>120 CALL LOAD("DSK1.TASKBA/O")     or      CALL LOAD("DSK1.TASKXB/O")</pre>
<p>Either scheduler defines the following routines:</p>
<pre><a href="#initsk">INITSK</a>  Initialize multitasking<br><a
 href="#fork">FORK</a>    Create a new task<br><a href="#kill&amp;die">KILL</a>    Kill a task<br><a
 href="#kill&amp;die">DIE</a>     Kill the current task<br><a href="#grab">GRAB</a>    Grab a semaphore<br><a
 href="#drop">DROP</a>    Drop a semaphore<br><a href="#barrier">BARIER</a>  Wait at a barrier<br><a
 href="#raise">RAISE</a>   Raise a semaphore<br><a href="#wait">WAIT</a>    Wait for a semaphore<br><a
 href="#setsem">SETSEM</a>  Set the value of a semaphore<br><a
 href="#critic%20&amp;%20endcri">CRITIC</a>  Enter critical section<br><a
 href="#critic%20&amp;%20endcri">ENDCRI</a>  Leave critical section<br><a
 href="#yield">YIELD</a>   Yields to another task<br><a href="#local">LOCAL</a>   Reserve local variables<br><a
 href="#endtsk">ENDTSK</a>  Terminate multitasking operations<br><a
 href="#cfgtsk">CFGTSK</a>  Modifiy default configuration</pre>
<h3><br>
<br>
<a name="initsk"></a>Initializing multitasking</h3>
<pre>120 REM There must be a comment line here <br>130 CALL LINK("INITSK")</pre>
<p>Calling INITSK initializes the scheduler for multitasking
operations.
This must happen before any call to another routine in the scheduler
(except
for CFGTSK, if present).</p>
<p>The comment line is necessary, because that's where the scheduler
jumps
to switch tasks. INITSK will thus be called in between each task, but
only
the first time does it really initialize the system. The rest of the
time,
it's just a signal for the task switch to occur.</p>
<h4><br>
How it works </h4>
<p>The first time INITSK is called, the scheduler installs an interrupt
hook. Within the (Extended) Basic interpreter, interrupts are allowed
briefly
before each keyword is interpreted. If this keyword is interpreted by
an
assembly routine in ROM, this is the only chance for the scheduler to
gain
control on this line. Exemples of such keywords include: DATA, DEF,
DIM,
ELSE, END, IF, GO, GOSUB, GOTO, NEXT, REM, RETURN, ON, OPTION, STOP,and
SUB. </p>
<p>Most other keywords and CALLed subprograms are interpreted by GPL
routines
in GROMs. This is of course much slower because GPL itself is
interpreted
by assembly routines. However, interrupts are briefly enabled before
almost
each GPL instructions, which means that GPL-interpreted keywords offer
many opportunities for the scheduler to take control anytime whithin
the
instruction. Of course, switching tasks before an instruction line is
completed
is a big no-no, so the scheduler does it in a more subttle way.</p>
<p>When the scheduler gains control through an interrupt, it decides
whether
it's time to switch tasks. Since GPL-interpreted keywords may be quite
slow, the scheduler will not switch tasks before at least two Basic
lines
have been executed. Otherwise, the system could spend more time
switching
tasks than actually running them! On the other hand,
assembly-interpreted
keywords are very fast so it is quite possible that many will be
executed
before an interrupt occurs.</p>
<p>Once it decides to switch tasks, the scheduler saves the current
line
number and replaces it with the number of the REM line that's before
the
call to INITSK. When (Extended) Basic completes the current line and
moves
to the next, it actually lands on the line with the <tt>CALL
INIT("INITSK")</tt>.
Entering INITSK tells the scheduler that tasks can now be switched
safely,
i.e. that we are not in the middle of an instruction.</p>
<p>However, there are instructions that do not move to the next line
(e.g.
<tt>IF</tt>, <tt>GOTO, GOSUB, NEXT</tt>, etc.) so obviously INITSK
will
not be called after such an instruction. (Which is good since execution
may not necessarily continue with the next line, when the task returns
to such an instruction). The scheduler thus keeps changing the line
number
so as to point at the REM line, until the program finally jumps to it.
This complicated mechanism is necessary to ensure that the current line
will always terminate before switching, and that the next line will be
the one to execute next.</p>
<p>Take-home messages: </p>
<ol>
  <li>Switching always occurs in between two lines. So compound
statements
in Extended Basic (e.g. <tt>I=I+1 :: PRINT I :: PRINT "Test"</tt>)
will never be interrupted. </li>
  <li>The minimal "time slice" for a task is two lines (although
you can change that with CFGTSK).</li>
  <li>Task switching will never occur just after a line that contains a
    <tt>GOTO</tt>,
a <tt>NEXT</tt>, a <tt>GOSUB</tt>, or any instruction that causes a
jump.</li>
</ol>
<p>Note: If you TRACE the program, you may notice that some lines are
listed
twice (just before and just after a task switch), although they are
actually
executed only once. This is because the tracing routine outputs the
line
number before the Basic interpreter figures where the line is in
memory,
from its line number. Since the tracing routine is written in GPL, it
is
possible that the line number will be changed after it was placed on
screen,
but before the line was located and executed. This line will only be
executed
when the task resumes. In other words, TRACE is outputing the wrong
line
number, but don't worry: everything happens as it should.</p>
<h3><br>
<a name="endtsk"></a>Terminating multitasking</h3>
<pre>500 CALL LINK("ENDTSK")</pre>
<p>Because the scheduler hooks the interrupt routine, we must unhook it
when we are done. Note that this should be done automatically when the
program terminates, but it's good practice to call ENDTSK anyhow. If
you
&lt;BREAK&gt; the program, call ENDTSK, then INITSK to restart it.</p>
<h3><br>
<a name="cfgtsk"></a>Changing the default configuration</h3>
<pre>100 CALL LINK("CFGTSK",TYPE,BUFFER,TASKS,SLICE)</pre>
<p>This optional command lets you modify the default configuration of
the
scheduler. If present, it must be placed at the top of your program,
just
after the CALL LOAD that loads the scheduler file(s). All parameters
are
optional, but you cannot leave gaps (e.g. define BUFFER without
defining
TYPE).</p>
<p><b>TYPE </b>is the type of multitasking desired: 0 means
preemptive,
a non-zero value means cooperative. The default is preemptive.</p>
<p><b>BUFFER </b>is the number of bytes to reserve for the local
buffer.
This buffer is used to save the Basic value stack and local variables
for
each task. The default size is 1152 bytes. Passing 0 leaves the current
value unchanged.</p>
<p><b>TASKS </b>is the maximum number of tasks that can be created
(including
the main program). The default is 16. Zero means no changes.</p>
<p><b>SLICE </b>is the minimum number of lines that should be executed
within a time slice, i.e. before a task switch occurs. The default is
two,
which I find the most convenient. Passing 0 means no changes. </p>
<p>CFGTSK may cause the following errors:</p>
<ul>
  <li>If any of these value not in the range -32768 to 65535, you will
get
a "Bad argument" error. </li>
  <li>You may get a "number too big", if BUFFER or TASK is obviously
crazy. However, the scheduler may miss some subttle points (such as
extending
the buffer beyond the limit of the low memory expansion). </li>
</ul>
<p>Cautionary notes:</p>
<p>SLICE represents an offset from the number of the line in which the
tasks is entered, <b>not </b>the number of lines actually executed.
Which
means that, if you have a 3-line FOR-NEXT loop, and you set SLICE as 4,
this loop will never be interrupted! Conversely, if the first line
executed
is a GOTO that lands 50 lines down your program, chances are that a
switch
will occur, even if SLICE was set at a high value. This is because the
scheduler has no way to know how many lines where executed in between
two
interrupts. It only knows how far down from the original line the
program
went.</p>
<p>Be aware that changing BUFFER and/or TASKS, changes the amount of
memory
that must remain available just after the scheduler program. The file
TASKBA/O
(or TASKXB/O) reserves the default amount, but if you change it you
risk
overwriting any assembly file that you may load subsequently. So either
load the scheduler last, or load a dummy file containing only a BSS
statement
with the additional size needed, or use <tt>CALL LOAD</tt> to modify
the
loader's pointers. Hmmm, I guess the easiest is to load the scheduler
last...</p>
<h3><br>
<a name="fork"></a>Creating a new task</h3>
<pre>150 CALL LINK("FORK",LINE,PRIOR,NESTING,ID)</pre>
<p>This command is used to create a new task. The last 3 parameters are
optional. </p>
<p><b>LINE </b>is the line number where the new task is to start. The
parent
task will continue normally with the next line.You could also use a
constant
instead of a variable: <tt>CALL LINK("FORK",200)</tt> spawns
a child task at line 200. Just be carefull when you <tt>RESEQUENCE </tt>your
program: the target line may have changed number...</p>
<p><b>PRIOR </b>is an optional parameter, that specifies the task
priority.
This must be a number between 1 and 255. If it is 0, or if it is
omited,
the priority will be the same as that of the parent task. Here also, a
constant could be used. A task priority affects its chances of being
selected
during a task switch: tasks with higher priority values run more often.
The priority of the main program is arbitrarily set as 16.</p>
<p><b>NESTING </b>is an optional parameter, constant or variable, in
the
range 0 to 255. It indicates the maximum number of entries to be saved
from the value stack when the task is switched off (and restored when
it
is switched on). If this parameter is not specified the default value
will
be that of the main program: 9 entries. Stack entries are used by the <tt>GOSUB</tt>
(1 entry) and <tt>FOR-NEXT</tt> statements (3 entries in Basic, 4 in
Extended
Basic). The number to reserve depends on how many levels down such
statements
can be nested in a task. For instance, a <tt>FOR-NEXT</tt> loop inside
a subprogram called from a <tt>GOSUB </tt>located inside another <tt>FOR-NEXT</tt>
requires 3+1+3 = 7 stack entries in Basic and 4+1+4 = 9 in Extended
Basic.
Each entry occupies 8 bytes in the scheduler's buffer.</p>
<p><b>ID </b>is yet another optional parameter. Contrarily to the
previous
ones, it must be a numeric variable, not a constant. This is because it
is a pure "output" parameter: FORK will return the ID number
of the newly created task in this variable. This number can be used by
the parent task to kill the child task, for instance.</p>
<p>FORK may cause the following errors:</p>
<ul>
  <li>"Memory full" if there is not enough room in the scheduler
memory to create the new task (e.g. if you are reserving a lot of
nesting
space), or if you create too many tasks. </li>
  <li>"Bad line number" if the line number specifed does not exist.
  </li>
  <li>"Number too big" if PRIOR or NESTING is greater than 255.</li>
</ul>
<h3><br>
<a name="kill&amp;die"></a>Terminating a task</h3>
<p>There are two ways to terminate tasks: calling KILL or calling DIE.</p>
<h4>Kill</h4>
<pre>250 CALL LINK("KILL",ID)</pre>
<p><b>ID </b>is the ID number of the task to be terminated (obtained
when
calling FORK). Zero stands for "current task" and is therefore
equivalent to calling DIE.</p>
<h4><br>
Die</h4>
<pre>250 CALL LINK("DIE")</pre>
<p>Kills the current task.</p>
<p>KILL and DIE may cause the following errors: </p>
<ul>
  <li>"Number too big" if the ID entered does not correspond to
a valid task (KILL only). </li>
  <li>"Can't continue" if you killed the only task that could run.</li>
</ul>
<h3><br>
<a name="sync"></a>Synchronizing tasks</h3>
<p>There are cases when you don't want two tasks to run at the same
time:
when they both need to access the same resource, for instance. You can
cause two (or more) task to become mutually exclusive by using "mutex"
semaphores.</p>
<p>The scheduler contains 100 semaphores, which are internal variables
used to communicate between tasks. To achieve mutual exclusion, have
each
task GRAB the same semaphore before it attempts to use the critical
resource
(e.g. a printer). If the semaphore is free, the task will grab it and
continue
normally. If the semaphore was already grabbed by another task, the
current
task will be suspended. It will only resume once the semaphore is freed
by calling DROP, generally from the task that had successfully grabbed
it. </p>
<p>It is also possible to wait for a semaphore without grabbing it
(WAIT),
to "grab" it without checking it first (RAISE) or to define its
value (SETSEM).</p>
<p>Actually, a mutex is just a special case of semaphore, that can only
take two values: raised (1) or dropped (0). But in fact semaphores can
have more than two possible states: legal values range from -128 to
+127.
If the value of a semaphore is positive the task will hang on GRAB or
WAIT,
if the value is zero or less the task will go through.</p>
<h4><br>
<a name="grab"></a>Grab</h4>
<pre>800 CALL LINK("GRAB",SEM)</pre>
<p><b>SEM </b>can be either a constant or a variable. It is the number
of the semaphore to grab. The call will not return until the semaphore
is free. When it does, the semaphore will be marked as used by the
current
task (i.e. its value is incremented by one).</p>
<p>GRAB can cause a "Number too big" error if the semaphore number
is not between 1 and 100.</p>
<p>Beware of deadlocks: when a task grabs semaphores #1 then #2, and
another
task grabs semaphores #2 then #1, there is a risk that each task ends
up
waiting for the semaphore grabbed by the other. Since none of the two
tasks
ever runs, it is likely that neither semaphore will ever become free!
Also
make sure a tasks never grabs the same semaphore twice in a row, as it
would end up waiting for itself!</p>
<p>A simple rule to avoid deadlocks is to grab semaphores in increasing
order, i.e make sure a task never grabs a semaphore with a number
smaller
than (or equal to) the highest it has already grabed.</p>
<h4><br>
<a name="wait"></a>Wait</h4>
<pre>800 CALL LINK("WAIT",SEM)</pre>
<p><b>SEM </b>is the semaphore number, just as with GRAB.</p>
<p>WAIT is identical to GRAB except the it does not raise the semaphore
once it returns. In other words, it makes sure the semaphore is free,
but
it does not prevent other tasks from grabbing it later on.</p>
<p>This is a bit dangerous to do, since nothing guarantees than a task
switch will not occur just after the call to WAIT, transfering control
to another task that may grab the semaphore. When returning to the
current
task, the semaphore will be in use, even though we went through WAIT!
In
fact, it is to avoid precisely this kind of situation that semaphores
were
invented...</p>
<h4><br>
<a name="drop"></a>Drop</h4>
<pre>900 CALL LINK("DROP",SEM)</pre>
<p>DROP releases a semaphore (i.e. decrements its value by one),
whether
or not it was previously grabed by the current task. It is very
important
that a task always releases any semaphore it may have grabbed before it
terminates. Other tasks may be waiting for one of these semaphores and
if you don't relinquish them the program may get stalled and abort with
a "Can't do that" error.</p>
<p><b>SEM </b>is the semaphore number. If this number is negated, the
semaphore
will only be decremented if its current value is positive (you can't
drop
something that's already down, can you?).</p>
<h4><br>
<a name="raise"></a>Raise</h4>
<pre>900 CALL LINK("RAISE",SEM)</pre>
<p>RAISE increments the semaphore value by one. This will hang any task
that tries to GRAB it or to WAIT for it. Contrarily to GRAB, RAISE will
never suspend the current task if the semaphore value was already
positive.</p>
<p><b>SEM </b>is the semaphore number. If this number is negative, the
semaphore value will not be increased if it is already positive (i.e.
you
cannot "super-raise" such a semaphore).</p>
<h4><br>
<a name="barrier"></a>Barrier</h4>
<pre>900 CALL LINK("BARIER",SEM,VAL)</pre>
<p>Barriers use semaphores in a way that allows tasks to wait for each
other. Each time a task reaches the barrier, the semaphore value is
decremented
by one. If the result is greater than zero the task will stall. If the
result is zero or less, all tasks that were waiting at this barrier are
released.</p>
<p><b>SEM </b>is the number of the semaphore that should control the
barrier.</p>
<p><b>VAL </b>is the new value for the semaphore, in the range -128 to
+127. If VAL is omited (recommended), the current semaphore value will
be decremented by one. Specifying VAL gives each task a chance to
modify
the threashold value. A value of 1 or less always opens the barrier
(since
the current task is already at the barrier, there is at least 1 task
there...).</p>
<p>The best way to use barriers is to set the semaphore value with
SETSEM
and have each task call BARIER without a VAL parameter. In this way,
the
barrier just counts the tasks and opens when the preset number of tasks
has been reached. If you are planning to use the same barrier again,
remember
to close it by calling SETSEM again.</p>
<li>BARIER can cause the error "number too big" if either SEM
or VAL are too high.</li>
<h4><br>
<a name="setsem"></a>Setsem</h4>
<pre>950 CALL LINK("SETSEM",SEM,VAL)</pre>
<p>This subroutine lets you manually assign a value to a semaphore.
It's
especially usefull to initialize a barrier, for instance.</p>
<p><b>SEM </b>is the semaphore number. Cf GRAB.</p>
<p><b>VAL </b>is the value you want this semaphore to take. It should
be
in the range -128 to +127.</p>
<li>A "bad argument" error is issued if VAL or SEM is not an
integer. </li>
<li>A "number too big" error occurs if you pick an illegal number
for SEM.</li>
<h3><br>
<a name="critic &amp; endcri"></a>Critical sections and cooperative
multitasking</h3>
<p>By default, INITSK enters preemptive multitasking. But you can use
CRITIC
and ENDCRI to bracket sections in your program that should not be
interrupted
when using preemptive multitasking.</p>
<p>While in a critical section, the only way you can switch task is to
call the scheduler. This can be done with routines like GRAB and WAIT,
but also with the dedicated YIELD routine. Note that yielding
automatically
terminates the critical section.</p>
<h4><br>
Critic</h4>
<pre>720 CALL LINK("CRITIC")</pre>
<p>Enters a critical section. Interrupts still occur, but the scheduler
won't switch tasks any more.</p>
<h4><br>
Endcri</h4>
<pre>880 CALL LINK("ENDCRI")</pre>
<p>Leave critical section. Note that CRITIC is not additive: a single
ENDCRI
enables task switching, no matter how many times CRITIC was called
before.
And conversely: a single CRITIC defines a critical section, even after
several ENDCRI. In other words, it's a on/off mechanism.</p>
<h4><br>
<a name="yield"></a>Yield</h4>
<pre>800 CALL LINK("YIELD")</pre>
<p>Returns the control to the scheduler. If a task switch can occur, it
will. Note that in this case, there is no need for the scheduler to
first
jump to TSKINI: it can switch directly to wherever the next task is
waiting.</p>
<p>With cooperative multitasking, it is imperative that each and every
task frequently calls YIELD. If a task does not, it may stall the whole
program and multitasking won't be achieved effectively. This is why
preemptive
multitasking is generally prefered.</p>
<p>With preemptive multitasking, calling YIELD is optional, but
recommended
any time a task is idle (e.g. waiting for human input). Remember that
YIELD
automatically terminates any pending critical section.</p>
<h3><br>
<a name="instances&amp;local"></a>Instances and local variables</h3>
<p>In Basic or Extended Basic programs all variables are accessible to
all parts of the program, i.e. there are no local variables as in C or
Pascal. This means that you have to be really carefull, because a given
variable used in the current task may be altered by another task, if
switching
occurs. For instance, consider this loop:</p>
<pre>500 FOR I=1 to 100 <br>510 PRINT I <br>520 PRINT A$(I) <br>530 NEXT I</pre>
<p>It should run fine, right? But suppose there is another task that
also
uses the variable I. Now if the scheduler switches to this task while
in
the loop, the value of I will be all messed up!</p>
<p>The conclusion is that each task should have its own set of
variables:
avoid names like I, A$, etc. My suggestion would be to use a mnemonic
trick,
such as appending a different number at the end of each variable
belonging
to a given task: I1 and A1$ for one task, I2 and A2$ for another, etc.</p>
<p>This strategy is unfortunately impossible when two tasks share the
same
section of your program, such as the above loop. This may occur because
they are performing identical functions (e.g. animate the many alien
ships
that keep attacking the human player), or because they call a common
subprogram.</p>
<p>It is said that each task constitutes an "instance" of this
routine or subprogram. As all instances share the same code, they will
use the same variables. You must therefore save these variables when a
task switches off, and restore them when the task switches on. This is
automatically achieved by the same mechanism that saves the value
stack.
The only thing you have to do is to tell the scheduler which variables
you want to save for which task. You can do that by including one or
more
calls to LOCAL at the beginning of a task.</p>
<h4><br>
<a name="local"></a>Local</h4>
<pre>200 CALL LINK("LOCAL",I,A$,X2)</pre>
<p>In this example A$, I and X2 are three variables that we are
declaring
as local. If necessary, you could have several calls to LOCAL, and
define
as many local variables as you wish (although this would slow down
switching).</p>
<p>It is very important that any call to LOCAL occurs at the beginning
of the task, before any of the local variables is actually used. A good
practice is to FORK a new task beginning with its first LOCAL line.</p>
<p>LOCAL can cause a "memory full" error if the scheduler runs
out of memory. Remember that all active tasks, whether stalled or not,
require memory space to save all their local variables (and the Basic
value
stack). For your information, each variable uses up 10 bytes.</p>
<p>A call to LOCAL has different effects depending on whether it deals
with a string or a numeric variable. For numeric variables, the current
task makes a copy of the current value of this variable and restores it
every time it is switched on. If a task did not declare this variable
as
local (such as the parent task) it will still be able to use it, but at
the risk of seeing the value briskly altered, if a task switch has
occured.
Only tasks that have declared a numeric variable as local can safely
assume
that its value will never change unexpectedly.</p>
<p>For string variables, the current task grabs the string for its own
use and replaces it with an empty string. Which means that if you are
FORKing
multiple instances, the parent task must reinitialize the string every
time! Every tasks that did not declare this string variable as local
share
a "global" copy (initially empty) that may be modified by those
tasks that have their own local copies, when they switch between each
others.</p>
<p>This sounds a bit complicated, but you can make your life easier by
adopting a simple rule: Never use a local variable in a task that did
not
declare it as local! </p>
<p>The exception to this rule is when the parent task needs to pass
some
initial parameter to the child task. In this case the variable should
be
initialize just before the FORK (possibly using a critical section for
numeric variables, when forking more than one task that uses this
variable).</p>
<h2>
<hr width="100%"><a name="Assembly"></a>Multitasking assembly language</h2>
<p>The following files are provided:</p>
<pre><u>Filename   Type  Contents                                   <br></u>TASKS/O    DF80  Scheduler. Allows multitasking in assembly language<br>SUBS/O     DF80  Standard assembly utilities, adapted for multitasking<br>TASKS/EQU  DV80  Equates to be used in your programs (on GPL disk)<br>DEMO1/S    DV80  Tutorial. Basics.<br>DEMO2/S    DV80  Tutorial. Priority.<br>DEMO3/S    DV80  Tutorial. Mutex semaphores.<br>DEMO4/S    DV80  Tutorial. General semaphores.<br>DEMO5/S    DV80  Tutorial. Barriers.<br>DEMO6/S    DV80  Tutorial. Context saving.<br>DEMO7/S    DV80  Tutorial. Instance basics.<br>DEMO8/S    DV80  Tutorial. Local variables.<br>DEMO9/S    DV80  Tutorial. Full instanciation.<br>DEMO10/S   DV80  Tutorial. Switch-time routines<br>DEMO11/S   DV80  Tutorial. Critical sections. Standard utilities<br>DEMO12/S   DV80  Tutorial. Real example: key scan with type-ahead buffer.</pre>
<h3><br>
Loading the scheduler </h3>
<p>The scheduler is a DF80 relocatable tagged-object file named
TASKS/O.
It should be loaded along with your program, with Editor/Assembler
option
3, or an equivalent loader (such as Fweb). The current version is a
little
short of &gt;800 bytes in size.</p>
<p>The file defines the following routines: </p>
<pre><a href="#initsk1">INITSK</a>  Initialize multitasking<br><a
 href="#fork1">FORK</a>    Create a new task<br><a href="#kill+die">KILL</a>    Kill a task<br><a
 href="#kill+die">DIE</a>     Kill the current task<br><a href="#grab1">GRAB</a>    Grab a semaphore<br><a
 href="#wait1">WAIT</a>    Wait for a semaphore<br><a href="#barier1">BARIER</a>  Wait at a barrier<br><a
 href="#drop1">DROP</a>    Drop a semaphore<br><a href="#raise1">RAISE</a>   Raise a semaphore<br><a
 href="#yield1">YIELD</a>   Yield to another task<br><a href="#gettcb1">GETTCB</a>  Get a pointer to a task control block<br></pre>
<p>And the following data words:</p>
<pre><a href="#critical%20&amp;%20coop">CRITIC</a>  Flag for critical sections<br><a
 href="#Error%20codes">TSKERR</a>  Error code<br><a href="#fatal">ERRSEM</a>  Semaphore for fatal error barriers<br><a
 href="#instances&amp;local%20mem">VADDR</a>   Current VDP address<br><a
 href="#instances&amp;local%20mem">VR0</a>     Copy of VDP registers (8 bytes) </pre>
<h3><br>
<a name="initsk1"></a>Initializing multitasking</h3>
<p>Just call the INITSK routine. It clears the task list, hooks the
interrupt
routine and returns with an implicit LIMI 2 to enable interrupts. If
you
want cooperative multitasking, add a LIMI 0 just after the call to
INITSK.</p>
<pre>BLWP @INITSK      or      BLWP @INITSK      or      BLWP  @INITSK<br>DATA tcbptr               DATA &gt;000r                DATA   &gt;FFFF</pre>
<p><b>Tcbptr </b>is the address of the Task Control Block (TCB) to be
used
for the main program. Alternatively, the data word can contain a number
"r" from 0 to 15 (i.e. &gt;000F), which indicates in which register
the address of the TCB is to be found.</p>
<p>If the data word or the register content is &gt;FFFF, no TCB is
specified.
The scheduler will provide a minimal TCB of its own, with a priority of
&gt;60, no context saving, and no local memory.</p>
<h4>Technical note</h4>
<p>INITSK intalls an interrupt service routine hook at address
&gt;83C4.
It you already had a hook in there, the scheduler will link to it. If a
task switch is due to occur, your routine will be called before the
switch
takes place. You must return with <tt>B *R11</tt> for the switch to
occur.
If you return with <tt>LWPI &gt;83C0</tt> and <tt>RTWP</tt>, the
current
task will remain active. </p>
<p>If you would like to remove, or modify your hook, its value can be
found
12 bytes after VR0:</p>
<pre>       LI   R1,VR0 <br>       CLR  @12(R1)   to remove your hook</pre>
<h3><br>
<a name="fork1"></a>Creating a new task</h3>
<p>The scheduler allows upto 32 tasks at any given time, including the
main program. To create a new task, set up a Task Control Block (see
below),
then call the FORK routine.</p>
<pre>BLWP @FORK        or        BLWP @FORK<br>DATA tcbptr                 DATA &gt;000r</pre>
<p><b>Tcbptr </b>is the address of the Task Control Block (TCB) to use
for the newly created task. Alternatively, this address can be in a
workspace
register whose number is passed in the data word (the address cannot be
&gt;FFFF with FORK).</p>
<p>The structure of a minimal TCB is the following: </p>
<pre>TCB1  BYTE 0         priority (0 = same a parent task)<br>      BYTE 0         internal use<br>      DATA &gt;0000     flags (0 = minimal TCB)<br>      DATA 0         workspace (0 = same as parent task)<br>      DATA 0         start point (0 = after the FORK statement)<br>      DATA 0         internal use (status buffer)<br>      DATA 0         internal use (timer count)<br>      DATA 0         internal use (semaphore ptr)</pre>
<p>As you see, it's very simple: it basically consists in a string of
14
null bytes!</p>
<p>If you wanted to, you could specify a starting address for the child
task, in the 4th word of the TCB. If you leave this word as 0, the
child
task will start where the parent task returns, i.e. after the call to
FORK.
You can differentiate them easily, because the parent task return with
the Eq bit reset, whereas the child task starts with the Eq bit set. So
you can use <tt>JNE </tt>to trap the parent task, or <tt>JEQ </tt>for
the
child task.</p>
<p>The parent task returns with the ID of the newly created (child)
task
in R0. Hint: you may want to save this value for further use... If this
value is zero, an error occured and no task was created. The error
number
can be found in the word TSKERR.</p>
<h3><br>
<a name="kill+die"></a>Terminating a task</h3>
<p>You can terminate tasks by calling either the KILL routine, or the
DIE
routine.</p>
<h4>Kill</h4>
<pre>BLWP @KILL</pre>
<p>Terminates the task whose ID is in R0 (I told you to save this
value).
If R0 contains zero, the current task will be terminated, which is
equivalent
to a call to DIE.</p>
<p>If an invalid task ID was placed in R0 the routine returns with the
Eq bit set, and TSKERR will contain the value RNOTID. </p>
<h4><br>
Die</h4>
<pre>BLWP @DIE</pre>
<p>Terminates the current task</p>
<p>Caution: if you terminate all tasks in a program, the scheduler
can't
run anything and will reset the TI-99/4A. The same thing will happen if
all tasks are hanged by semaphores.</p>
<h3><br>
<a name="endtsk1"></a>Terminating multitasking</h3>
<p>To terminate multitasking operations, you can call ENDTSK</p>
<pre>BLWP @ENDTSK</pre>
<p>ENDTSK unhooks the interrupts and clears the list of tasks. It also
places -1 in TSKERR. Then it calls the switch-time routines (if any)
for
each and every task (whether it is ready to run or hanged), including
the
current one. Finally ENDTSK returns to your program, that will not be
considered
as a task any more.</p>
<p>You can re-initiate multitasking by calling TSKINI again. Until you
do that, do not call any other routine in the scheduler, as they will
not
function properly.</p>
<h3><br>
<a name="set priority"></a>Setting priorities</h3>
<p>You can affect the way a task is scheduled by changing the priority
value in its TCB. Note that, for the current task, the change will only
become effective after a task switch has occured.</p>
<p>There are four priority classes: </p>
<ul>
  <li>Low priority : &gt;01 to &gt;3F </li>
  <li>Average priority: &gt;40 to &gt;7F </li>
  <li>High priority : &gt;80 to &gt;BF </li>
  <li>Critical task : &gt;C0 to &gt;FF</li>
</ul>
<p>The scheduler will never select a task if a task in a higher
priority
class can be run instead.</p>
<p>Within a given class, the scheduler will run each task in turn at a
frequency determined by the respective task priorities. For instance, a
task with a priority of &gt;20 will run twice as often as a task with a
priority of &gt;10, but twice less often than a task with a priority of
&gt;3F. The same is true for priorities &gt;60 and &gt;50 in the
"average
priority" class: within the class, a priority of &gt;60 - &gt;40 =
&gt;20 is twice higher as a priority of &gt;50 - &gt;40 = &gt;10.</p>
<h3><br>
<a name="task sync"></a>Synchronizing tasks</h3>
<p>Task synchronisation can be achieved with semaphores. A semaphore is
nothing more than a data word that should be part of your program's
data
and initialized to an appropriate value (generally zero). If it
contains
a positive value, it has the potential to suspend (hang) a task. A null
or negative value will let the task run. </p>
<p>Three routines have the potential to hang a task, i.e. not to return
until a semaphore reaches a given value: WAIT, GRAB and BARIER. (Yes I
know, barrier is spelled with two Rs, but label names are limited to 6
characters).</p>
<p>You can manipulate the value of a semaphore with the routines DROP
and
RAISE (although BARIER and GRAB also change the semaphore value). You
can
also change it directly, but this will not free any currently hanged
task!</p>
<h4><br>
<a name="wait1"></a>Wait</h4>
<pre>BLWP @WAIT         or        BLWP @WAIT<br>DATA semptr                  DATA &gt;000r</pre>
<p><b>Semptr </b>is the address of a semaphore, and can also be
specified
in register r.</p>
<p>WAIT tests the value of the semaphore word. If it is 0 or negative
(&gt;8000-FFFF)
it returns immediately, with the Eq bit reset. If the semaphore value
is
positive(&gt;0001-7FFF), the task hangs and will not resume until the
semaphore
value is brought back to 0 or less by the DROP routine. When the task
is
freed, the routine returns with the Eq bit set.</p>
<h4><br>
<a name="drop1"></a>Drop</h4>
<pre>BLWP @DROP         or       BLWP @DROP<br>DATA semptr                 DATA &gt;000r</pre>
<p><b>Semptr </b>is the address of a semaphore. This address can also
be
placed in register r, if you use the second syntax.</p>
<p>DROP decreases the value of the specifed semaphore by one. If the
result
is zero or less, it looks for a task hanged by this semaphore (due to a
call to WAIT, GRAB or BARIER), with a priority class higher or equal to
that of the current task. If no such task is found, execution continues
with the current task and the Eq bit will be reset.</p>
<p>If a hanged task was found, the outcome depends on the routine that
suspended it:</p>
<ul>
  <li>If it was GRAB, the task is switched on and the semaphore is
incremented
by one again.</li>
  <li>If it was WAIT, the task is switched on, but the semaphore is
left
unchanged.</li>
  <li>If it was BARIER, the scheduler frees the task and attempts to
find
another one. It's only when no more tasks can be freed that the
scheduler
switches one on.</li>
</ul>
<p>If a task switch occured, the Eq bit will be set when DROP finally
returns
to the calling task.</p>
<h4><br>
<a name="raise1"></a>Raise</h4>
<pre>BLWP @RAISE       or        BLWP @RAISE<br>DATA semptr                 DATA &gt;000r</pre>
<p><b>Semptr </b>is the address of a semaphore. This address can also
be
placed in register r.</p>
<p>RAISE increments by one the value of the specified semaphore. If the
result is zero or less, it searches for a task hanged by this semaphore
and switches it on. If no such task exists (or if it is in a lower
priority
class than the current task), the current task continues with the Eq
bit
reset. If RAISE caused a task switch it will return with the Eq bit
will
be set.</p>
<h4><br>
<a name="grab1"></a>Grab</h4>
<pre>BLWP @GRAB         or        BLWP @GRAB<br>DATA semptr                  DATA &gt;000r</pre>
<p><b>Semptr </b>is the address of a semaphore. This address can also
be
placed in register r.</p>
<p>GRAB is a combination of WAIT and RAISE. It first checks the
semaphore
value. If it is positive the task hangs until the semaphore becomes 0
or
less. When it's the case, the task increments the semaphore value by
one
and returns with the Eq bit set. If GRAB is able to return right away,
the Eq bit will be reset.</p>
<p>This is safer than calling WAIT and RAISE in succession: there is
always
a possibility that a task switch occurs just after WAIT, in which case
the semaphore value may become positive even though the task went
through
WAIT without hanging!</p>
<p>GRAB is usefull to implement a mutex, or mutually exclusive
semaphore.
Imagine a resource that can only be used by one task at a time. A
printer
is a good example: you wouldn't want two tasks to take turns printing
one
line at a time, would you?</p>
<p>So each task should first grab a semaphore, then print what it needs
to print, and drop the semaphore once done. If another task tries to
print
in the mean time, it will hang at the GRAB statement until the first
task
has released the semaphore. Then the second task grabs the semaphore
and
gains exclusive control of the printer, etc.</p>
<h4><br>
<a name="barier1"></a>Barrier</h4>
<pre>BLWP @BARIER        or        BLWP @BARIER<br>DATA semptr                   DATA &gt;000r</pre>
<p><b>Semptr </b>is the address of a semaphore. This address can also
be
placed in register r.</p>
<p>A barrier is a special type of semaphore: it suspends any task that
reaches it, until a preset number of tasks has reached the barrier. At
this point the barrier is opened and all tasks are free to go.</p>
<p>To implement a barrier, use a semaphore with an initial value
corresponding
to the number of tasks that should reach the barrier before it opens.
Then
have each task call BARIER: it decrements the semaphore value by one.
If
the result is not zero yet, this task hangs. If the result is zero (or
less), BARIER frees all other tasks hanged by this barrier and returns
to the caller.</p>
<p>The task that caused the barrier to open returns from BARIER with
the
Eq bit reset. All other tasks return with the Eq bit set.</p>
<p>Note that the semaphore will need to be initialized again before the
barrier can be reused!</p>
<h3><br>
<a name="critical &amp; coop"></a>Critical sections and cooperative
multitasking</h3>
<p>There may be cases when you don't want your program to be
interrupted:
time critical processes, routines that are called by different tasks
but
cannot manage two tasks at a time, etc. These so-called critical
sections
can be created by bracketing them with a <tt>SETO @CRITIC</tt> and a <tt>CLR
@CRITIC</tt>.</p>
<p>CRITIC is a flag that is part of the scheduler and DEFined inside
the
TASKS/O file. When CRITIC is zero, multitasking occurs normally. When
CRITIC
is &gt;FFFF, interrupts still occur, but the scheduler won't switch
tasks.</p>
<p>Alternatively, you could use <tt>LIMI 0</tt> and <tt>LIMI 2</tt>
to
bracket critical sections, in which case interrupts will not occur. The
two solutions are not completely equivalent however. Remember that the
console interrupt routine handles sprites in auto-motion, automatic
sound
playing, the &lt;quit&gt; key and the screen-saving timeout. Also,
peripheral
card interrupts won't be answered if you use <tt>LIMI 0</tt>.
Therefore,
it is generally better to use <tt>SETO @CRITIC</tt>, unless you know
for
sure that interrupts can safely be disabled in a given section of your
program.</p>
<p>By default, INITSK enables the interrupts so multitasking will be
preemptive.
If you prefer cooperative multitasking, you can either place a <tt>LIMI
2</tt> just after the call to INITSK so as to disable interrupts, use a
<tt>SETO @CRITIC</tt> to prevent task switching upon interrupts, or
both.</p>
<p>Regardless of the method chosen, it is critical that each task
periodically
returns control to the scheduler, so that other tasks get a chance to
run.
This can be achieved by calling the YIELD subroutine, although most of
the other routines will also seize the opportunity to switch tasks.</p>
<h4><br>
<a name="yield1"></a>Yield</h4>
<pre>BLWP @YIELD </pre>
<p>Relinquish control to the scheduler. If a task switch can occur, it
will. A task should always call YIELD when it is idling. For instance,
suppose you scanned the keyboard and no key was pressed. Given the slow
human reaction time it is likely that, if you rescan the keyboard right
away, there still won't be any key pressed. So now is a good time to
yield.
When YIELD returns, scan the keyboard again, etc.</p>
<p>Another way to switch tasks in a cooperative program, is to
temporarily
enable preemptive multitasking, with a <tt>LIMI 2, LIMI 0</tt> pair of
instructions for instance. Toggling CRITIC also works, but in a
slightly
different manner: if a task switch does occur immediately, the new task
will run in preemptive conditions until a <tt>SETO @CRITIC</tt> is
encountered.
</p>
<h3><br>
<a name="context"></a>Context switching</h3>
<p>It is possible for a task to save several parameters as it switches
off, and to retrieve them when it's switched on again. Currently, the
scheduler
handles the following parameters:</p>
<ul>
  <li>GROM base, as specified in word &gt;837A in the scratch-pad. This
is
the address of the GROM port. </li>
  <li>Current GROM address, as obtained from the GROMs. </li>
  <li>VDP address. The address can always be set when switching on, it
can
only be saved (when switching off) if all VDP operations were performed
using my VDP access subroutines. These routines save the current
address
into the scheduler variable VADDR (initially, it is &gt;0000). </li>
  <li>VDP registers. These can always be set when switching on. They
can
only be saved reliably if my VWTRX routine was used to set the VDP
registers:
it saves them into the scheduler data area, in eight bytes starting at
address VR0. The scheduler also updates the copy of VDP register 1 in
the
scratch-pad (byte &gt;83D4, used by the keyboard scanning routine). If
VWTRX has not been used yet, the default values are those of the
Editor/Assembler
module: &gt;00, &gt;E0, &gt;00, &gt;0E, &gt;01, &gt;06,&gt;01, &gt;F5.</li>
</ul>
<p>To enable saving/retrieval of a given parameter, you must set the
corresponding
flag in the TCB. You must also provide space in the TCB to store this
variable.
Remember that a task is always switched on before it is switched off,
so
make sure you initialize these variables with some meaningfull value.
Alternatively,
you can set a value as &gt;FFFF, and FORK will automaticatically
initialize
it with the current value. </p>
<p>Flags:</p>
<pre>&gt;8000: Save / retrieve GROM base (from/to &gt;83FA)<br>&gt;4000: Save / set GROM address (from/to GROMs)<br>&gt;2000: Set VDP address<br>&gt;1000: Save VDP address (from VADDR)<br>&gt;0800: Set VDP registers<br>&gt;0400: Save VDP registers (from VR0 and following bytes)</pre>
<p>Structure of a TCB with context saving: </p>
<pre>TCB1   BYTE 0            priority<br>       BYTE 0            internal use<br>       DATA &gt;FC00    &lt;== flags <br>       DATA 0            internal use<br>       DATA 0              "<br>       DATA 0              " <br>       DATA 0              " <br>       DATA 0              "<br>       DATA &gt;9804        GRAM base buffer (set it)<br>       DATA &gt;FFFF        GRAM address (use current)<br>       DATA &gt;1234        VDP address (set it)<br>       BYTE &gt;FF,&gt;FF,&gt;00,&gt;0E,&gt;01,&gt;06,&gt;00,&gt;F5  VDP registers (use current) <br>       DATA 0            switch-time routine (none)</pre>
<h3><br>
<a name="switch-time"></a>Switch-time routine</h3>
<p>If you need to save other parameters, or to perform any kind of
operation
at switching time, you can place the address of a switch-time routine
in
the TCB, and set flag &gt;0010 to indicate its presence.</p>
<p>The scheduler will call your switch-time routine with a BLWP in six
distinct occasions. You can distinguish them by testing the value found
*R14+ (You MUST fetch this value, so as to skip a word when returning
with
RTWP).</p>
<ul>
  <li>When the task is first created, but is not running yet. *R14 =
&gt;8000
  </li>
  <li>When the task has been selected for running, before the context
was
loaded. *R14 = &gt;FFFF</li>
  <li>When the task is about to run, after context was loaded (if any).
*R14
= &gt;FFFE</li>
  <li>When the task is due to switch off, before context was saved.
*R14
= &gt;0000</li>
  <li>When the task is about to switch off, after context was saved.
*R14
= &gt;0001</li>
  <li>When the task is killed, or multitasking is terminated. *R14 =
&gt;8001</li>
</ul>
<p>If several tasks use the same switch-time routine, you can get a
pointer
to the task's TCB from the word @4(R13). Do not alter this word, nor
any
other in the scheduler's workspace!</p>
<p>An example of need for a switch-time routine would be a memory
extension
card that does bank switching. You could use such a routine to select
the
banks required by a given task.</p>
<p>Make sure you switch-time routine runs fast, as it may tremendously
slow down program execution. Remember that tasks are switched as often
as 60 times per second (50 on European consoles).</p>
<h4>Technical note</h4>
<p>If necessary, you could abort the switching operation by redirecting
R14 to a <tt>RTWP </tt>instruction. This causes the scheduler
switching
routine to return before switching was completed, so the same task will
keep running (however, some context manipulation may already have been
performed...). Don't do this during task creation though, as no
switching
will occur anyhow: the creation call is only here to give you an
opportunity
for some initialization. Don't do it during termination either, except
if TSKERR is -1. In this case redirecting R14 to a <tt>RTWP </tt>returns
from ENDTSK immediately, without calling the switch-time routines for
the
remaining tasks, nor clearing the rest of the task list.</p>
<h3><br>
<a name="instances&amp;local mem"></a>Instances and local memory</h3>
<p>It may occur that a given portion of your program is run
simultaneously
in several tasks. This "instanciation" (what an hugly neologism)
process has a main drawback though: since tasks share the same lines of
program, they act on the same variables and they'll overwrite each
other's
data! To some extent, this can be prevented by placing all data in
registers
and assigning a different workspace to each task. But that's only 16
variables...</p>
<p>A way to extend this mechanism is to reserve a different memory area
for each task (known as a local memory), and have a workspace register
point at it. All variables can then be accessed as offsets from this
pointer.
Upon request, the scheduler will conveniently place the proper address
in the register of your choice each time a task is switched on.</p>
<p>Example: </p>
<pre><u>Without instanciation</u>       <u>With instanciation     <br></u>                            THIS   EQU   0<br>                            THAT   EQU   2<br><br>       CLR  @THIS                  CLR    @THIS(R8)<br>       SETO @THAT                  SETO   @THAT(R8)<br>*                           *<br>THIS   DATA &gt;1234           LOCAL  DATA  &gt;1234   &lt;--- R8 points here<br>THAT   DATA &gt;5678                  DATA  &gt;5678<br>                            ENDLOC</pre>
<p>Actually, the address of your local data area does not need to end
up
into a register: it could be placed anywhere in memory. A register is
just
more convenient. Similarly, you can cause the scheduler to place the
address
of your workspace into a register or at any given address.</p>
<p>All this is done by setting the proper flags, and including the
required
addresses in the TCB.</p>
<p>Flags:</p>
<pre>&gt;0020: Place a pointer to the local data area into a register/address<br>&gt;0040: Place a pointer to the workspace into a register/address<br>&gt;0080: Automatically assign a data area when creating a new instance</pre>
<p>Structure of a TCB for instanciation:</p>
<pre>TCB1   BYTE 0            priority<br>       BYTE 0            internal use<br>       DATA &gt;00E0    &lt;== flags <br>       DATA 0            internal use<br>       DATA 0                "<br>       DATA 0                " <br>       DATA 0                " <br>       DATA 0                "<br>       DATA 0            local context<br>       DATA 0                " <br>       DATA 0                "<br>       BYTE 0,0,0,0,0,0,0,0  "<br>       DATA 0                "<br>       DATA LOCAL        address of local data area<br>       DATA ENDLOC-LOCAL size of local data area<br>       DATA &gt;0008        where to place ptr to data area (here: in R8)<br>       DATA THERE        where to place workspace ptr (here: in data word THERE)</pre>
<p>You can even have the scheduler assign a local data area to each
task,
as it creates it. This way, you can use the same TCB for each task
instance.
There are two requirements though: </p>
<ul>
  <li>The TCB must be part of the data area.</li>
  <li>There must be enough free space just after the data area to
create
a copy of it for each task.</li>
</ul>
<p>If you set the &gt;0080 flag in the TCB, the FORK function will copy
the whole data area somewhere in the memory immediately downstream of
it.
That's why you should reserve enough space for as many times the data
area
size, as you plan to have instances. The TCB must be part of the local
area, so that each task can have its own TCB. You may also want to have
the task's workspace in the local area, unless it's ok for all
instances
to share the same workspace. Personally, I like to place my workspace
at
the beginning of the data area: this way I can use the same pointer for
both.</p>
<pre>* Example of local data area<br>WREGS  BSS  32              workspace<br><br>THIS   DATA &gt;1234           some data<br>THAT   DATA &gt;1234<br><br>TSK1   BYTE 0,0             TCB<br>       DATA &gt;00A0<br>       DATA WREGS<br>       DATA 0,0,0,0,0,0,0,0,0,0,0<br>       DATA WREGS<br>       DATA ENDLOC-WREGS<br>       DATA &gt;0007<br>       DATA 0<br><br>COUNT  DATA 123            more data used by the task<br>DSR    TEXT 'DSK1.'   <br>       EVEN                *must* end on a even address   <br>ENDLOC<br><br>       BSS  ENDLOC-WREGS   space for 1 instance<br>       BSS  ENDLOC-WREGS   space for 2 instances<br>       BSS  ENDLOC-WREGS   etc.</pre>
<h3><br>
<a name="TCBs"></a>Fooling around with TCBs</h3>
<p>The Task Control Block is the key structure that governs the
behaviour
of a task. In addition, it is used by the scheduler to store important
variables upon task switching. Therefore, TCBs should always be
modified
with due caution. In particular, the scheduler does not have time for
sanity
checks, so absurd values (that would be rejected by FORK) will be
blindly
accepted upon task switching. Also remember that the TCB of the current
task is different from these of currently "off" tasks: part of
its contents will be overwritten when the task switches off.</p>
<p>Finally, beware that a task switch may occur in the middle of your
modifications.
You should thus make sure that the task you are modifying will not be
selected
before you are done. This can be achieved by INVerting its semaphore
word
(at offset +12 whithin the TCB), but don't forget to <tt>INV </tt>it
again
when done otherwise your task will never run! </p>
<h4><br>
<a name="gettcb1"></a>GetTCB</h4>
<p>The routine GETTCB can be used to obtain the address of a TCB, by
providing
the task ID. Don't assume that you know where the TCB is: if the task
is
instanciated, each instance will have its own copy of the TCB,
somewhere
downstream in the local memory area...</p>
<pre>BLWP @GETTCB</pre>
<p>Called with the task ID in R0 (or &gt;0000 for the current task),
returns
a pointer to the TCB in R1. If an error occurs (e.g. the task ID is
incorrect)
GETTCB returns with the Eq bit set, and R1 contains zero.</p>
<p>If you call GETTCB with &gt;FFFF in R0, it returns a pointer to the
task list in R1. You can the walk the list with a series of <tt>MOV
*R1+</tt>,
and so get pointers to the TCBs of all tasks currently alive (whether
they
are ready to run or not), in no particular order. </p>
<p>Possible values for each word in the list are: </p>
<ul>
  <li>&gt;0000: Empty slot, skip this word </li>
  <li>&gt;0001: End of list </li>
  <li>Other: Pointer to a TCB</li>
</ul>
<h4><br>
<a name="TCB structure"></a>Structure of a Task Control Block</h4>
<p>Now let's examine the different fields that make up a TCB. The names
correspond to labels defined in the TASKS/EQU file. Except that in the
file they are provided as EQU offsets, so that you can use them with a
task pointer. For instance: <tt>CLR @TVAD(R1)</tt>.</p>
<pre><a href="#tprior">TPRIOR</a> BYTE 0            priority<br><a
 href="#tbyte1">tbyte1</a> BYTE 0            internal use only (no EQU)<br><a
 href="#tflags">TFLAGS</a> DATA &gt;0000        flags <br><a href="#tws">TWS</a>    DATA 0            workspace buffer<br><a
 href="#tpc">TPC</a>    DATA 0            program counter buffer<br><a
 href="#tst">TST</a>    DATA 0            status buffer<br><a
 href="#tcount">TCOUNT</a> DATA 0            time counter<br><a
 href="#tsem">TSEM</a>   DATA 0            semaphore ptr<br>*-------------optional from here down----------------*<br><a
 href="#tgba">TGBA</a>   DATA 0            GRAM base buffer<br><a
 href="#tgad">TGAD</a>   DATA 0            GRAM address<br><a
 href="#tvad">TVAD</a>   DATA 0            VDP address<br><a href="#tvr">TVR</a>    BYTE 0,0,0,0,0,0,0,0  VDP registers<br><a
 href="#tswi">TSWI</a>   DATA 0            switch-time routine<br><a
 href="#tloc">TLOCAL</a> DATA 0            address of local data area<br><a
 href="#tlsize">TLSIZE</a> DATA 0            size of local data area<br><a
 href="#tlptr">TLPTR</a>  DATA 0            were to place ptr to local data area<br><a
 href="#twsptr">TWSPTR</a> DATA 0            where to place workspace ptr</pre>
<p><a name="tprior"></a><b>TPRIOR </b>Priority. The meaning of this
field
has been discussed <a href="#set%20priority">above</a>. If you modify
it
"on the fly", it will take effect immediately and is likely to
affect the next task switch. Note that only FORK understands a priority
of zero as "same as parent" </p>
<p><a name="tbyte1"></a><b>TBYTE1</b>. This byte is reserved by the
scheduler
for storage of some status flags (currently: whether the taks is hanged
by a GRAB, a WAIT, or a BARIER). Better don't touch this field. Always
use byte-oriented operations to deal with the priority byte.</p>
<p><a name="tflags"></a><b>TFLAGS</b>. Here is a summary of the flags
currently
understood by the scheduler.</p>
<pre>&gt;8000: Save / set GROM base (from/to &gt;83FA)<br>&gt;4000: Save / set GROM address (from/to GROMs)<br>&gt;2000: Set VDP address<br>&gt;1000: Save VDP address (obtained from VADDR)<br>&gt;0800: Set VDP registers<br>&gt;0400: Save VDP registers (obtained from VR0 and following bytes).<br>&gt;0080: Automatically assign a data area when creating a new instance<br>&gt;0040: Place a pointer to the workspace into a register/address<br>&gt;0020: Place a pointer to the local data area into a register/address<br>&gt;0010: Call a switch-time routine</pre>
<p>If you change a flag, it will only have effect the next time this
task
is switched on or off. Be carefull that many flags affect the size of
the
TCB. The length of the TCB is defined by the last word for which a flag
is set (even if all previous words are not used, they are still there).
Hence it is useless (and risky) to enable context saving in a minimal
TCB
that does not contain room for this purpose! </p>
<p><br>
<a name="tws"></a><b>TWS </b>Task workspace buffer. Note that only
FORK
recognises a zero as "same as parent". Any value that you put
in here will be used as workspace, no matter how crazy it is, the next
time this task is switched on. </p>
<p>For the current task, this value is the worskpace used when the task
was switched on. There is no guaranty that it is still the current
workspace.
This value will be updated when the task switches off.</p>
<p><br>
<a name="tpc"></a><b>TPC </b>Task PC buffer, indicates where execution
will resumes next time the task is switched on. Note that only FORK
understands
a zero as "after the FORK statement". Any value placed in here
will be used as a start point next time the task switches on.</p>
<p>For the current task, this value indicates where the task resumed
last
time it was selected. It will be overwritten when the task switches off.</p>
<p><br>
<a name="tst"></a><b>TST </b>Task status buffer. This value will be
placed
in the status register when the task is switched on. Caution: it
contains
the interrupt mask! If you modify it, make sure it ends with &gt;xxx2
for
preemptive multitasking, with &gt;xxx0 for cooperative multitasking.
For
the current task, this value will be overwritten when the task switches
off.</p>
<p><br>
<a name="tcount"></a><b>TCOUNT </b>Time counter. This variable is
initialized
by FORK and used by the scheduler to determine which task should run
next.
The value will be reset as zero for the selected task. For all other
tasks
that could have been selected but were not (i.e. not hanged, same
priority
class), this word will be incremented by the in-class priority value
(after
masking out the class bits).</p>
<p>Setting this word as &gt;FFFF almost guaranties that the task will
run
soon, provided it has the right priority class and is not stalled at a
semaphore. For the current task, this word is always zero, any change
will
become effective when the task is switched off.</p>
<p>Conversely, setting TCOUNT as &gt;0000 renders the task less likely
to run. It may still be selectect though, if no other task is ready to
run.</p>
<p><br>
<a name="tsem"></a><b>TSEM </b>Semaphore buffer. This variable is used
by the scheduler to store a pointer to the semaphore currently hanging
the task. This word must be &gt;0000 for the task to run. You can clear
a non-zero word, to make the task ready to run, or use a non-zero value
to prevent a task from running. </p>
<p>The latter is a bit dangerous: make sure you don't overwrite an
existing
semaphore pointer! I recommend using the INV instruction: it will turn
&gt;0000 to &gt;FFFF and modify any existing semaphore value so that it
will not be cleared by a DROP in another task. A second INV will
restore
the previous value if needed. A potential problem is that the actual
semaphore
may have been cleared in the mean time, and our task won't know about
it.
Thus it will still hang, as the scheduler has no time to check
semaphore
values (the mere presence of a semaphore pointer in the TCB marks the
task
as suspended).</p>
<p><br>
The remaining fields are only meaningfull if the corresponding flag is
set in TFLAGS. They may be missing in some TCBs, but their order is
invariable
(i.e. TCBs "grow" from the bottom).</p>
<p><br>
<a name="tgba"></a><b>TGBA </b>Buffer for GROM base. This value will
be
transfered to word &gt;83FA when the task switches on, provided the
corresponding
flag is set in TFLAG. Caution: a value that does not correspond to a
GROM
base (i.e. in the range &gt;9800-983C) will crash the GPL interpreter
and
any program making use of this value. </p>
<p>The current task will overwrite this value with the content of word
&gt;83FA as the task switches off.</p>
<p><br>
<a name="tgad"></a><b>TGAD </b>Buffer for GROM address. This value
will
be set as the current GROM (or GRAM) address when the task is switched
on, provided the corresponding flag is set in TFLAGS. The current task
overwrites this value with the current GROM address, as obtained from
the
GROMs (with the -1 address correction).</p>
<p><br>
<a name="tvad"></a><b>TVAD </b>Buffer for VDP address. This value will
be set as the current VDP address when the task switches on, if the
corresponding
bit is set in TFLAGS. It must contain the read/write indication bit,
i.e.
write operations add &gt;4000 to the actual address. The value is also
copied into VADDR.</p>
<p>The current task will overwrite this value with the content of word
VADDR in the scheduler memory, if the corresponding (and distinct) bit
in TFLAGS is set.VADDR is maintained by the VDP access subroutines
VSBRX,
VMBRX, VXBWX, VMBWX and VIBW.</p>
<p><br>
<a name="tvr"></a><b>TVR </b>Buffer for the eight VDP registers. If
the
corresponding bit is set in TFLAGS, these 8 bytes will be send to the 8
VDP registers when the task is switched on. They will also be copied
into
byte VR0 and following in the scheduler's memory.</p>
<p>Another bit in TFLAGS causes these values to be overwriten by byte
VR0
and following, as the current task switches off. VR0 and the next 7
bytes
contain copies of the VDP register values set by the VWTRX subroutine.</p>
<p><br>
<a name="tswi"></a><b>TSWI </b>Address of the switch-time routine. The
use of this routine has been discussed <a href="#switch-time">above</a>.
It must be enabled by setting the corresponding bit in TFLAGS. Once
this
is done, the routine will be called twice when the task is switched on,
and twice when it switches off. (Remember that the current task is next
due to switch off, not on).</p>
<p><br>
<a name="tloc"></a><b>TLOCAL </b>Address of the local memory area.
This
address is used by TFORK to create instances, provided the
corresponding
bit is set in TFLAGS. When a task is switched on, this value will be
placed
at the address specified in TLPTR, if the corresponding bit is set in
TFLAGS.
Nothing happens when the task is switched off.</p>
<p><br>
<a name="tlsize"></a><b>TLSIZE </b>Size of the local memory area. This
value is only used by TFORK to create instances. Modifying it on the
fly
has no effects.</p>
<p><br>
<a name="tlptr"></a><b>TLPTR </b>Pointer to local memory area. This
can
be either a register number, from 0 to 15, or an address. If the
corresponding
bit is set in TFLAGS, the address of the local memory area will be
placed
in the specified register or address when the task is switched on.
Nothing
happens when the task is switched off.</p>
<p><br>
<a name="twsptr"></a><b>TWSPTR </b>Pointer to the workspace. Can be an
address or a register number, from 0 to 15. If the corresponding bit is
set in TFLAGS, the address of the task workspace will be placed in this
register, or at this address, when the task switches on. Nothing
happens
when it switches off.</p>
<h3><br>
<a name="Error codes"></a>Scheduler error codes</h3>
<p>When an error occurs, an error code can be retrieve from the word
TSKERR.
If no error occured, the content of this word is meaningless.
Currently,
the following codes are defined (in the TASKS/EQU files).</p>
<pre>RMEM    EQU     &gt;0001   Out of memory. Most likely, too many tasks were created.<br>RINST1  EQU     &gt;0002   Instanciation error #1. The TCB is not in local memory.<br>RNOTID  EQU     &gt;0003   Wrong task ID (may have been valid, but task is now dead).<br>RNOTPT  EQU     &gt;0004   Not a valid address for a pointer (e.g. ROM space).<br>RGPL    EQU     &gt;0005   Error in TCB for GPL task (most likely, FGAD flag missing).<br>RNORUN  EQU     &gt;0081   Fatal error. Nothing to run. </pre>
<p>When checking the error code, use the label rather than the numeric
value. This way, if the code change in the future, your program will
still
work (you will only need to update the /EQU file).</p>
<h4><br>
<a name="fatal"></a>Fatal errors</h4>
<p>If the scheduler cannot find a task ready to run, either because you
killed them all, or because they are all hanged at semaphores, the
TI-99/4A
will be reset. </p>
<p>This kind of error typically occurs when task 1 waits for a
semaphore
grabbed by task 2, and then task 2 starts waiting for a semaphore
grabbed
by task 1... One way to avoid this error is to number your semaphores
(SEM1,
SEM2, etc) and adopt the rule that a task should never wait for a
semaphore
with a number smaller than the highest one it has already grabbed, but
not dropped yet. </p>
<p>Of course, there is also the case when a given task is killed before
it has dropped all the semaphores it had grabed.... Or when a tasks
grabs
twice the same semaphore... There is no failsafe strategy here, apart
from
carefull programming.</p>
<p>The scheduler provides you with a way to catch fatal errors before
it
resets the TI-99/4A. To this end, it defines the semaphore ERRSEM, with
an initial value of &gt;3000. You can have your error-handling task
wait
for that semaphore with either GRAB, WAIT, or BARIER (the latter is
recommended).
When a fatal error occurs, the scheduler clears the semaphore and
attempts
to run any task(s) that were waiting for it. </p>
<p>A task that handles the error successfully should reset the
semaphore
as &gt;3000, a task the cannot handle it should simply INCT the
semaphore
and loop back to the BARIER call. If no tasks was able to handle the
lock-up,
the scheduler will reset the TI-99/4A (the scheduler won't free the
semaphore
again if its value is less than &gt;2000, so as not to loop forever).</p>
<h3><br>
<a name="Standard utilities"></a>Standard assembly utilities</h3>
<p>For your convenience, the scheduler comes with another file, SUBS/O,
which contains the standard assembly language utilities, suitably
modified
for multitasking (namely, they are enclosed in a critical section).
While
I was at it, I also added a few extra features.</p>
<p><b>VSBRX </b>Just like VSBR, but tests for 0 in R2 and saves the
final
address in VADDR.</p>
<p><b>VMBRX </b>Just like VMBR, but tests for 0 in R2 and saves the
final
address in VADDR.</p>
<p><b>VSBWX </b>Just like VSBW, but tests for 0 in R2 and saves the
final
address in VADDR.</p>
<p><b>VMBWX </b>Just like VMBW, but tests for 0 in R2 and saves the
final
address in VADDR.</p>
<p><b>VIBW</b>. New routine: VDP Identical Bytes Write. Writes multiple
occurences of the same byte in VDP memory and saves the final address
in
VADDR. <br>
<u>Parameters</u>: <br>
R0 = VDP address <br>
R1(msb) = byte to write <br>
R2 = number of repeats (&gt;0000 does nothing).</p>
<p><b>VWTRX </b>Just like VWTR, but saves register values in VR0 and
following
bytes in the scheduler memory.</p>
<p><b>KSCANX </b>Just like KSCAN, but returns with the Eq bit set if a
new key was pressed, and with the H bit set if the same key was held. </p>
<p><u>Usage</u>:</p>
<pre>      BLWP @KSCANX<br>      JEQ  NEW<br>      JH   SAME<br>      JMP  NONE</pre>
<p><b>XMLLNX </b>Just like XMLLNK.</p>
<p><b>GPLLNX </b>Just like GPLLNK, but does not require the
Editor/Assembler
cartridge. It makes use of some data byte in the console GROMs to
simulate
a dummy XML and regain control when then called GPL routine returns. As
this may be console dependent, the critical values can be modified by
changing
the two words immediately preceding GPLLNX:</p>
<pre>       LI   R1,GPLLNX    get ptr to GPLLNX<br>       MOV  ...,@-2(R1)  change the RAM vector<br>       MOV  ...,@-4(R1)  change the GROM address<br> </pre>
<p>The GROM address must be that of a &gt;0F byte, which will be
interpreted
as an XML. The next byte will indicate where the XML vector is located.
This must be an address in RAM. <a href="../gpl2.htm#XML">Calculate</a>
its value and place it in the word @-2(R1).</p>
<p>GPLLNX also provides an alternative syntax, to call routines that
are
normally called with the GPL routine G@&gt;0010. This requires passing
the GROM base together with the desired address:</p>
<pre>       BLWP @GPLLNK<br>       DATA &gt;0000       Flag: alternate syntax<br>       DATA &gt;98xx       GROM base<br>       DATA address     Address in GROM/GRAM memory</pre>
<p><br>
<b>DSRLNX </b>Just like DSRLNK, but the DATA statement is optional: if
omited it is assumed to be DATA &gt;0008, i.e. calling a DSR. Also,
when
DSRLNX has found the DSR/subprogram, it saves all parameters for use by
DSRRPT.</p>
<p><br>
<b>DSRCRU </b>New routine. Just like DSRLNK but begins scanning the
peripheral
cards with the CRU base specified in word &gt;83D0.</p>
<p><br>
<b>DSRRPT </b>New routine. Calls the same DSR or subprogram that was
previously
called with DSRLNX. Caution: make sure a task switch did not result in
calling DSRLNX in another task. This is a good example of what a mutex
semaphore can be used for...</p>
<h2>
<hr width="100%"><a name="GPL"></a>Multitasking GPL programs</h2>
<p>The scheduler for GPL is the same as for assembly, with a thin
wraper
that allows you to call each routine with an XML. In order not to
uselessly
clutter the XML table, you have the option to call all routines with a
single XML.</p>
<p>Remember that the GPL interpreter performs a <tt>LIMI 2, LIMI 0</tt>
in between instructions, except while it's in the FMT sub-interpreting
mode (screen access: always <tt>LIMI 0</tt>). Therefore, multitasking
will
always be preemptive, unless you perform a <tt>DST &gt;FFFF,@CRITIC</tt>.
Assembly routines called from GPL (with either a XML instruction or the
DSR-calling routine <tt>G@&gt;0010</tt>) will be cooperative. If you
want
preemptive multitasking in assembly, you must include a <tt>LIMI 2</tt>
in the called assembly routine.</p>
<p>The following files are provided:</p>
<pre><u>Filename     Type    Contents                                         <br></u>TASKGPL      Prog    Scheduler. Allows multitasking in assembly and GPL<br>TASKG/EQU    DV80    Equates to be used in your programs<br>GPLDEMO/T    DV80    Demo program (source text)<br>GPLDEMO/C    DF80    Demo program (tagged-object code)<br>GPLDEMO      Prog    Demo program (GROM image, in GramKracker format)<br>TASKG/S      DV80    Source file: XML wrapper around the assembly scheduler</pre>
<h3><br>
Loading the scheduler</h3>
<p>The GPL scheduler comes in the form of a "program" file, called
TASKGPL. It is nothing more than the assembly scheduler (TASKS/O) with
a thin wrapper to allow XML calls. If you are interested, have a look
at
the file TASKG/S, that contains the source for the wrapper. </p>
<p>The scheduler can easily be loaded from disk into the high memory
expansion
with the following routine:</p>
<pre>       MOVE 22,G@PAB,V@&gt;1000          or whatever VDP address you like<br>       DST  &gt;1009,@&gt;8356              pointer to name size byte<br>       CALL G@&gt;0010                   call DSR<br>       BYTE &gt;08<br>       BS   ERROR                     handle errors</pre>
<pre>       DST  V@&gt;1102,@&gt;834A            get size<br>       DST  V@&gt;1104,@&gt;834C            get address (should be &gt;A000)<br>       MOVE @&gt;834A,V@&gt;1106,@0(@&gt;834C) copy program in CPU mem<br>       ...                            and use it<br><br>PAB    DATA    &gt;0500                  PAB for file access<br>       DATA   &gt;1100                   VDP buffer address<br>       DATA    &gt;0000<br>       DATA    &gt;2000                  max file size<br>       BYTE    &gt;00<br>       STRI    'DSK1.TASKGPL'          filename (string including size byte)<br></pre>
<p>This will load the scheduler at the beginning of the high memory
expansion,
from &gt;A000 to &gt;AA20. You can then use XML &gt;B1 through &gt;BB
to
access the scheduler. Alternatively, you can access it exclusively
through
XML &gt;B0 and use the other XML entries for your own vectors. In case
you would want to restore them afterwards, there is an internal copy
(used
by XML &gt;B0) at addresses &gt;A020-A037.</p>
<p>You can access the scheduler variables at the following addresses
(included
in the file TASKG/EQU):</p>
<pre>CRITIC  EQU     &gt;A286                   &gt;FFFF = critical section, &gt;0000 = normal<br>TSKERR  EQU     &gt;A288                   scheduler error code<br>ERRSEM  EQU     &gt;A28A                   semaphore for fatal error barrier<br>VADDR   EQU     &gt;A28C                   VDP address buffer (not used by GPL)<br>VR0     EQU     &gt;A28E                   VDP register buffers (not used by GPL)</pre>
<h3><br>
<a name="context saving"></a>Context saving</h3>
<p>The VDP context cannot be saved in GPL, because the GPL interpreter
uses its own routines rather than those I modified for use with
multitasking.
It should not matter too much though, since GPL considers all VDP
access
operations as critical sections. Just remember that you cannot assume
the
VDP address will be maintained from one instruction to the next (which
should never be assumed with GPL anyhow).</p>
<p>The GROM context must always be part of the TCB, since this is the
way
GPL will be multitasked. The XML wrapper around FORK will reject a TCB
that does not have the corresponding flag set. Saving and retrieving
the
GROM base is optional.</p>
<p>The GPL interpreter uses some critical bytes in the scratch-pad
memory
(&gt;8300-83FF), that must be saved upon task switching for proper
functionning.
The GPL scheduler provides a default switch-time routine that is
automatically
implemented if you don't specify one. This routine saves and retrieves
the following: </p>
<ul>
  <li>Bytes &gt;8372-8373 </li>
  <li>Bytes &gt;837C-837F </li>
  <li>Subroutine stack (&gt;8380 to pointer in &gt;8373) </li>
  <li>Data stack (&gt;83A0 to pointer in &gt;8372)</li>
</ul>
<p>These values are saved at the top of your local memory area,
provided
you specifed one (you don't need to set the "instanciation" flag).
If you didn't specify a local area, the default switch-time routine
will
not be installed !</p>
<p>If you want to save more context, you will have to implement your
own
switch-time routine in assembly. You can finish by linking to the
default
routine with <tt>B @&gt;A040</tt>: it will save the above parameters
and
return to the scheduler with <tt>RTWP</tt>. Caution: the default
routine
performs a <tt>MOV *R14+</tt> to get the calling code, so if your
routine
also needs this code word, it should get it with <tt>MOV *R14</tt>, so
that R14 does not get incremented twice!</p>
<h3><br>
<a name="XMLs"></a>XML routines</h3>
<p>There are 12 routines that can be called from GPL. Rather than
remembering
their numbers, you can include the file TASKG/EQU in your program. In
addition
to TCB offsets, flags and error codes, it defines the following labels:</p>
<pre><a href="#B0">XML0</a>   EQU  &gt;B0         XML base (table is at &gt;A000)<br><a
 href="#B1">INITSK</a> EQU  XML0+1      Initialize scheduler<br><a
 href="#B2">FORK</a>   EQU  XML0+2      Create a new task<br><a
 href="#B3">KILL</a>   EQU  XML0+3      Kill a task<br><a href="#B4">DIE</a>    EQU  XML0+4      Kill current task<br><a
 href="#B5">YIELD</a>  EQU  XML0+5      Return control to the scheduler<br><a
 href="#B6">GRAB</a>   EQU  XML0+6      Grab a semaphore<br><a
 href="#B7">WAIT</a>   EQU  XML0+7      Wait for a semaphore<br><a
 href="#B8">BARIER</a> EQU  XML0+8      Wait at a barrier<br><a
 href="#B9">DROP</a>   EQU  XML0+9      Drop a semaphore<br><a
 href="#BA">RAISE</a>  EQU  XML0+10     Raise a semaphore<br><a
 href="#BB">GETTCB</a> EQU  XML0+11     Get TCB pointer from task ID<br><a
 href="#BC">ENDTSK</a> EQU  XML0+12     Terminate multitasking</pre>
<p>The corresponding call becomes, for instance: </p>
<pre>       XML  INITSK</pre>
<p>For detailed instructions on the use of these routines, see the
chapter
on multitasking assembly language. What follows here is just a quick
description
of how to call each XML routine.</p>
<h4><br>
<a name="B0"></a>XML &gt;B0 Call any multitasking routine</h4>
<p>This is the common entry point to all routines. It allows you to
overwrite
the remaining entries in the XML table, in case you need them for your
program.</p>
<p>Byte &gt;834A needs a routine number, from 1 to 11. This number
corresponds
to the second digit of the XML number, as described above (but the
first
digit is ignored anyhow, so you can use the same labels). Parameter
passing
is the same as for a direct call via a dedicated XML.</p>
<p>Example: </p>
<pre>       ST   INTISK,@&gt;834A     routine to be called<br>       DST  &gt;FFFF,@&gt;834C      pass parameter<br>       XML  &gt;B0               call it</pre>
<h4><br>
<a name="B1"></a>XML &gt;B1 call INITSK</h4>
<p>Word &gt;834C contains the TCB pointer, or &gt;FFFF to use the
default
TCB.</p>
<p>You can have upto 32 tasks running, including the parent program. </p>
<h4><br>
<a name="B2"></a>XML &gt;B2 call FORK</h4>
<p>Word &gt;834C contains the TCB pointer (in cpu memory).</p>
<p>Upon return, byte &gt;834B will contain the task ID, or &gt;00 if an
error occured (you can get the error code from word TSKERR)</p>
<p>This XML can be used to create either assembly or GPL tasks. To
start
an assembly task, you must specify its address in the TPC entry of the
TCB (the task will generally start with a <tt>LIMI 2</tt>
instruction).
If you don't, the XML wrapper assumes you want to start a GPL task and
clears the TWR and TPC entries in the TCB.</p>
<p>If you would like the child GPL task to start at a different GRAM
address,
you must set this address in the GAD file of the TCB. If you set this
field
as &gt;FFFF, the scheduler will substitute the current GRAM address for
it (which means the child task will return after the <tt>XML &gt;B2</tt>).</p>
<p>If the child task returns after the XML, it will have the Cnd bit
set.
The parent task returns with the Cnd bit reset, so you can tell parent
from child with a <tt>BR </tt>(resp. <tt>BS</tt>) instruction.</p>
<h4><br>
<a name="B3"></a>XML &gt;B3 call KILL</h4>
<p>Byte &gt;834B must contain a valid task ID, or &gt;00 for the
current
task. </p>
<p>Invalid ID errors return with the Cnd bit set and can be trapped
with
<tt>BS</tt>. TSKERR will contain the value RNOTID. </p>
<h4><br>
<a name="B4"></a>XML &gt;B4 call DIE</h4>
<p>No parameter is required.</p>
<h4><br>
<a name="B5"></a>XML &gt;B5 call YIELD</h4>
<p>No parameter is required.</p>
<p>The instruction returns with the Cnd bit set if a task switch
effectively
occured, with the Cnd bit reset otherwise. </p>
<h4><br>
<a name="B6"></a>XML &gt;B6 call GRAB</h4>
<p>Word &gt;834C must contain the address (in cpu memory) of the
semaphore
to be grabbed. </p>
<p>The Cnd bit will be set if the semaphore was grabbed immediately and
reset when the task hanged for a while before the semaphore became
available.</p>
<h4><br>
<a name="B7"></a>XML &gt;B7 call WAIT</h4>
<p>Word &gt;834C must contain a pointer to the semaphore to be waited
for.
</p>
<p>Just like the above, a reset Cnd bit indicates that no waiting
occured,
a set bit signals that the task hanged for a while.</p>
<h4><br>
<a name="B8"></a>XML &gt;B8 call BARIER</h4>
<p>Word &gt;834C must contain a pointer to the semaphore controlling
the
barrier. </p>
<p>Here also, the Cnd bit can be used to detect whether the task hanged
at the barrier (jumps on <tt>BS</tt>) or went right through (jumps on <tt>BR</tt>).</p>
<h4><br>
<a name="B9"></a>XML &gt;B9 call DROP</h4>
<p>Word &gt;834C must contain a pointer to the semaphore to be dropped.
</p>
<p><tt>BS </tt>can be used to detect cases when this caused a task
switch,
<tt>BR </tt>for cases when the task continued normally.</p>
<h4><br>
<a name="BA"></a>XML &gt;BA call RAISE</h4>
<p>Word &gt;834C must contain a pointer to the semaphore to be raised.
</p>
<p>This will rarely cause a task switching (unless the semaphore value
was negative), but if this is the case the Cnd bit will be set upon
return.</p>
<h4><br>
<a name="BB"></a>XML &gt;BB call GETTCB</h4>
<p>Byte &gt;834B must contain a valid task ID, or &gt;00 for the
current
task.</p>
<p>Upon return, word &gt;834C will contain the task pointer, or
&gt;0000
if the task ID was invalid. Such an error sets the Cnd bit and can be
detected
with a <tt>BS</tt>.</p>
<p>If &gt;834B contains &gt;FF, the word &gt;834C will contain a
pointer
to the task list upon return. </p>
<h4><br>
<a name="BC"></a>XML &gt;BC call ENDTSK</h4>
<p>No parameter is required. </p>
<address><br>
<br>
Revision 1. 7/28/01. OK to release<br>
Revision 2. 9/9/01. Minor changes to Basic scheduler<br>
</address>
<center>
<p><a href="titechpages.htm">Back to the TI-99/4A Tech Pages</a></p>
</center>
</body>
</html>
