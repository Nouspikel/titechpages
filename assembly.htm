<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
  <title></title>
  <meta name="Author" content="">
  <meta name="GENERATOR"
 content="Mozilla/3.04Gold (Win95; U) [Netscape]">
</head>
<body>
<h1 align="center"><a
 href="http://www.nouspikel.com/ti99/titechpages.htm"><img
 src="logo.jpg" style="border: 0px solid ; height: 33px; width: 95px;"
 title="" alt=""></a></h1>
<h1>Assembly language primer</h1>
<p>Hey, I said "primer". Not "tutorial", ok?</p>
<p><a href="#Machine%20language">Machine language<br>
</a><a href="#Assembly%20language">Assembly language<br>
</a><a href="#Registers">CPU registers<br>
</a><a href="#Addressing%20modes">Addressing modes<br>
</a><a href="#bytes%20vs%20words">Bytes vs words</a></p>
<p><a href="#opcodes">Opcodes<br>
</a><a href="#instructions">Common assembly-time instructions</a></p>
<p><a href="#Encoding%20format">Encoding format<br>
</a><a href="#hex%20notation">Hexadecimal notation</a></p>
<p><br>
</p>
<h2><a name="Machine language"></a>Machine language</h2>
<p>Basically, a computer consists of a microprocessor together with
some
memory. All the additional gear (keyboard, screen, mouse, etc) is just
here for a secondary purpose: allow a human to interface with the
computer.</p>
<p>The microprocessor is the brain of the computer: it controls the
whole
system according to the instructions contained in a program. But no
matter
how sophisticated, the microprocessor still does not understand
english!
The only thing it understands are numbers. In the case of the TI-99/4A,
numbers from 0 to &gt;FFFF, i.e. 65535 (if you don't know what I mean
by
&gt;FFFF, thre will be an <a href="#hex%20notation">explanation</a> of
the
hexadecimal notation at then end of this page).</p>
<p>Each operation that the microprocessor can execute has been assigned
a number: &gt;A000 (40960) for addition, &gt;6000 for substraction,
etc.
A program is nothing else that a carefully arranged list of such
numbers.</p>
<p>Actually, I slightly oversimplified the situation. Some instructions
are encoded by a unique number, but most can be encoded by a range of
numbers,
depending on their targets. Let's thake the negation operation for
instance:
it can be encoded by any number between &gt;0500 and &gt;053F. Each
number
corresponds to a different target for the instruction: &gt;0500
instructs
the microprocessor to negate register 0, &gt;0501 to negate register 1,
etc.</p>
<p>The set of valid numbers accepted by the processor therefore
constitues
a language. It is called "machine language". In the case of the
TI-99/4A, the microprocessor (the TMS9900) understands 69 different
instructions,
encoded by a total of 57792 numbers (i.e. some numbers do not
correspond
to any valid instruction).</p>
<h2><br>
<a name="Assembly language"></a>Assembly language</h2>
<p>As you probably realise, machine language is not very convenient for
a human to use. Who's gonna recall 57792 numbers and know what they are
used for? It is possible to program directly in machine language: I can
do it to some extent, to patch a program with a sector editor for
instance.
But this is only convient for tiny bits of program using a small subset
of instructions. If we want to do anything more complex, we'll need an
assembler.</p>
<p>An assembler is a program that translates human managable mnemonics
into machine language. For instance, the mnemonic for the addition is
"A",
the one for substaction is "S" and the one for negation is "NEG".
Such mnemonics are called "opcode" for operation code.</p>
<p>Another set of mnemonics can be combined with the opcodes to define
the target of an instruction (i.e. its operand). For instance, register
0 would be designated as "R0" and register 1 as "R1".</p>
<p>To negate register 0 you would write:</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre><tt>       NEG  R0       </tt></pre>
      </td>
    </tr>
  </tbody>
</table>
<p>Similarly, to add R1 to R0:</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre><tt>       A    R1,R0      </tt></pre>
      </td>
    </tr>
  </tbody>
</table>
<p>It's easier to handle than machine language isn't it? </p>
<p>This set of opcodes and operands is called "assembly language".
It's nothing else than a litteral representation of machine language in
a human-managable form.</p>
<p>Of course, since we are using an assembler, we could as well add
some
extra features that will make our life easier. The assembler may
automatically
check for syntax errors and tell us about it. It may also allow us to
replace
numbers with alphanumeric "labels". For instance, I could define
a label for the number 10:</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre><tt>TEN   EQU  10       </tt></pre>
      </td>
    </tr>
  </tbody>
</table>
<p>EQU means "equates" and is not an opcode, in that it will
not be translated to machine language. It is an assembly-time
instruction,
used to tell the assembler that we would like to use the word "TEN"
as a synonym for the number ten. Wherever we write "TEN" in our
program the assembler will replace it with 10 before it translates the
program into machine language:</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre><tt>       LI   R0,TEN       Is equivalent to:<br>       LI   R0,10        And loads the value 10 into R0 </tt></pre>
      </td>
    </tr>
  </tbody>
</table>
<p>Whereas opcodes and operands are pretty much defined by the
structure
of the microprocessor, assembly instructions are only limited by the
programers
imagination. Therefore, different assemblers may used very different
instructions.
In all examples you'll find on this website, I have used the
instruction
set of the original assembler released by Texas Instruments with the
module
"Editor/Assembler".</p>
<h4>Object files</h4>
<p>Conceivably, an assembler could load machine code directly into
memory
at then end of the assembly process. But that would not be convenient
because
you would have to re-assemble a program every time you want to execute
it. Therefore most assemblers are file-based programs. </p>
<p>The TI assembler takes its input from a Dis/Var 80 text file and
produces
a Dix/Fix 80 object file in tagged-object format. It also offers you
the
option to produce a list file, where all syntax error will be reported:
this is easier than trying to jot them down as they flash on screen!</p>
<p>The object file contains machine language mixed with special
instructions
for the linker and the loader (the 'tags'). If you are curious, the
tagged-object
format of this file is described in my <a
 href="ea_mod.htm#tagged-object">page</a>
on the Editor/Assembler cartridge.</p>
<h4>Linker</h4>
<p>A linker is a program that lets you piece together several object
files
assembled independently. This is a nice feature when you write really
big
assembly programs, because it means that you don't have to re-assemble
a mammoth program every time you make a small change. You can split the
program into smaller files and assemble them separately, then you only
re-assemble the one you modified.</p>
<p>Also, you could have a library of usefull routines, whether written
by you or not, and link them to your program as independently assembled
files. This saves you the need to reinvent the wheel for every program.</p>
<p>Finally, some linkers will let you link assembly with other
languages,
such as GPL or Extended Basic.</p>
<p>A very good linker is the RAG linker, from R.G. Green. It takes one
or more DF80 object files and produces an executable version of the
program,
in the form of a memory-image "program" file. </p>
<p>The memory-image file must then be loaded into memory by yet another
program, called a loader. The Editor/Assembler cartridge contains such
a loader in its option 5, which is why memory-image files are often
refered
to as EA5 files. The TI-writer option 3 also calls an EA5 loader, so do
Funnelweb options 1 to 3. Finally, you will find a stand-alone loader
on
this site: my <a href="download.htm#MILD%20and%20MISS">MILD</a> loader
that
let's you load both machine language and GPL.</p>
<p>Texas Instruments also came up with several hybrid "linking-loaders"
which you'll find in Editor/Assembler option 3, Mini-memory option 1
and
Extended Basic CALL LOAD. As their name implies, these programs perform
linking while the program is loaded. This is much slower then loading
EA5
files, but it has the advantage that object files can be loaded
anywhere
there is room in memory, whereas EA5 files are meant to run at a
predefined
location. Also, linking with Extended Basic is easier this way.</p>
<p>Once the program is in memory, you can use a small utility called
SAVE
to dump it into an EA5 program file.</p>
<p>In summary, the process of creating assembly language programs can
be
represented as such:</p>
<pre>Your brain<br>     |<br>     | Editor<br>     |<br>     V<br>Text File (DV80)<br>     |<br>     | Assembler<br>     |<br>     V<br>Object file (DF80)  Other object files (DF80)<br>     |                |<br>     | Linker         |<br>     |                |<br>     V                V<br>Memory-image EA5 file (Program)<br>     |<br>     | EA5 loader<br>     |<br>     V<br>Program is executed in memory</pre>
<p>Alternatively, using the TI Editor/Assembler cartridge:</p>
<pre>Your brain<br>     |<br>     | Editor<br>     |<br>     V<br>Text File (DV80)<br>     |<br>     | Assembler<br>     |<br>     V<br>Object file (DF80)   SAVE utility (DF80)<br>     |                    :<br>     | EA3 linking loader :<br>     |                    :<br>     V                    V<br>Program is executed in memory<br>     :<br>     : SAVE is called (optional)<br>     :<br>     V<br>Memory-image file (Program)<br></pre>
<h4>Source file format</h4>
<p>The format of the source file is the only one we are concerned with
for the moment being, since this is the file that you must write.
Fortunately,
its format is very simple: each line in the file contains an opcode
with
its operands, generally in the form:</p>
<pre>[label] Opcode [operand][,operand] [comments]<br>Spaces ^      ^                   ^</pre>
<p>The fields in [brakets] are optional. Note however that the number
of
operands is determined by the opcode and is therefore not optional for
a given opcode: some have no operands, some have one, some have two.
The
syntax is a little more relaxed for instructions to the assembler, and
some of these can take a variable number of operands.</p>
<p>Labels in the left margin are used to easily refer to a location in
your program, for instance to branch to it. There must be at least one
space between label and opcode, between opcode and operands, and
between
operands and comments (if any). If there are two operands, they should
be separated with a comma, not with spaces.</p>
<p>Comments are very important with assembly language, since it can be
quite difficult to figure out what a program is doing when reading the
source file. This even applies to your own programs: you'd be surprised
how difficult it is for you to understand what you wrote just a few
month
ago! Therefore, use comments a lot: leave messages for yourself.</p>
<p>If you need more room than just the end of the line, you can enter
lines
that contain only comment. Just make sure that such lines begin with a
* that will instruct the assembler to ignore them.</p>
<p>Example:</p>
<pre>*&nbsp;This is a comment line<br>MYTEST MOV  R1,R2    This is a sample assembly language line  </pre>
<h4><br>
Minimal assembly program</h4>
<p>So what's the smallest assembly program that you can write?
Something
like this:</p>
<pre>START  RT          return to caller<br>       END  START</pre>
<p><b><tt>RT</tt> </b>is not a real opcode, it's an assembly alias for
one of the most common return statement, which should actually be
written
<tt>B *R11</tt> This statement returns to the caller, in this case the
loader that will return control to you (hopefully).</p>
<p><b><tt>END&nbsp;</tt></b>is an instruction that tells the assembler
that the end of the file has been reached. An optional operand can also
be used to indicate the entry point of your program: in our case this
is
the label START.</p>
<p>If you don't specify an entry point, an EA5 loader will begin
execution
at the top of your program. An EA3 loader will wait for you to enter
the
name of a label where you want to start execution. So you can do this,
you must tell the assembler to include the label into the object file.
This is done as follows:</p>
<pre>       DEF  START<br>START  RT          return to caller<br>       END</pre>
<p>The <b><tt>DEF </tt></b>instruction makes one or more label
available
to the linker and/or the loader.</p>
<h2><br>
<a name="Registers"></a>CPU Registers</h2>
<p>Before we discuss assembly language further, I would like to
introduce
you briefly to the structure of the TMS9900 microprocessor (a.k.a. CPU
for "Central Processing Unit).. You'll find a more complete description
in <a href="tms9900.htm">here </a>in case you are interested.</p>
<p>First let's talk about registers. A register is nothing else than a
memory cell that is integrated inside the microprocessor. The advantage
is that it's much easier and faster for the microprocessor to access a
register than to access the external memory. The TMS9900 has 3 main
registers:</p>
<p><a href="#PC">The program counter<br>
</a><a href="#WS">The workspace pointer<br>
</a><a href="#ST">The status register</a></p>
<h4><br>
<a name="PC"></a>Program counter</h4>
<p>The Program Counter (PC) keeps trace of the currently executed
instruction.
This allows the TMS9900 to fetch the next instruction to be executed.
Some
instructions allow you to load a different value inside PC, thereby
performing
a "jump" or "branch" inside your program (the equivalent
of a Basic GOTO). The program counter is a 16-bit register that simply
contains the memory address of the current instruction.</p>
<h4><br>
<a name="ST"></a>Status register</h4>
<p>The Status register (ST) contains flag bits use by the TMS9900 to
make
decisions. Most operations affect one or the other of these bits. And
conversely,
some instructions behave differently according to the status of a given
bit (e.g. conditional jumps). The structure of the status register is
the
following:</p>
<table border="1">
  <tbody>
    <tr>
      <th>Bit</th>
      <td>0</td>
      <td>1</td>
      <td>2</td>
      <td>3</td>
      <td>4</td>
      <td>5</td>
      <td>6</td>
      <td>7 to 11</td>
      <td>12 to 15</td>
    </tr>
    <tr>
      <th>Use</th>
      <td>High</td>
      <td>GT</td>
      <td>Equ</td>
      <td>Carry</td>
      <td>Ovf</td>
      <td>Par</td>
      <td>Xop</td>
      <td>not used </td>
      <td>Interrupt mask</td>
    </tr>
  </tbody>
</table>
<p>The first bits deal with mathematical operations:</p>
<p><b>High </b>means logically higher than, for unsigned operations.
For
instance, you could use the compare opcode "C" to compare R0
and R1:</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre><tt>      LI  R0,&gt;0001     Loads number 1 into R0<br>      LI  R1,&gt;FFFF     Loads number 65535 (a.k.a. -1) into R1<br>      C   R1,R0        Compares R1 to R0</tt></pre>
      </td>
    </tr>
  </tbody>
</table>
<p>After the comparison instruction, the "High" bit will be set
to 1 since &gt;FFFF is logically higher than 1.</p>
<p><b>GT </b>(greater than) performs the same function, but consider
that
the operands contain signed values. By convention, &gt;FFFF means -1,
&gt;FFFE
means -2, &gt;FFFD means -3, ... and &gt;8000 means -32768.</p>
<p>In the above example, GT will be 0 since -1 is arithmetically
smaller
than 1.</p>
<p><b>Eq </b>means equal and is set by the comparison operation when
the
two operands contain equal values.</p>
<p>And now, let's mention a very usefull feature of the TMS9900: after
almost each operation that deals with numbers the processor will
aurtomatically
compare the result to zero and set the status bits accordingly. For
instance,
if you decrement R0 by 1:</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre><tt>       DEC  R0       </tt></pre>
      </td>
    </tr>
  </tbody>
</table>
<p>the content of the status register will reflect the result of the
comparison
of R0 (after it was decremented) with zero. If you were using R0 as a
countdown
counter, there is no need to use a "C" instruction to compare
it to zero: this was already done by the DEC instruction.</p>
<p><b>Carry </b>is used to indicate a carry over. It can be viewed as
a
17th bit, left of bit 0. For instance, if you do:</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre><tt>      LI  R0,&gt;0001     Load number 1 into R0<br>      LI  R1,&gt;FFFF     Load number 65535 (a.k.a. -1) into R1<br>      A   R1,R0        Add R1 to R0</tt></pre>
      </td>
    </tr>
  </tbody>
</table>
<p>The result will be &gt;10000, which is too big to fit in 16 bits. R0
will therefore contain &gt;0000 and the "Carry" bit will be set
to indicate that the value of R0 "wraped over".</p>
<p><b>Ovf </b>indicates an overflow during some operations. Mostly,
ovf
deals with the sign bit (i.e. bit 0). For instance, if you add two
positive
numbers and the result may be understood as a negative number, ovf will
be set:</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre><tt>      LI  R0,&gt;4000     Load number into R0<br>      LI  R1,&gt;4001     Load number into R1<br>      A   R1,R0        Add R1 to R0</tt></pre>
      </td>
    </tr>
  </tbody>
</table>
<p>The result of the addition (to be placed in R0) is &gt;8003, wich is
perfectly correct for unsigned values: 16384+16385 = 32769. However, if
we were to consider these numbers as signed, we would get: 16384+16385
= -32767. The TMS9900 sets ovf to warn us about a potential problem in
this case, as well as in similar situations.</p>
<p><b>Par </b>stands for parity. It is only used by a limited number
of
opcodes. The microprocessor checks all the bits involved in these
operations
and counts how many of them were "1". If the result is odd, the
Par bit will be set. This can serve as a transmission error control
mechanism
for instance, but is generally of little use to the average programmer.</p>
<p><b>Xop </b>is set during the execution of a <a href="#XOP">XOP</a>
instruction.
</p>
<p>The <b>interrupt masks</b> tells the TMS9900 upto which priority
level
it can accept interrupts. In the TI-99/4A console, all interrupts are
hardwired
at level 2. Therefore only two cases are of importance for us:</p>
<li>If the interrupt mask is 0 or 1, interrupts are not allowed</li>
<li>If the interrupt mask is 2 to 15, interrupts are allowed.</li>
<p>In case you wonder, an interrupt is a hardware-triggered event that
causes the TMS9900 to temporarely stop execution of the current program
and to execute another program instead: the interrupt service routine
(ISR).
Once the ISR is completed, the TMS9900 will (hopefully) resume
execution
of the program where is was interrupted.</p>
<h4><br>
<a name="WS"></a>Worskpace pointer</h4>
<p>Registers are also meant to be used by the programmer: since they
are
located on chip they are faster than external memory. Furthermore,
since
there is only a limited number of registers, they can be encoded within
the instruction number itself (cf the example above for NEG R0 and NEG
R1). By contrast, if we wanted to negate an address in the external
memory,
we wourld write:</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre><tt>     NEG  @&gt;2000   Negates word at address &gt;2000 </tt></pre>
      </td>
    </tr>
  </tbody>
</table>
<p>But now we need 16 bits to specify the address of the word to
negate,
obiously it cannot fit together with the opcode into a 16-bit
instruction
word! Therefore, this instruction will require an extra word and will
be
encoded as: &gt;0520 &gt;2000 (the &gt;0020 in &gt;0520 indicates that
there is an extra word in this instruction).</p>
<p>With instructions that deal with two operands (like the addition) it
may be necessary to have an extra word for each of them. Therefore a
TM9900
instruction can be 1, 2 or 3 words long.</p>
<p>Now how many registers are there for us to use inside the TMS9900?
Well,
none... or 16.... or as much as we want!</p>
<p>Let me explain that. Instead of placing registers inside the
microprocessor,
the TI designers decided that registers will be in the external memory.
The TMS9900 only contains a workspace pointer, i.e. a register that
contains
the address of 16 pseudo-registers in the external memory.</p>
<p>This kind of defeats the principle of a register: it will take as
much
time to access a register that to access a memory address... since
registers
are memory addresses. Well, not quite. We saw above that an instruction
requires an extra word to use an operand in the external memory. Thus,
by using a register we make the program shorter, and we also make it
faster:
we save the time that would be required to read that extra word.</p>
<p>In addition, if we change the value of the workspace pointer, we
automatically
start to work with a fresh set of 16 registers. If we change it back to
what it was before, we'll found our previous registers with their
original
content. This is very usefull for context switching, i.e. to switch
from
one task to another. This is what occurs during the execution of an
interrupt
for instance: the TMS9900 automatically switches to a workspace placed
at &gt;83C0 and "remembers" where was the workspace the main
program was using. This allows to return from the interrupt with an
undisturbed
set of registers.</p>
<p>You can also cause such a context switch programmatically, using
instructions
like BLWP (Branch and Load a new Workspace Pointer), LWPI (Load
Workspace
Pointer from Immediate value) and RTWP (ReTurn using old Workspace
Pointer).</p>
<h3><br>
<a name="Addressing modes"></a>Addressing modes</h3>
<p>If you followed the above, you will have now understood that a given
instruction address memory in two different ways: as a register (i.e.
on
offset with respect the the workspace pointer) or as an absolute
address.
These different ways are known as "addressing modes". There is
a total of eight addressing modes for the operands of the TMS9900
instructions,
but out of these three are reserved for sets of special instructions. </p>
<p><a href="#Immediate">Immediate operands</a>: e.g. <tt>LI R0,12<br>
</tt><a href="#register%20addressing">Register addressing</a>: e.g. <tt>CLR
R1<br>
</tt><a href="#Indirect%20register">Indirect register addressing</a>:
e.g.
<tt>CLR *R1<br>
</tt><a href="#auto-increment">Auto-incrementing addressing</a>: e.g. <tt>CLR
*R1+<br>
</tt><a href="#direct">Direct addressing</a>: e.g. <tt>CLR @&gt;2000<br>
</tt><a href="#indexed">Indexed addressing</a>: e.g. <tt>CLR
@&gt;2000(R1)<br>
</tt><a href="#PC%20relative%20adressing">PC relative addressing</a>:
e.g.
<tt>JMP $+4<br>
</tt><a href="#CRU%20addressing">CRU relative addressing</a>: e.g. <tt>SBO
0</tt></p>
<h4><br>
<a name="Immediate"></a>Immediate operands</h4>
<p>These only apply to a restricted set of instructions. An immediate
value
is a number that immediately follows the instruction in the program.
This
value is to be used as an operand.</p>
<p>We already encountered one of these: the <tt>LI </tt>instruction
that
appeared in many examples above:</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre><tt>      LI  R0,&gt;0001     Loads number 1 into R0</tt></pre>
      </td>
    </tr>
  </tbody>
</table>
<p>In machine language this corresponds to:<br>
&gt;0200 <br>
&gt;0001. </p>
<p>Where &gt;020x encodes the LI opcode, &gt;xxx0 encodes register 0
and
the extra word &gt;0001 encodes the immediate value.</p>
<p>The "immediate" opcodes are:<br>
<tt><b>LI </b>R1,123<b> </b></tt>(load immediate value)<br>
<tt><b>AI </b>R1,-12<b> </b></tt>(add immediate value)<br>
<tt><b>ANDI </b>R1,&gt;1FFF<b> </b></tt>(and immediate value)<br>
<tt><b>ORI </b>R1,&gt;8040<b> </b></tt>(or immediate value)<br>
<tt><b>CI </b>R1,25<b> </b></tt>(compare with immediate value)<br>
<tt><b>LWPI </b>&gt;83E0<b> </b></tt>(load worskpace pointer with
immediate
value)<br>
<tt><b>LIMI </b>2<b> </b></tt>(load interrupt mask with immediate
value)</p>
<p>As you can see, they all end with letter I (and no other opcode
does).
They are thus pretty easy to recognize and to remember.</p>
<p>Most have two operands. The first one must be a register (no
indirect,
no indexing, just a plain register addressing). LWPI and LIMI have only
one operand because the register is implicitly defined by the
instruction:
the Worspace pointer register and the Status register of the TMS9900,
respectively.</p>
<p>The second operand must be an immediate value: it's a requirement,
not
a choice. </p>
<p>By contrast, other opcodes generally have the choice between the 5
other
addressing modes. There are a few exceptions to this rule though: some
opcodes can only deal with registers for on apparent reason. That's
because
the TI designers ran out of numbers to encode all these possibilities
in
machine language.</p>
<h4><br>
<a name="register addressing"></a>Register addressing</h4>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre><tt>      NEG   R0    Negates the content of R0</tt></pre>
      </td>
    </tr>
  </tbody>
</table>
<p>This one is already an old friend: the operand is simply one of the
sixteen registers in the current workspace. They are abbreviated R0
through
R15. </p>
<p>Note that the "R" is optional with the TI assembler. In fact,
to use the "R" you must set a special option when launching the
assembler. I didn't know that when I learned assembly (using a hacked
assembler,
with no manual) and I therefore got the habit of not using the R. I had
a hard time remembering to add it while I was typing the examples for
these
pages...</p>
<h4><br>
<a name="Indirect register"></a>Indirect register addressing</h4>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre><tt>      NEG  *R1   Negates the content of the word pointed at by R1</tt></pre>
      </td>
    </tr>
  </tbody>
</table>
<p>Here the register is not the final target of the instruction.
Instead,
it contains the address of the target (i.e. it is a pointer to it).</p>
<p>In the above example, if R0 contains &gt;A123 the instruction will
result
in negating word at address &gt;A123.</p>
<p>This allow you to operate on different addresses according to the
situation,
even though the exact address could not be predicted by the time you
wrote
the program.</p>
<h4><br>
<a name="auto-increment"></a>Indirect auto-incrementing register
addressing</h4>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre><tt>      NEG  *R1+   Negates the content of the word pointed at by R1</tt></pre>
      </td>
    </tr>
  </tbody>
</table>
<p>These is almost exactly the same as the above, with one exception:
once
the instruction is completed, the content of R1 will be incremented (by
two in this case, because we are dealing with words).</p>
<p>That comes extremely handy for copy loops for instance:</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre><tt>       LI   R1,&gt;2000      We want to copy this memory area<br>       LI   R2,&gt;A000      Into that one<br>       LI   R0,&gt;1000      That's the number of bytes to copy </tt></pre>
      <pre><tt>L1     MOV  *R1+,*R2+     Copy one word<br>       DECT R0            We decrement by two because 1 word is 2 bytes <br>       JGT  L1            DECT automatically compares R0 with 0.<br>*                         If it's greater we jump to L1, other wise we come here </tt></pre>
      </td>
    </tr>
  </tbody>
</table>
<p>Do you see how it works? </p>
<ul>
  <li>The MOV instruction copies the content of the address to be found
in
R1 (in this case &gt;2000) to the address to be found in R2 (in this
case
&gt;A000). Then is automatically changes R1 to &gt;2002 and R2 to
&gt;A002.</li>
  <li>The next execution of the loop will copy &gt;2002 to &gt;A002 and
change
R1 to &gt;2004 and R2 to &gt;A004.</li>
  <li>The next one copies &gt;2004 to &gt;A004, etc</li>
</ul>
<h4><br>
<a name="direct"></a>Direct addressing</h4>
<p>A.k.a. Symbolic addressing</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre><tt>      NEG  @&gt;2000   Negates the word at address &gt;2000 </tt></pre>
      </td>
    </tr>
  </tbody>
</table>
<p>That one is easy to understand: you just use the memory address of
the
word you want to target. Optionally, you could designate this word with
a label, hence the name "symbolic":</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre><tt>      NEG  @COUNTER    Assuming you define COUNTER as &gt;2000 </tt></pre>
      </td>
    </tr>
  </tbody>
</table>
<p>Finally, most assembly will let you enter arithmetic expressions
like:<br>
</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre><tt>      NEG  @COUNTER+4    Negates the word at address COUNTER + 4</tt></pre>
      </td>
    </tr>
  </tbody>
</table>
<p>The assembler calculates the value of COUNTER+4 (in our case
&gt;2004)
at assembly time and encodes the instruction as <tt>NEG @&gt;2004. </tt>One
more example of the usefull things an assembler can do for you.</p>
<h4><br>
<a name="indexed"></a>Indexed addressing</h4>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre><tt>      NEG  @&gt;2000(R1)  Negates the word at address: &gt;2000 plus the value of R1 </tt></pre>
      </td>
    </tr>
  </tbody>
</table>
<p>This one kind of combines <tt>@&gt;2000</tt> with <tt>*R1</tt>:
the
target address is calculated by adding the direct (a.k.a. symbolic)
address
and the content of R1.</p>
<p>For instance, if R1 contains 2, the above instruction negates
&gt;2002.<br>
If R1 contains &gt;0548, it negates &gt;2548 etc.</p>
<p>Note that R0 cannot be used as an index (this is because <tt>NEG
@&gt;2000</tt>
is in fact encoded as <tt>NEG @&gt;2000(R0)</tt>, the TMS9900 knows
that
in this case it must not use R0).</p>
<p>This adressing mode is usefull in two situations:</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre>      LI   R1,8           Loads the number 8 into R1<br><tt>      NEG  @TABLE(R1)     Negates entry 8 in the table</tt></pre>
      </td>
    </tr>
  </tbody>
</table>
<p>In this case, the symbolic part of the operand refers to a table of
values you placed in memory. R1 represents an index inside that table
(hence
the name of this addressing mode). Of course, we could have written <tt>NEG
@TABLE+8</tt>, but in the above example, the content of R1 can vary.
Therefore,
the NEG instruction can apply to one or the other word in the table,
according
to the value of R1.</p>
<p>The second situation is the "mirror image" of the first one:</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre><tt>      LI    R1,LIST     Makes R1 a pointer to LIST<br>      NEG   @8(R1)      Negates entry 8 in the list</tt></pre>
      </td>
    </tr>
  </tbody>
</table>
<p>It does the same job as the above: which one you want to use is
mainly
a matter of taste. Sometimes you prefer to think "I'm targetting the
8th entry in the table" and sometimes you like better "I'm dealing
with the 8th byte after the current position in the list".</p>
<p>There are two more addressing modes that are only used by well
defined
sets of opcodes (just like immediate operands are).</p>
<h4><br>
<a name="PC relative adressing"></a><a name="JUMPs"></a>PC relative
addressing</h4>
<p>This one is used exclusively by jump instructions:<br>
<b><tt>JMP </tt></b>(unconditional jump)<br>
<b><tt>JEQ </tt></b>(Jump if Equal, i.e. if the Equ bit is 1 in the
status
register)<br>
<b><tt>JNE </tt></b>(Jump if Not Equal, i.e. if the Equ bit is 0)<br>
<b><tt>JGT </tt></b>(Jump if Greater Than)<br>
<b><tt>JH</tt></b> (Jump if Higher)<br>
<b><tt>JHE </tt></b>(Jump if Higher or Equal)<br>
<b><tt>JL </tt></b>(Jump if Lower, i.e. if the "High"and the
"Equ" bits are 0)<br>
<b><tt>JLE </tt></b>(Jump is Lower or Equal)<br>
<b><tt>JLT </tt></b>(Jump if Less Than, i.e. if the "GT" and
the "Equ" bits are 0)<br>
<b><tt>JNC </tt></b>(Jump if No Carry)<br>
<b><tt>JOC </tt></b>(Jump On Carry)<br>
<b><tt>JNO </tt></b>(Jump is No Overflow)<br>
<b><tt>JOP </tt></b>(Jump on Odd Parity, i.e. if the "Par" bit
is set)</p>
<p>Again these are easy to recognise: they all begin with "J"
(no other opcode does).</p>
<p>Youn will note however that there are some missing: what about <tt>JLTE
</tt>and <tt>JGTE</tt>? And why isn't it a "jump if overflow"
and a "jump on even parity". Again that's because the machine
language is running out of valid numbers.</p>
<p>But the missing one are the logical complement of existing
instructions:
Therefore, to perform the equivalent of "Jump if Less Than of Equal"
you could invert the comparison and use "<tt>JGT</tt>":</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre><tt>      C    R1,R4     Compare R1 to R4<br>      JGTE SK1       Error: "illegal opcode" </tt></pre>
      <pre><tt>      C    R4,R1     Do the inverse comparison <br>      JLT  SK1       Now this is gonna work</tt></pre>
      </td>
    </tr>
  </tbody>
</table>
<p>Similarly, you could compensate for a defficient "jump if overflow"
by changing the structure of your program:<br>
</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre><tt>       A    R1,R4    Add R1 to R4<br>       JIO  SK1      Jump if overflow? Does not exist!<br>       MOV  R4,R2    Continue if no overflow<br>       ...<br>SK1    NEG  R1       Do something if overflow occured</tt></pre>
      <pre><tt>       A    R1,R4    Let's try again<br>       JNO  SK1      Jump if no overflow<br>       NEG  R1       React to overflow here<br>       ...<br>SK1    MOV  R4,R2    And continue here if no overflow</tt></pre>
      </td>
    </tr>
  </tbody>
</table>
<p>The main advantage of jump instructions, is that they can be encoded
together with the opcode. How is this possible? Didn't I just
mentionned
that a memory address uses up 16 bits and therefore always requires an
extra word in the program?</p>
<p>Yes, but you see jump to not use memory addresses. Instead they jump
to a given distance from the current instruction: plus or minus 127
words.
This allows to encode all jump values with a single byte and leaves the
other 8 bits for the opcode. BUT it means that we cannot jump
everywhere
in the program: the destination address must be within the 127 words
limit
(actually it's 128 words forwards and 127 backwards). Here again, the
assembler
wil calculate this for you and issue an error message if the jump
cannot
be encoded. This "out of range" message is one of the most frequent
you will encounter...</p>
<p>There are two ways to specify a jump in assembly. First you can type
the displacement yourself:</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre>      C    R1,R0    Compare R1 to R0<br><tt>      JLT  $+4      Jump 4 bytes down if R1 is less than R0 (signed) <br>      JMP  $-120    Jump 120 bytes up otherwise (replaces a JGTE )</tt></pre>
      </td>
    </tr>
  </tbody>
</table>
<p>The $ sign stands for "current value of the program counter".
The assemble then knows that the offset you specified is relative to
the
current instruction. (FYI: in machine language jumps are WORDS relative
to the NEXT instruction: therefore a JMP $+4 is encoded as &gt;1001,
not
as &gt;1004. But the assembler takes care of this for you).</p>
<p>In the above example, it's relatively easy to figure that <tt>JLT
$+4</tt>
jumps over the <tt>JMP</tt>. But who wants to count 120 bytes upwards
to
figure out where the <tt>JMP </tt>is going to land?</p>
<p>Therefore, the assembler lets you use a label to specify the
destination.
The value of this label is most simple defined by placing it in the
left
margin of the target instruction: the assembler automatically assigns
the
current value of the program counter (i.e. the memory location of the
opcode)
to such labels.</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre><tt>      JNE  OK         Perform some kind of test <br>      JLT  UHOH       And another one here<br>      ...             Continue here if both are negative<br>OK    MOV  R1,R2      Here if first test hit<br>      ...<br>UHOH  NEG  @&gt;2000     And here if second jump taken</tt></pre>
      </td>
    </tr>
  </tbody>
</table>
<p>Note that contrarily to braching instructions, you must not include
the @ sign before a label in the case of a jump (as opposed to <tt>B
@OK</tt>).
This is usefull to remind you that you are restricted to a limited
range
of motion.</p>
<h4><br>
<a name="CRU addressing"></a>CRU relative addressing</h4>
<p>The CRU (Communication Register Unit) is a special hardware trick
that
allows the TMS9900 to communicate with pieces of equipment without
using
the data bus. Conceptually, it could be viewed as a set of 2048 wires
linking
the microprocessor to peripherals (in fact it uses only three lines,
plus
the address bus, but that's not the point).</p>
<p>You can also view it as a set of 2048 bits, one per each "wire".
By reading a bit you can test the status of a wire, by writing to a bit
you can change the status of a wire. Provided of course that the
peripheral
in question is designed to allow these operations: there could be
read-only
bits, write-only bits and not-used bits!</p>
<p>There are five CRU operations:</p>
<p><b><tt>TB </tt></b>(Test Bit: transfer the bit into the Equ bit of
the
status register)<br>
<b><tt>SBO </tt></b>(Set Bit to One)<br>
<b><tt>SBZ </tt></b>(Set Bit to Zero)<br>
<b><tt>LDCR </tt></b>(Load CRU: allows to modify upto 16 bits at a
time)<br>
<b><tt>STCR </tt></b>(Store CRU: allows to read upto 16 bits at a time)</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre><tt>      LI   R12,&gt;1300     CRU base of the RS232 card  <br>      SBO  7             Turn light on<br>      TB   7             Read it back<br>      JEQ  OK            Jump if bit is 1 (not zero)</tt></pre>
      </td>
    </tr>
  </tbody>
</table>
<p>Note that TB is somewhat missleading: JEQ jumps it the bit is 1 and
JNE if the bit is zero. That's because the bit is copied in the Equ bit
(that normally stands for "equals zero" in automatic comparisons).</p>
<p>So what's the use of the <tt>LI R12,&gt;1300</tt> instruction?
Well,
instead of numbering the bits from zero, the TMS9900 numbers them from
the value found in R12, divided by two (because the last addess line
does
not exist on a word-oriented microprocessor, we cannot encode uneven
addresses).</p>
<p>That's usefull when dealing with peripherals: each card is assigned
a chunk of 128 bits at addresses starting at &gt;1000, &gt;1100,
&gt;1200,
etc upto &gt;1F00 (addresses &gt;0000 to &gt;0FFF are internal to the
console).
If you want to turn on the disk controller card, whose CRU address is
&gt;1100
you may do:<br>
</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre><tt>     LI    R12,&gt;0000<br>     SBO   &gt;880         That's &gt;1100 divided by two </tt></pre>
      </td>
    </tr>
  </tbody>
</table>
<p>But that's kinda hard to remember right.</p>
<p>Now you could do the same with:</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre><tt>      LI   R12,&gt;1100<br>      SBO  0            By convention, the first bit of a card turns it on </tt></pre>
      </td>
    </tr>
  </tbody>
</table>
<p>Which is somewhat easier to use: the bits are relative to the card,
not to the whole CRU address space</p>
<p>And when it comes to LDCR and STCR, you don't even have a choice:
you
must use the second style since you can't specify the starting bit in
the
instruction (it's always zero)</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre><tt>      LI   R12,&gt;1102<br>      LDCR R1,3          Load 3 CRU bits from R1 into the disk controller card</tt></pre>
      </td>
    </tr>
  </tbody>
</table>
<p>Because &gt;1102 accesses bit 1 of the disk controller card
(remember:
the content of R12 is the bit number times 2), the above example
affects
the values of bit 1, 2, and 3 of the controller card.</p>
<p>Note that with LDCR and STCR the only valid addressing mode is
register
(that's one of those case where numbers were missing...). The bits are
always taken/stored from the right to the left of the register. If the
operation deals with 1 to 8 bits, only the left byte of the register
will
be used: a byte-oriented operation is assumed. With 9 to 15 bits, the
whole
register is accessed.</p>
<p>For a more complere explanation of the CRU, see <a href="cru.htm">here</a>.</p>
<h2><br>
<a name="bytes vs words"></a>Bytes versus words</h2>
<p>The TMS9900, and the TI-99/4A that is built around it, is a
word-oriented,
byte-addressable processor.</p>
<p>What this means is that the processor mainly deals with 16-bit
words.
But that these words are stored in a memory that is addressed as bytes.
It may seem silly, but that's what happened in most computer systems:
even
a 32-bit Pentium is still using a byte-addressable memory.</p>
<p>With 16 bits we can encode numbers from 0 to 65535, which means that
the size of the memory has to be at most 64K bytes if we want to be
able
to deal with an address as a single value. The memory could be twice as
large is it were word-addressable, but that's not the case.</p>
<p>For the processor, it means that the least significant address line
(A15 in the TI numbering convention) is perfectly useless: it just
represents
the byte inside the word. Therefore, the TMS9900 has only 15 address
lines:
A0 through A14.</p>
<p>Nevertheless, the CPU can deal with byte values if necessary. It
just
uses an internal trick: when you write a value to a byte, the processor
reads the whole word, modifies the byte you were accessing, and writes
the word back. There is a bunch of opcodes that allow such
byte-oriented
operations: AB, SB, MOVB, CB, SOCB, SZCB and in some cases LDCR and
STCR.
</p>
<p>When the operand is a register, the only byte that you can access in
this manner is the leftmost one, the most significant. That's the byte
stored in memory at an uneven address. When using direct addressing,
you
can specify an odd or an even address indifferently for byte operations.</p>
<p>On the other hand word operations always require an even address,
since
the 16-bit value is transfered as such on the data bus (and the address
is always even since A15 is missing). </p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre><tt>      LI   R1,&gt;0104     Loads &gt;0104 into R1<br>      S    R1,@&gt;2000    Substracts &gt;0104 from &gt;2000-2001 <br>      S    R1,@&gt;2001    Ditto! It does not affect &gt;2002   !!!<br>      SB   R1,@&gt;2000    Substract &gt;01 from &gt;2000. &gt;2001 unchanged<br>      SB   R1,@&gt;2001    Substracts &gt;01 from &gt;2001. &gt;2000 unchanged</tt></pre>
      </td>
    </tr>
  </tbody>
</table>
<p>Just remember: for word operations always use an even address.</p>
<h4><br>
Data bus multiplexing</h4>
<p>For some mysterious reason, the TI-99/4A designers decided to
cripple
their machine by using an 8-bit data bus to access most peripherals.
Only
the console ROMs and the 256 bytes of console RAM known as the
"scratch-pad"
are accessed via a 16-bit data bus.</p>
<p>For the rest of the memory, a special circuitery in the console
multiplexes
the data bus and passes it as twice 8 bits. This requires the creation
of an extra address line, A15, which indicates which byte is currently
accessed. We therefore end up with a 16-bit address bus. Note that A15
is multiplexed with the CRU data output line, but this is not a problem
during memory operations since this CRU line will be inactive.</p>
<p>The big drawback is that memory access is now twice slower, and the
multiplexer circuit has to put the TMS9900 on hold until the transfer
is
completed!</p>
<h2><br>
<a name="opcodes"></a>Opcodes</h2>
<p><a href="#branching">Branching opcodes<br>
</a><a href="#Arithmetic%20opcodes">Arithmetic opcodes<br>
</a><a href="#logic%20opcodes">Bitwise logic opcodes<br>
</a><a href="#Shift%20opcodes">Shift opcodes<br>
</a><a href="#CRU%20opcodes">CRU opcodes<br>
</a><a href="#Various%20opcodes">Various opcodes<br>
</a><a href="#Forbidden%20opcodes">Forbidden opcodes</a></p>
<table border="1">
  <tbody>
    <tr>
      <th>Opcode</th>
      <th>Value</th>
      <th><a href="#Encoding%20format">Fmt </a></th>
      <th>Operands</th>
      <th><a href="#ST">Status</a></th>
    </tr>
    <tr>
      <td><a href="#A">A</a></td>
      <td>&gt;A000</td>
      <td>I</td>
      <td><i>source,dest</i> </td>
      <td>HGECO</td>
    </tr>
    <tr>
      <td><a href="#AB">AB</a></td>
      <td>&gt;B000</td>
      <td>I</td>
      <td><i>source,dest</i></td>
      <td>HGECOP</td>
    </tr>
    <tr>
      <td><a href="#ABS">ABS</a></td>
      <td>&gt;0740</td>
      <td>VI</td>
      <td><i>dest</i></td>
      <td>HGECO</td>
    </tr>
    <tr>
      <td><a href="#AI">AI</a></td>
      <td>&gt;0220</td>
      <td>VIII</td>
      <td><i>reg,immed</i></td>
      <td>HGECO</td>
    </tr>
    <tr>
      <td><a href="#ANDI">ANDI</a></td>
      <td>&gt;0240</td>
      <td>VIII</td>
      <td><i>reg,immed</i></td>
      <td>HGE</td>
    </tr>
    <tr>
      <td><a href="#B">B</a></td>
      <td>&gt;0440</td>
      <td>VI</td>
      <td><i>dest</i></td>
      <td>-</td>
    </tr>
    <tr>
      <td><a href="#BL">BL</a></td>
      <td>&gt;0680</td>
      <td>VI</td>
      <td><i>dest</i></td>
      <td>-</td>
    </tr>
    <tr>
      <td><a href="#BLWP">BLWP</a></td>
      <td>&gt;0400</td>
      <td>VI</td>
      <td><i>dest</i></td>
      <td>-</td>
    </tr>
    <tr>
      <td><a href="#C">C</a></td>
      <td>&gt;8000</td>
      <td>I</td>
      <td><i>source,dest</i></td>
      <td>HGE</td>
    </tr>
    <tr>
      <td><a href="#CB">CB</a></td>
      <td>&gt;9000</td>
      <td>I</td>
      <td><i>source,dest</i></td>
      <td>HGE P</td>
    </tr>
    <tr>
      <td><a href="#CI">CI</a></td>
      <td>&gt;0280</td>
      <td>VIII</td>
      <td><i>reg,immed</i></td>
      <td>HGE</td>
    </tr>
    <tr>
      <td><a href="#Forbidden%20opcodes">CKOF</a></td>
      <td>&gt;03C0</td>
      <td>VII</td>
      <td>-</td>
      <td>-</td>
    </tr>
    <tr>
      <td><a href="#Forbidden%20opcodes">CKON</a></td>
      <td>&gt;03A0</td>
      <td>VII</td>
      <td>-</td>
      <td>-</td>
    </tr>
    <tr>
      <td><a href="#CLR">CLR</a></td>
      <td>&gt;04C0</td>
      <td>VI</td>
      <td><i>dest</i></td>
      <td>-</td>
    </tr>
    <tr>
      <td><a href="#COC">COC</a></td>
      <td>&gt;2000</td>
      <td>III</td>
      <td><i>source,reg</i></td>
      <td>E</td>
    </tr>
    <tr>
      <td><a href="#CZC">CZC</a></td>
      <td>&gt;2400</td>
      <td>III</td>
      <td><i>source,reg</i></td>
      <td>E</td>
    </tr>
    <tr>
      <td><a href="#DEC">DEC</a></td>
      <td>&gt;0600</td>
      <td>VI</td>
      <td><i>dest</i></td>
      <td>HGECO</td>
    </tr>
    <tr>
      <td><a href="#DECT">DECT</a></td>
      <td>&gt;0640</td>
      <td>VI</td>
      <td><i>dest</i></td>
      <td>HGECO</td>
    </tr>
    <tr>
      <td><a href="#DIV">DIV</a></td>
      <td>&gt;3C00</td>
      <td>IX</td>
      <td><i>source,reg2</i></td>
      <td>O</td>
    </tr>
    <tr>
      <td><a href="#Forbidden%20opcodes">IDLE</a></td>
      <td>&gt;0340</td>
      <td>VII</td>
      <td>-</td>
      <td>-</td>
    </tr>
    <tr>
      <td><a href="#INC">INC</a></td>
      <td>&gt;0580</td>
      <td>VI</td>
      <td><i>dest</i></td>
      <td>HGECO</td>
    </tr>
    <tr>
      <td><a href="#INCT">INCT</a></td>
      <td>&gt;05C0</td>
      <td>VI</td>
      <td><i>dest</i></td>
      <td>HGECO</td>
    </tr>
    <tr>
      <td><a href="#INV">INV</a></td>
      <td>&gt;0540</td>
      <td>VI</td>
      <td><i>dest</i></td>
      <td>HGE</td>
    </tr>
    <tr>
      <td><a href="#JUMPs">JEQ</a></td>
      <td>&gt;1300</td>
      <td>II</td>
      <td><i>PC-rel</i></td>
      <td>E=1</td>
    </tr>
    <tr>
      <td><a href="#JUMPs">JGT</a></td>
      <td>&gt;1500</td>
      <td>II</td>
      <td><i>PC-rel</i></td>
      <td>G=1</td>
    </tr>
    <tr>
      <td><a href="#JUMPs">JH</a></td>
      <td>&gt;1B00</td>
      <td>II</td>
      <td><i>PC-rel</i></td>
      <td>H=1 E=0</td>
    </tr>
    <tr>
      <td><a href="#JUMPs">JHE</a></td>
      <td>&gt;1400</td>
      <td>II</td>
      <td><i>PC-rel</i></td>
      <td>H=1 E=1</td>
    </tr>
    <tr>
      <td><a href="#JUMPs">JL</a></td>
      <td>&gt;1A00</td>
      <td>II</td>
      <td><i>PC-rel</i></td>
      <td>H=0 E=0</td>
    </tr>
    <tr>
      <td><a href="#JUMPs">JLE</a></td>
      <td>&gt;1200</td>
      <td>II</td>
      <td><i>PC-rel</i></td>
      <td>H=0 E=1</td>
    </tr>
    <tr>
      <td><a href="#JUMPs">JLT</a></td>
      <td>&gt;1100</td>
      <td>II</td>
      <td><i>PC-rel</i></td>
      <td>G=0 E=0</td>
    </tr>
    <tr>
      <td><a href="#JUMPs">JMP</a></td>
      <td>&gt;1000</td>
      <td>II</td>
      <td><i>PC-rel</i></td>
      <td>Always</td>
    </tr>
    <tr>
      <td><a href="#JUMPs">JNC</a></td>
      <td>&gt;1700</td>
      <td>II</td>
      <td><i>PC-rel</i></td>
      <td>C=0</td>
    </tr>
    <tr>
      <td><a href="#JUMPs">JNE</a></td>
      <td>&gt;1600</td>
      <td>II</td>
      <td><i>PC-rel</i></td>
      <td>E=0</td>
    </tr>
    <tr>
      <td><a href="#JUMPs">JNO</a></td>
      <td>&gt;1900</td>
      <td>II</td>
      <td><i>PC-rel</i></td>
      <td>O=0</td>
    </tr>
    <tr>
      <td><a href="#JUMPs">JOC</a></td>
      <td>&gt;1800</td>
      <td>II</td>
      <td><i>PC-rel</i></td>
      <td>C=1</td>
    </tr>
    <tr>
      <td><a href="#JUMPs">JOP</a></td>
      <td>&gt;1C00</td>
      <td>II</td>
      <td><i>PC-rel</i></td>
      <td>P=1</td>
    </tr>
    <tr>
      <td><a href="#LDCR">LDCR</a></td>
      <td>&gt;3000</td>
      <td>IV</td>
      <td><i>source,nbits</i></td>
      <td>HGECOP</td>
    </tr>
    <tr>
      <td><a href="#LI">LI</a></td>
      <td>&gt;2000</td>
      <td>VIII</td>
      <td><i>reg,immed</i></td>
      <td>HGE</td>
    </tr>
    <tr>
      <td><a href="#LIMI">LIMI</a></td>
      <td>&gt;0300</td>
      <td>VIII</td>
      <td><i>immed</i></td>
      <td>-</td>
    </tr>
    <tr>
      <td><a href="#Forbidden%20opcodes">LREX</a></td>
      <td>&gt;03E0</td>
      <td>VII</td>
      <td>-</td>
      <td>-</td>
    </tr>
    <tr>
      <td><a href="#LWPI">LWPI</a></td>
      <td>&gt;02E0</td>
      <td>VIII</td>
      <td><i>immed</i></td>
      <td>-</td>
    </tr>
    <tr>
      <td><a href="#MOV">MOV</a></td>
      <td>&gt;C000</td>
      <td>I</td>
      <td><i>source,dest</i></td>
      <td>HGE</td>
    </tr>
    <tr>
      <td><a href="#MOVB">MOVB</a></td>
      <td>&gt;D000</td>
      <td>I</td>
      <td><i>source,dest</i></td>
      <td>HGE P</td>
    </tr>
    <tr>
      <td><a href="#MPY">MPY</a></td>
      <td>&gt;3800</td>
      <td>IX</td>
      <td><i>source,reg2</i></td>
      <td>-</td>
    </tr>
    <tr>
      <td><a href="#NEG">NEG</a></td>
      <td>&gt;0500</td>
      <td>VI</td>
      <td><i>dest</i></td>
      <td>HGECO</td>
    </tr>
    <tr>
      <td><a href="#ORI">ORI</a></td>
      <td>&gt;0260</td>
      <td>VIII</td>
      <td><i>reg,immed</i></td>
      <td>HGE</td>
    </tr>
    <tr>
      <td><a href="#Forbidden%20opcodes">RSET</a></td>
      <td>&gt;0360</td>
      <td>VII</td>
      <td>-</td>
      <td>-</td>
    </tr>
    <tr>
      <td><a href="#RTWP">RTWP</a></td>
      <td>&gt;0380</td>
      <td>VII</td>
      <td>-</td>
      <td>All</td>
    </tr>
    <tr>
      <td><a href="#S">S</a></td>
      <td>&gt;6000</td>
      <td>I</td>
      <td><i>source,dest</i></td>
      <td>HGECO</td>
    </tr>
    <tr>
      <td><a href="#SB">SB</a></td>
      <td>&gt;7000</td>
      <td>I</td>
      <td><i>source,dest</i></td>
      <td>HGECOP</td>
    </tr>
    <tr>
      <td><a href="#SBO">SBO</a></td>
      <td>&gt;1D00</td>
      <td>II</td>
      <td><i>bit</i></td>
      <td>-</td>
    </tr>
    <tr>
      <td><a href="#SBZ">SBZ</a></td>
      <td>&gt;1E00</td>
      <td>II</td>
      <td><i>bit</i></td>
      <td>-</td>
    </tr>
    <tr>
      <td><a href="#SETO">SETO</a></td>
      <td>&gt;0700</td>
      <td>VI</td>
      <td><i>dest</i></td>
      <td>-</td>
    </tr>
    <tr>
      <td><a href="#SLA">SLA</a></td>
      <td>&gt;0A00</td>
      <td>V</td>
      <td><i>reg,count</i></td>
      <td>HGECO</td>
    </tr>
    <tr>
      <td><a href="#SOC">SOC</a></td>
      <td>&gt;E000</td>
      <td>I</td>
      <td><i>source,dest</i></td>
      <td>HGE</td>
    </tr>
    <tr>
      <td><a href="#SOCB">SOCB</a></td>
      <td>&gt;F000</td>
      <td>I</td>
      <td><i>source,dest</i></td>
      <td>HGEC P</td>
    </tr>
    <tr>
      <td><a href="#SRA">SRA</a></td>
      <td>&gt;0800</td>
      <td>V</td>
      <td><i>reg,count</i></td>
      <td>HGEC</td>
    </tr>
    <tr>
      <td><a href="#SRC">SRC</a></td>
      <td>&gt;0B00</td>
      <td>V</td>
      <td><i>reg,count</i></td>
      <td>HGEC</td>
    </tr>
    <tr>
      <td><a href="#SRL">SRL</a></td>
      <td>&gt;0900</td>
      <td>V</td>
      <td><i>reg,count</i></td>
      <td>HGECO</td>
    </tr>
    <tr>
      <td><a href="#STCR">STCR</a></td>
      <td>&gt;3400</td>
      <td>IV</td>
      <td><i>dest,nbits</i></td>
      <td>HGE P</td>
    </tr>
    <tr>
      <td><a href="#STST">STST</a></td>
      <td>&gt;02C0</td>
      <td>VIII</td>
      <td><i>reg</i></td>
      <td>-</td>
    </tr>
    <tr>
      <td><a href="#STWP">STWP</a></td>
      <td>&gt;02A0</td>
      <td>VIII</td>
      <td><i>reg</i></td>
      <td>-</td>
    </tr>
    <tr>
      <td><a href="#SWPB">SWPB</a></td>
      <td>&gt;06C0</td>
      <td>VI</td>
      <td><i>dest</i></td>
      <td>-</td>
    </tr>
    <tr>
      <td><a href="#SZC">SZC</a></td>
      <td>&gt;4000</td>
      <td>I</td>
      <td><i>source,dest</i></td>
      <td>HGE</td>
    </tr>
    <tr>
      <td><a href="#SZCB">SZCB</a></td>
      <td>&gt;5000</td>
      <td>I</td>
      <td><i>source,dest</i></td>
      <td>HGE P</td>
    </tr>
    <tr>
      <td><a href="#TB">TB</a></td>
      <td>&gt;1F00</td>
      <td>II</td>
      <td><i>bit</i></td>
      <td>E</td>
    </tr>
    <tr>
      <td><a href="#X">X </a></td>
      <td>&gt;0480</td>
      <td>VI</td>
      <td><i>dest</i></td>
      <td>depends</td>
    </tr>
    <tr>
      <td><a href="#XOP">XOP</a></td>
      <td>&gt;2C00</td>
      <td>IX</td>
      <td><i>source,xop#</i></td>
      <td>X</td>
    </tr>
    <tr>
      <td><a href="#XOR">XOR</a></td>
      <td>&gt;2800</td>
      <td>III</td>
      <td><i>source,reg</i></td>
      <td>HGE</td>
    </tr>
    <tr>
      <td>Illegal</td>
      <td colspan="4">&gt;0000-01FF, &gt;0320-033F, <br>
&gt;0780-07FF,&gt;0C00-0FFF</td>
      <td><br>
      </td>
      <td><br>
      </td>
      <td><br>
      </td>
    </tr>
  </tbody>
</table>
<h3><a name="branching"></a>Branching opcodes</h3>
<p>These opcodes allow you to control the flow of your program, by
jumping
from a point to another, possibly remembering where to come back.</p>
<h4>Jxx <i>offset</i></h4>
<p>We already discussed the <a href="#PC%20relative%20adressing">jump </a>opcodes.
They are very usefull since they are conditional: your program can make
decisions and follow one or the other path of execution according to
the
value of a given status bit. </p>
<h4><br>
<a name="B"></a>B <i>dest</i></h4>
<p>The first one is very easy to understand: B just loads the value of
the destination operand into the program counter register of the
TMS9900.
As a result, the program execution continues from that address. Note
that
contrarily to jumps there is no range limitation for B: the whole 64K
range
is within reach. This is because the address is passed as an extra word
after the opcode.</p>
<p>Status bits affected: none</p>
<h4><br>
<a name="BL"></a>BL <i>dest</i></h4>
<p>Branch-and-Link does exactly the same thing, except that it
remembers
where it came from: the address of the next instruction (the one that
would
be executed of the branch were not taken) is placed in register R11.
Then
the program execution continues from the specifed address: in this case
it is marked by a label called "THERE".</p>
<p>Status bits affected: none</p>
<p>How to return from such a branch? Very easy: just use a B
instruction
with an R11 addressed as an indirect operand. Like that:</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre><tt>      B    *R11    Which can also be abbreviated as:<br>      RT </tt></pre>
      </td>
    </tr>
  </tbody>
</table>
<p>Here we are just telling the TMS9900: branch at the address that you
will find in R11. Which happens to be the return address, since BL
automatically
placed it in here.</p>
<p>Of course, you should carefully preserve this return address. If you
plan to use R11, make sure you first transfer its content into another
register or memory location. A very common mistake is to place another
BL within a function called with a BL: the new return point will
overwrite
the old one.</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre><tt>      BL    @HERE       Branch at "HERE", place address "BACK" into R11<br>BACK  NEG   R0</tt></pre>
      <pre>HERE  BL    @THERE      Incorrect example: branch at "THERE" and place "DONE" into R11 <br>DONE  ABS   R0<br>      B     *R11        This returns at "DONE" since its now the value in R11<br><br>THERE B     *R11        This returns at "DONE"</pre>
      <pre>* Now here is the correct example<br><tt>      BL    @HERE       Branch at "HERE", place address "BACK" into R11<br>BACK  NEG   R0</tt></pre>
      <pre>HERE  MOV   R11,R10     Save return point<br>      BL    @THERE      Branch at "THERE" and place "DONE" into R11 <br>DONE  ABS   R0<br>      B     *R10        This returns at "BACK" since its the value in R10<br><br>THERE B     *R11        This returns at "DONE" since its the value in R11    <br></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4><br>
<a name="BLWP"></a>BLWP <i>dest</i></h4>
<p>Branch-and-Load-Workspace-Pointer is slightly trickier: here we want
to branch, but also to change the workspace. To be able to return to
the
calling point, we must not only remember the return address (i.e. the
content
of the PC register), but also the location of the old workspace (i.e.
the
content of the WR register). And since we are at it, we may also record
the value of the status register. This way, when we come back, we can
restore
the situation just like is is now.</p>
<p>You may think that BLWP is called with two operands, one for the
address
to branch at, the other for the new workspace. If that's the case, you
came close but no cigar! BLWP has only one operand, a pointer: it
contains
the address of a pair of words that contain the address to branch at
and
the new workspace. It is more flexible this way since you only have to
know one value (the pointer) to perform the branch.</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre><tt>      BLWP  @WHERE</tt></pre>
      <pre>WHERE DATA  &gt;8300       New workspace to be used <br>      DATA  HERE        Address to branch at</pre>
      <pre>HERE  MOV   R0,R1       The BLWP branches here </pre>
      </td>
    </tr>
  </tbody>
</table>
<p>So where are the three values we wanted to remember upon branching?
The pointer to the old worskpace is automatically placed into R13, the
return address (the instruction that follows the <tt>BLWP</tt>) into
R14,
and the current value of the status register into R15.</p>
<p>Here also, we should be carefull not to overwrite them with our
data.
However, unlike BL, there is no risk of erasing them with a second <tt>BLWP</tt>,
since that one will save its return values into R13-R15 of the NEW
workspace.
That's a very neat feature: it means that <tt>BLWPs </tt>can be
nested
as deep as we want! The drawback is that this operation is fairly slow,
as the TMS9900 must do a lot of memory transfer to complete it...</p>
<p>Status bits affected: none</p>
<h4><br>
<a name="RTWP"></a>RTWP</h4>
<p>Now how do we return to the caller and restore the three TMS9900
registers?
There is a dedicated instruction for that purpose:
Return-with-Worskpace-Pointer.
Upon execution it will branch to the address found in R14, with the
workspace
specified in R13 and place the content of R15 in the status register.
And
we just have restored the situation as it was before the <tt>BLWP </tt>was
taken. </p>
<p>That's an ideal feature for a multi-tasking operating system. Too
bad
there isn't one around... Actually, there is one multi-tasking feature
in the TI-99/4A: the interrupt service routine. Upon reception of an
interrupt,
the TMS9900 performs an implicit <tt>BLWP @&gt;0004</tt>, i.e uses the
values found at &gt;4000 and &gt;4002 in the console ROM as workspace
(&gt;83C0)
and address (&gt;0900). At this address you'll find the interrupt
service
routine, the subprogram that handles all the interrupts. This
subprogram
returns to the main program with a simple <tt>RTWP </tt>and the main
program
never knows it was interrupted.</p>
<p>Know, if you have an "assembly freak" mind, you'll probably
have thought of an alternative use for <tt>RTWP</tt>: change the
content
of the registers in the TMS9900. All we have to do is to load values
into
R13, R14 and R15 and execute a <tt>RTWP</tt>.</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre><tt>      LI   R13,&gt;83E0    This will be the new workspace<br>      LI   R14,THERE    This will be the new address<br>      MOV  R1,R15       The content of R1 will be the new status <br>      RTWP              Do it</tt></pre>
      <pre><tt>      LWPI &gt;83E0        We could alter the workspace this way<br>      B    @THERE       We could change the address this way<br>*     ???               But there is no opcode to load the status </tt></pre>
      </td>
    </tr>
  </tbody>
</table>
<p>This trick is often used to return at a differnt address in case an
error occured within a procedure: just place the address of the error
handling
routine into R14 and the next <tt>RTWP </tt>will branch to it. It is
good
practice to save the previous value of R14 somewhere, in case the error
handling routine would need it, after all</p>
<h4><br>
<a name="XOP"></a>XOP</h4>
<p>Extended operations are implicit <tt>BLWPs </tt>that use vectors
located
at precise addresses in the console ROMs:</p>
<p>XOP 0 uses addresses &gt;0040 and &gt;0042 (worskpace &gt;280A,
address
&gt;0C1C)<br>
XOP 1 uses addresses &gt;0044 and &gt;0046 (workspace &gt;FFD8, address
&gt;FFF8)<br>
XOP 2 uses addresses &gt;0048 and &gt;004A (values may vary according
to
the ROM version), etc</p>
<p>XOPs constitute an advanced feature and are discussed in the TMS9900
<a href="tms9900.htm#XOP">page</a>.</p>
<h4><br>
<a name="Parameter passing"></a>Parameter passing</h4>
<p>While we are taking about branching and calling subroutines, I would
like to briefly discribe the three classical ways for a subroutine to
get
parameters from the calling program: global variables, registers and
immediate
data.</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre><tt>* This snippet illustrate three ways to pass parameters <br>* to a subroutine called with BL</tt></pre>
      <pre>      CLR   @COUNTER     Place the value &gt;0000 into the word at address COUNTER <br><tt>      LI    R0,&gt;01B4     Place value &gt;01B4 into R0<br>      BL    @SUB1        Call a subroutine<br>      DATA  'BA'         Place the value 'BA' (&gt;4241) into a data word<br>BACK  MOV   R1,R0        Continue execution here </tt></pre>
      <pre><tt>SUB1  MOV   @COUNTER,R2  Use the value in COUNTER: global parameter<br>      A     R0,R2        Use the value in R1: parameter in register<br>      MOV   *R11+,R0     Get the value in the data word. AND change R11 to return to BACK <br>      LI    R1,&gt;0456     To return a result: put it in a register<br>      MOV   R2,@RESULT   Our into a global</tt></pre>
      </td>
    </tr>
  </tbody>
</table>
<p>It's not considered as good programming practice to make to much a
wide
use of global parameters. You should reserve them for critical values
that
are needed by many subroutines in your program: using the as global
avoids
having to pass them with a register every time.</p>
<p>Whether to use a register or a data word largely depends on what
kind
of information is passed by this parameter. If it can contain a wide
range
of values that vary often, better use a register. If it just allows to
differentiate between a few situation uses a data word: this will save
you a register, and a word in memory (the one occupied by the LI
instruction
in the caller).</p>
<p>For instance: a routine that places a character somewhere onscreen
should
probably pass the character and the screen position in registers. This
will make it more versatile. By contrast, a routine used to display pre
defined error messages may well use dat words as there won't be that
many
messages and they will probably always be displayed at the same address.</p>
<p>Note the way the data word is retrieved in the subroutine: it
automatically
increments R11 by two, which will skip the data word upon return</p>
<p>The corresponding operations for a subroutine called with <tt>BLWP </tt>would
be the following:</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre><tt>* This snippet illustrate three ways to pass parameters<br>* to a subroutine called with BLWP</tt></pre>
      <pre>      CLR   @COUNTER     Place the value &gt;0000 into the word at address COUNTER <br><tt>      LI    R0,&gt;01B4     Place value &gt;01B4 into R0<br>      BLWP  @SUB4        Call a subroutine, this time changing the context<br>      DATA  'BA'         Place the value 'BA' (&gt;4241) into a data word<br>BACK  MOV   R1,R0        Continue execution here </tt></pre>
      <pre><tt>SUB4  DATA  WREGS,SUB40  Use this workspace and this address</tt></pre>
      <pre><tt>SUB40 MOV   @COUNTER,R2  Use the value in COUNTER: global parameter<br>      A     *R13,R2      Use the value in old R0: parameter in register<br>      MOV   *R14+,R0     Get the value in the data word. AND change R14 to return to BACK <br>      LI    R1,&gt;0456     To return a result: put it in a register<br>      MOV   R1,@2(R13)   Remember: the address of the old workspace is in R13<br>      MOV   R2,@RESULT   Our return value in a global</tt></pre>
      </td>
    </tr>
  </tbody>
</table>
<p>Did you get the trick with R13? Since R13 contains the address of
the
old workspace, <tt>*R13</tt> points at the old R0, <tt>@2(R13)</tt>
at
the old R1, <tt>@4(R13)</tt> at the old R2, etc.</p>
<h4><br>
<a name="Returning values"></a>Returning values</h4>
<p>If the subroutine wants to return a value, it can place it in a
register,
or in a global variable. Generally, one does not return values in a
DATA
statement (because the program could be placed in ROM, in which case
the
data word won't take the new value). On the other hand, the following
trick
is often use to indicate a special condition upon return:</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre><tt>      BL   @SUB2       Call a subroutine<br>      JMP  ERROR       In principle, returns here<br>      MOV  R0,R1       In fact, returns here if no error occured </tt></pre>
      <pre><tt>SUB2  CI   R0,&gt;0111    Compare R0 to &gt;0111<br>      JL   ERR         We don't want it to be smaller (silly example) <br>      INCT R11         Change return address: skip the JMP if no error <br>ERR   B    *R11        Return at the address found in R11</tt>
      </pre>
      </td>
    </tr>
  </tbody>
</table>
<p>SUB2 indicates to the caller that everything went OK by skipping the
JMP upon return. Another way to do it would be to place the test in the
caller, since the B instruction does not affect the status register:</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre><tt>      BL   @SUB3       Call a subroutine<br>      JL   ERROR       Use the comparison performed in SUB3<br>      MOV  R0,R1      </tt></pre>
      <pre><tt>SUB3  CI   R0,&gt;0111    Compare R0 to &gt;0111<br>      B    *R11        Let the caller do the conditional branch</tt>
      </pre>
      </td>
    </tr>
  </tbody>
</table>
<p>Now what about routines called with <tt>BLWP</tt>? The first
solution
is identical, just replace R11 with R14:</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre><tt>      BLWP @SUB8       Call a subroutine<br>      JMP  ERROR       In principle, returns here<br>      MOV  R0,R1       In fact, returns here if no error occured </tt></pre>
      <pre><tt>SUB8  DATA WREGS,SUB80 New workspace and branching address</tt></pre>
      <pre><tt>SUB80 CI   R0,&gt;0111    Compare R0 to &gt;0111<br>      JL   ERR         We don't want it to be smaller (silly example) <br>      INCT R14         Change return address: skip the JMP if no error <br>ERR   BLWP             Return at the address found in R14</tt>
      </pre>
      </td>
    </tr>
  </tbody>
</table>
<p>The second solution is trickier since the RTWP discards the content
of the status register and replaces it with R15. We therefore have to
store
the status in R15 beforehand (or some value of our choice).</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre><tt>      BLWP @SUB9       Call a subroutine<br>      JL   ERROR       Use the comparison performed in SUB9<br>      MOV  R0,R1      </tt></pre>
      <pre><tt>SUB90 DATA WREGS,SUB80 New workspace and branching address</tt></pre>
      <pre><tt>SUB80 CI   R0,&gt;0111    Compare R0 to &gt;0111<br>      STST R15         Store the status register in R15<br>      RTWP             Return with the new status taken from R15 </tt>
      </pre>
      </td>
    </tr>
  </tbody>
</table>
<p>Finally, let me remind you that you can change the return address by
loading any value in R11 (or R14 for <tt>RTWP</tt>)</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre><tt>       BL   @ENTRY1        Call a procedure <br>BACK   ABS  @TABLE(R2)     That will return here </tt>
      </pre>
      <pre><tt>ENTRY2 LI   R11,ERROR      Special entry point: always return to error <br>ENRTY1 MOV  R0,R0          Regular entry point: return provided by BL<br>       B    *R11  </tt></pre>
      </td>
    </tr>
  </tbody>
</table>
<h3><br>
<a name="Arithmetic opcodes"></a>Arithmetic opcodes</h3>
<p>The following opcodes can be used to perform integer math. Unless
otherwise
indicated, the source and destination operands can be accessed in any
of
the five main addressing modes: Rx, *Rx, *Rx+, @xxxx and @xxxx(Rx).</p>
<h4><a name="MOV"></a>MOV <i>source,dest</i> </h4>
<p>Copies the content of the source operand into the destination
operand
and compares it to zero.<br>
Status bits affected: High, Gt, Equ</p>
<h4><br>
<a name="MOVB"></a>MOVB <i>source,dest</i></h4>
<p>Same as MOV, but affects only the leftmost (most significant) byte
of
the operands.<br>
Status bits affected: High, Gt, Equ, Parity</p>
<h4><br>
<a name="LI"></a>LI <i>register,immediate</i></h4>
<p>Loads the immediate value into the destination register and compares
it to zero.<br>
Status bits affected: High, Gt, Equ</p>
<h4><br>
<a name="A"></a>A <i>source,dest</i></h4>
<p>Adds the content of the source operand to the destination operand
and
compares the result to zero.<br>
Status bits affected: High, Gt, Equ, Carry, Ovf</p>
<h4><br>
<a name="AB"></a>AB <i>source,dest</i></h4>
<p>Same as A, but affects only the leftmost (most significant) byte of
the operands.<br>
Status bits affected: High, Gt, Equ, Carry, Ovf, Parity</p>
<h4><br>
<a name="AI"></a>AI <i>register,immediate</i></h4>
<p>Adds an immediate value to the destination register.<br>
Status bits affected: High, Gt, Equ, Carry, Ovf</p>
<p>NB. There is no SI (substract immediate) instruction, but you can
use
AI with negative values: <tt>AI R0,-5</tt></p>
<h4><br>
<a name="S"></a>S <i>source,dest</i></h4>
<p>Substracts the content of the source operand from the destination
operand
and compares the result to zero.<br>
Status bits affected: High, Gt, Equ, Carry</p>
<h4><br>
<a name="SB"></a>SB <i>source,dest</i></h4>
<p>Same as S, but affects only the leftmost (most significant) byte of
the operands.<br>
Status bits affected: High, Gt, Equ, Carry, Ovf, Parity</p>
<h4><br>
<a name="C"></a>C <i>source,dest</i></h4>
<p>Compares the content of the source operand to that of the
destination
operand.<br>
Status bits affected: High, Gt, Equ</p>
<h4><br>
<a name="CB"></a>CB <i>source,dest</i></h4>
<p>Same as C, but affects only the leftmost (most significant) byte of
the operands.<br>
Status bits affected: High, Gt, Equ, Parity</p>
<h4><br>
<a name="CI"></a>CI <i>register,immediate</i></h4>
<p>Compares the register to an immediate value.<br>
Status bits affected: High, Gt, Equ,</p>
<h4><br>
<a name="DEC"></a>DEC <i>dest</i></h4>
<p>Decrements the destination operand by 1 and compares the result to
zero.<br>
Status bits affected: High, Gt, Equ, Carry, Ovf</p>
<h4><br>
<a name="DECT"></a>DECT <i>dest</i></h4>
<p>Decrements the destination operand by 2 and compares the result to
zero<br>
Status bits affected: High, Gt, Equ, Carry, Ovf, Parity</p>
<h4><br>
<a name="INC"></a>INC <i>dest</i></h4>
<p>Increments the destination operand by 1 and compares the result to
zero<br>
Status bits affected: High, Gt, Equ, Carry, Ovf</p>
<h4><br>
<a name="INCT"></a>INCT <i>dest</i></h4>
<p>Increments the destination operand by 2 and compares the result to
zero<br>
Status bits affected: High, Gt, Equ, Carry, Ovf, Parity</p>
<h4><br>
<a name="NEG"></a>NEG <i>de</i>st</h4>
<p>Negates the destination operand and compares the result to zero.<br>
Status bits affected: High, Gt, Equ, Carry, Ovf, Parity</p>
<h4><br>
<a name="ABS"></a>ABS <i>de</i>st</h4>
<p>Takes the absolute value of the destination operand (i.e. negates it
if it is less than 0) and compares the result to zero.<br>
Status bits affected: High, Gt, Equ, Carry, Ovf, Parity</p>
<p>NB There are no DECB, DECTB, INCB, INCTB, NEGB, nor ABSB
byte-oriented
operations.</p>
<h4><br>
<a name="MPY"></a>MPY <i>source,register</i></h4>
<p>Multiplies the source operand and the destination register. The
result
will probably be 2-word long and will therefore be placed into the
destination
register and the following register! (If R15 is the destination, the
next
memory word after the workspace is used).</p>
<p>Example: R0 * R1 --&gt; [R1-R2]</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre><tt>      LI   R0,5<br>      LI   R1,10<br>      MPY  R0,R1  Now R1-R2 contains 10<br>*                 i.e. R1 is 0, R2 is 10 </tt></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4><br>
<a name="DIV"></a>DIV <i>source,register</i></h4>
<p>Divides the 2-word value found in the destination regiser and the
following
register by the content of the source operand. The result is placed in
the destination register. The remainder in the next register.<br>
Status bits affected: Ovf</p>
<p>Example: [R1-R2] / R0 --&gt; R1, Remainder in R2</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre><tt>      LI   R0,4<br>      LI   R1,8<br>      LI   R2,3   R1-R2 contains &gt;0008 0003 <br>      DIV  R0,R1  Now R1 is &gt;0002<br>*                 and R2 is &gt;0003 (remainder) </tt></pre>
      </td>
    </tr>
  </tbody>
</table>
<h3><br>
<a name="logic opcodes"></a>Bitwise logic opcodes</h3>
<p>The following operations deal with operands on a bitwise basis, i.e.
the operands are not considered as words or bytes but as a collection
of
individual bits. The change of a given bit will never affect
neighbouring
bits.</p>
<h4><br>
<a name="CLR"></a>CLR <i>dest</i></h4>
<p>Reset (clears) all bits in the destination operand to zero. The
result
is &gt;0000.<br>
Status bits affected: none</p>
<h4><br>
<a name="SETO"></a>SETO <i>dest</i></h4>
<p>Sets all bits in the destination operand to one. The result is
&gt;FFFF.<br>
Status bits affected: none</p>
<h4><br>
<a name="INV"></a>INV <i>dest</i></h4>
<p>Inverts all bits in the destination operand (logical NOT) and
compares
the result to zero.<br>
A 0 bit becomes a 1, a 1 bit becomes a 0.<br>
inv 0 = 1<br>
inv 1 = 0</p>
<p>Status bits affected: High, Gt, Equ</p>
<h4><br>
<a name="ANDI"></a>ANDI <i>register,immediate</i></h4>
<p>Ands the bit in the destination register with those in the immediate
value and compares the result to zero.<br>
If both the source and destination bit are 1, the resulting bit will be
1. Otherwise it will be 0.<br>
0 andi 0 = 0<br>
0 andi 1 = 0<br>
1 andi 0 = 0<br>
1 andi 1 = 1</p>
<p>Status bits affected: High, Gt, Equ</p>
<h4><br>
<a name="ORI"></a>ORI <i>register,immediate</i></h4>
<p>Ors the bit in the destination register with those in the immediate
value and compares the result to zero.<br>
If both the source and destination bit are 0, the resulting bit will be
0. Otherwise it will be 1.<br>
0 ori 0 = 0<br>
0 ori 1 = 1<br>
1 ori 0 = 1<br>
1 ori 1 = 1</p>
<p>Status bits affected: High, Gt, Equ</p>
<h4><br>
<a name="XOR"></a>XOR <i>source, register</i></h4>
<p>Exclusive OR of the bits in the source operand with those in the
destination
register. The result is compared to zero.</p>
<p>If a bit is 1 in either the source or the destination operand, but
not
both, it will be one. Bits that are identical in both operands are
reset
to 0:<br>
0 xor 0 = 0<br>
0 xor 1 = 1<br>
1 xor 0 = 1<br>
1 xor 1 = 0</p>
<p>Status bits affected: High, Gt, Equ</p>
<p>NB There is no XORI instruction</p>
<h4><br>
<a name="SOC"></a>SOC <i>source,dest</i></h4>
<p>Sets to 1 all bits in the destination operand that correspond to a 1
in the source operand and compares the result to 0. The other bits are
unchanged. </p>
<p>Set Ones Corresponding is therefore the equivalent of a logical OR:<br>
0 soc 0 = 0<br>
0 soc 1 = 1<br>
1 soc 0 = <b>1<br>
</b>1 soc 1 = <b>1</b></p>
<p>Status bits affected: High, Gt, Equ</p>
<p>Example: </p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre><tt>      LI   R0,&gt;0401<br>      LI   R1,&gt;1021<br>      SOC  R0,R1     R1 now contains &gt;1421 </tt></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4><br>
<a name="SOCB"></a>SOCB <i>source,dest</i></h4>
<p>Same as SOC, but affects only the leftmost (most significant) byte
of
the operands.<br>
Status bits affected: High, Gt, Equ, Parity</p>
<h4><br>
<br>
<a name="SZC"></a>SZC <i>source,dest</i></h4>
<p>Resets to 0 all bits in the destination operand that correspond to a
1 in the source operand and compares the result to 0. The other bits
are
unchanged. </p>
<p>Set Zero Corresponding is therefore the equivalent of a logical
NOT-A
AND B:<br>
0 szc 0 = 0<br>
0 szc 1 = 1<br>
1 szc 0 = <b>0<br>
</b>1 szc 1 = <b>0</b></p>
<p>Status bits affected: High, Gt, Equ</p>
<p>Example: </p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre><tt>      LI   R0,&gt;0401<br>      LI   R1,&gt;1420<br>      SZC  R0,R1     R1 now contains &gt;1020 </tt></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4><br>
<a name="SZCB"></a>SZCB <i>source,dest</i></h4>
<p>Same as SOC, but affects only the leftmost (most significant) byte
of
the operands.<br>
Status bits affected: High, Gt, Equ, Parity</p>
<h4><br>
<a name="COC"></a>COC <i>source,dest</i></h4>
<p>Checks whether all bits in the destination operand that correspond
to
a 1 in the source operand are 1. Sets the Equ bit if this is the case.
All bits are unchanged. </p>
<p>Compares Ones Corresponding therefore performes a masked comparison
with &gt;FFFF:<br>
0 coc 0 --&gt; not considered<br>
0 coc 1 --&gt; not considered<br>
1 coc 0 --&gt; Equ will be 0 if this happens at least once<br>
1 coc 1 --&gt; ok so far.</p>
<p>Status bits affected: Equ</p>
<p>Example: </p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre><tt>      LI   R0,&gt;0401<br>      LI   R1,&gt;1021<br>      LI   R2 &gt;4481<br>      COC  R0,R1     Equ = 0 (because &gt;0400 is not set in R1) <br>      JEQ  SK1       The jump is not taken <br>      COC  R0,R2     Equ = 1<br>      JEQ  SK2       The jump is taken</tt></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4><br>
<a name="CZC"></a>CZC <i>source,dest</i></h4>
<p>Checks whether all bits in the destination operand that correspond
to
a 1 in the source operand are 0. Sets the Equ bit if this is the case.
All bits are unchanged. </p>
<p>Compares Ones Corresponding therefore performes a masked comparison
to with &gt;0000:<br>
0 coc 0 --&gt; not considered<br>
0 coc 1 --&gt; not considered<br>
1 coc 0 --&gt; ok so far<br>
1 coc 1 --&gt; Equ will be 0 if this happens at least once.</p>
<p>Status bits affected: Equ</p>
<p>Example: </p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre><tt>      LI   R0,&gt;0401<br>      LI   R1,&gt;1021<br>      LI   R2 &gt;4080<br>      CZC  R0,R1     Equ = 0 (because &gt;0001 is not reset in R1) <br>      JEQ  SK1       The jump is not taken <br>      CZC  R0,R2     Equ = 1<br>      JEQ  SK2       The jump is taken</tt></pre>
      </td>
    </tr>
  </tbody>
</table>
<p>NB These is no COCB, nor CZCB byte-oriented instruction.</p>
<h3><br>
<br>
<a name="Shift opcodes"></a>Shift opcodes</h3>
<p>The following operations shift the content of a registed, i.e. move
all bits in it towards the left or the right.</p>
<p>Shifting one position to the left corresponds to a multiplication by
two (just as moving the decimal point by one position corresponds to a
multiplication/division by 10). Shifting to the right corresponds to a
division by two. However, in the latter case we may have to take the
sign
bit into account, if we are dealing with signed values: therefore there
are two shift-right instructions: one for logical operands, one for
arithmetic
operands.</p>
<p>For each you can specify by how many positions you want to shift the
bits: legal values are 1 to 15. Shifting by 0 has of course no effect,
so this value is interpreted differently: If you specify a shift by 0,
the number of positions is taken from the value in R0 (rounded to 15).
If this value is zero, the bits will be shifted by 16 positions.</p>
<h4><br>
<a name="SLA"></a>SLA <i>register,count</i></h4>
<p>Shifts the content of the register by <i>count </i>positions to
the
left, filling up the bits on the right with 0. The result is compared
to
zero, the last bit shifted out is placed in the carry bit.</p>
<p>Status bits affected: High, Gt, Equ, Carry</p>
<p>NB There is no SLL (Shift Left Logically) because it's equivalent to
SLA (Shift Left Arithmetic).</p>
<p>Example: </p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre><tt>      LI   R0,&gt;0401<br>      SLA  R0,1          R0 now contains &gt;0802 <br>      SLA  R0,4          R0 now contains &gt;8020<br>      SLA  R0,1          R0 now contains &gt;0040 and the Carry is 1 </tt></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4><br>
<a name="SRL"></a>SRL <i>register,count</i></h4>
<p>Shifts the content of the register by <i>count </i>positions to
the
right, filling up the bits on the left with 0. The result is compared
to
zero, the last bit shifted out is placed in the carry bit.</p>
<p>Status bits affected: High, Gt, Equ, Carry, Ovf (=1 if sign bit is
changed).</p>
<p>Example: </p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre><tt>      LI   R1,&gt;8401<br>      SRL  R1,1          R1 now contains &gt;4200 and Carry is 1 <br>      SLA  R1,4          R1 now contains &gt;0420 and Carry is 0<br>      LI   R0,1          Shift by one<br>      SLA  R1,0          R1 now contains &gt;0210 (shift value taken from R0) </tt></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4><br>
<a name="SRA"></a>SRA <i>register,count</i></h4>
<p>Shifts the content of the register by <i>count </i>positions to
the
right, filling up the bits on the right with copies of the sign bit.
The
result is compared to zero, the last bit shifted out is placed in the
carry
bit.</p>
<p>Status bits affected: High, Gt, Equ, Carry</p>
<p>Example: </p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre><tt>      LI   R1,&gt;8002      (i.e -32766)<br>      SRA  R1,1          R1 now contains &gt;C001 (i.e. -16383, correct division by 2) <br>*     SRL  R1,1          By contast, a SRL would give &gt;4001, which is 16385!</tt></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4><br>
<a name="SRC"></a>SRC <i>register,count</i></h4>
<p>Shifts the content of the register by <i>count </i>positions to
the
right, filling up the bits on the left with those ejected on the right.
The result is compared to zero, the last bit shifted out is placed in
the
carry bit.</p>
<p>Status bits affected: High, Gt, Equ, Carry</p>
<p>NB There is no SLC (Shift Left Circular), but you can do it with SRC
(Shift Right Circular): just substact the desired displacement from 16:
<tt>SLC R1,5</tt> is encoded by <tt>SRC R1,11</tt>.</p>
<p>Example: </p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre><tt>      LI   R1,&gt;0401<br>      SRC  R1,1          R1 now contains &gt;8200 and Carry is 1 <br>      SRC  R1,4          R1 now contains &gt;0820 and Carry is 0<br>      SRC  R1,12         R1 now contains &gt;8200 (equivalent to SLC R1,4) </tt></pre>
      </td>
    </tr>
  </tbody>
</table>
<h3><br>
<a name="CRU opcodes"></a>CRU opcodes</h3>
<p>These opcodes affect the CRU. See above for the CRU <a
 href="#CRU%20addressing">addressing
mode</a>. I also have a whole <a href="cru.htm#software">page </a>that
discusses CRU issues. You may want to have a look at it.</p>
<h4><a name="SBO"></a>SBO <i>bit</i></h4>
<p>Sets a CRU bit to 1. The bit number can be from 0 to 15 and is
relative
to the CRU address in R12.<br>
Status bits affected: none</p>
<h4><br>
<a name="SBZ"></a>SBZ <i>bit</i></h4>
<p>Sets a CRU bit to 0. The bit number can be from 0 to 15 and is
relative
to the CRU address in R12.<br>
Status bits affected: none</p>
<h4><br>
<a name="TB"></a>TB <i>bit</i></h4>
<p>Tests a CRU bit. The bit number can be from 0 to 15 and is relative
to the CRU address in R12. The bit is copied into the Equ bit in the
status
register.<br>
Status bits affected: Equ</p>
<h4><br>
<a name="LDCR"></a>LDCR <i>register,nbits</i></h4>
<p>Loads <i>nbits </i>bits to the CRU, starting from the CRU address
in
R12. If there are 1 to 8 bits, they bits are taken (from right to left)
from the most significant byte of the source register. If there are 9
to
16 bits, they are taken (from right to left) from the whole register.</p>
<p>Status bits affected: High, Gt, Equ, Carry. (Parity for 1-byte
operations)</p>
<h4><br>
<a name="STCR"></a>STCR <i>register,nbits</i></h4>
<p>Reads <i>nbits </i>bits from the CRU, starting from the CRU
address
in R12. If there are 1 to 8 bits, they bits are stored (from right to
left)
into the most significant byte of the source register. If there are 9
to
16 bits, they are stored (from right to left) into the whole register.</p>
<p>Status bits affected: High, Gt, Equ, Carry. (Parity for 1-byte
operations)</p>
<h3><br>
<a name="Various opcodes"></a>Various opcodes</h3>
<p>Finally, here are some opcodes that I couldn't fit in any of the
above
categories.</p>
<h4><a name="LWPI"></a>LWPI <i>immediate</i></h4>
<p>Loads an immediate value into the workspace pointer register of the
TMS9900, effectively changing the workspace. Just make sure that <i>imme</i>diate
does not correspond to an address in ROM !</p>
<p>Status bits affected: none</p>
<h4><br>
<a name="STWP"></a>STWP <i>register</i></h4>
<p>Stores the content of the workspace pointer register of the TMS9900
(i.e. the address of the current workspace) into the destination
register.</p>
<p>Status bits affected: none</p>
<p>NB. There is no LDWP, so if you want to change the value of the
workspace
you have two solutions:</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre><tt>* Assume we want to use the value in R0 for our new workspace<br>* We have two solutions:</tt></pre>
      <pre><tt>* 1) Put the value in our program and perform a LWPI</tt></pre>
      <pre>       MOV  R0,HERE+2     Replaces the &gt;0000 below with our value<br>HERE   LWPI &gt;0000         Loads the new workspace pointer<br><tt>     </tt></pre>
      <pre><tt>* 2) Put the value in R13 and perform a dummy RTWP</tt></pre>
      <pre><tt>       STST R15           Make sure the status won't be affected<br>       LI   R14,CONT      Make sure we go on normally<br>       MOV  R0,R13        <br>       RTWP<br>CONT   ...                Execution continues here with our new workspace </tt></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4><br>
<a name="STST"></a>STST <i>register</i></h4>
<p>Stores the status register of the TMS9900 into the destination
register.</p>
<p>Status bits affected: none</p>
<p>NB There is no LDST to load a value in the status register. But you
can put it in R15 and perform a RTWP (just make sure that R13 contains
the proper workspace, and R14 a valid address).</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre><tt>* Assume we want to put the value in R0 into the status register<br>* Solution: Put the value in R13 and perform a dummy RTWP</tt></pre>
      <pre><tt>       STWP R13            Make sure thje workspce won't change<br>       LI   R14,CONT1      Make sure we go on normally<br>       MOV  R0,R15        <br>       RTWP<br>CONT1  ...                 Execution continues here with new status </tt></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4><br>
<a name="LIMI"></a>LIMI <i>immediate</i></h4>
<p>Loads a value from 0 to 15 into the interrupt mask part of the
status
register. Only interrupts with a level equal or smaller than this value
will be recognized. On the TI-99/4A all interrupts are hardwired as
level
1. Therefore:</p>
<p>LIMI 0 and LIMI&nbsp;1 enable interrupts<br>
LIMI2 to LIMI 15 disable interrupts</p>
<p>Status bits affected: interrupt mask<br>
</p>
<h4><br>
<a name="SWPB"></a>SWPB <i>dest</i></h4>
<p>Swap the most significant and the least significant bytes of the
destination
operand. </p>
<p>Status bits affected: none.</p>
<p>Example:</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre><tt>       LI   R1,&gt;A52B<br>       SWPB R1           R1 now contains &gt;2BA5 </tt></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4><br>
<a name="X"></a>X <i>dest</i></h4>
<p>Executes the machine language instruction whose value is found in
the
destination operand. If the instruction requires additional memory
words
for operands, they will be taken after the X instruction, not after the
address of the operand.</p>
<p>Status bits affected: depends on the instruction executed.</p>
<p>Example (also see the <a href="tms9900.htm#X">page</a> on the
TMS9900)</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre>* This performs: B    *R11<br><tt>       LI   R9,&gt;045B     This means B  *R11<br>       X    R9           Do it</tt></pre>
      <pre><tt>* This performs: LI   R1,&gt;1234<br>       LI   R0,&gt;0201     This means LI  R1,xxxx<br>       X    R0<br>       DATA &gt;1234        Value to load in R1</tt></pre>
      <pre>* This performs: NEG  @&gt;2000<br><tt>       X    @TEST        Opcode to execute<br>       DATA &gt;2000        Operand used</tt></pre>
      <pre><tt>TEST   NEG  @&gt;0000</tt></pre>
      </td>
    </tr>
  </tbody>
</table>
<h3><br>
<a name="Forbidden opcodes"></a>Forbidden opcodes</h3>
<p>There are five opcodes that should never be used with the TI-99/4A,
because they would be mistaken for CRU operations. These are:</p>
<p>CKON<br>
CKOF<br>
LREX<br>
RSET<br>
IDLE</p>
<p>See the TMS9900 <a href="tms9900.htm#External">page</a> for details.</p>
<h2><br>
<br>
<a name="instructions"></a>Assembly-time instructions</h2>
<p>Besides opcodes, you can also include instructions to the assembler
whithin your source file. These instructions may or may not generate
code,
some deal with a printout feature, some issue commands for the linker,
etc.</p>
<p>They may vary from assembler to assembler, therefore I only included
here the most common ones.</p>
<p>Instuctions that generate data: <a href="#DATA">DATA</a>, <a
 href="#BYTE">BYTE</a>,
<a href="#TEXT">TEXT</a> or reserve room for it <a href="#BSS">BSS</a>,
<a href="#BSS">BES</a>, <a href="#EVEN">EVEN<br>
</a>Instructions for the linker: <a href="#DEF">DEF</a>, <a
 href="#REF">REF<br>
</a>Instructions for the loader: <a href="#AORG">AORG</a>, <a
 href="#RORG">RORG</a>,
<a href="#END">END<br>
</a>Others: <a href="#COPY">COPY</a></p>
<h4><br>
<a name="DATA"></a>DATA <i>value</i>[<i>,value</i>]</h4>
<p>This instuction is used to generate code that is not an opcode.
Generally,
to place data in your program. </p>
<p><i>value </i>can be any number (or math expression) between 0 and
&gt;FFFF.
It can also be entered as a 2-character string constant. If needed,
many
data words can be place on the same line, separed with comas.</p>
<p>Note that a data word will always be loaded at an even address, on a
word boundary.</p>
<p>Example:</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre><tt>       DATA 5,6,&gt;8001,0<br>       DATA 'TE'</tt></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4><br>
<a name="BYTE"></a>BYTE <i>value</i>[<i>,value</i>]</h4>
<p>Pretty much like <tt>DATA</tt>, except that it generates only one
byte,
and is therefore not limited by word boundaries. </p>
<p><i>Value </i>can be any number between 0 and 255, or a
single-character
string.</p>
<h4><br>
<a name="TEXT"></a>TEXT '<i>string</i>'</h4>
<p>This instruction is used to insert data into your program. The data
is specified in the form of a quoted string.</p>
<p>Example:</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre><tt>       TEXT 'This is a test'</tt></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4><br>
<a name="BSS"></a>BSS <i>nbytes<br>
</i>BES <i>nbytes</i></h4>
<p>These two instructions are used to reserve space into your program.
Generally you will place data there. Contrarily to the above
instructions,
<tt>BSS </tt>(block starting with symbol) and <tt>BES </tt>(block
ending
with symbol) don't place values into memory: they just tell the loader
to skip <i>nbytes </i>before to load the next instruction.</p>
<p><tt>BSS </tt>only differs from <tt>BES </tt>when you use a label:
the
label value corresponds to the current address with <tt>BSS </tt>and
to
the current address plue <i>nbytes </i>with <tt>BES </tt>(i.e. the
end
address).</p>
<p>Example</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre>CLRBUF LI   R1,BUFFER  Point to our buffer<br>       LI   R2,256     Buffer size in bytes<br>L1     CLR  *R1+       Clear a word in it<br>       DECT R2         Decrement bytes counter<br>       JNE  L1         More to clear<br><tt>       B    *R11</tt></pre>
      <pre><tt>BUFFER BSS  256        Reserve 256 bytes of memory</tt></pre>
      <pre><tt>       MOV   R0,R1     Next procedure</tt></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4><br>
<a name="EVEN"></a>EVEN</h4>
<p>Is used to make sure the loading will continue from a word boundary.
This instruction is usefull afer a <tt>TEXT </tt>statement, when you
don't
want to count the number of characters to know whether you must add a <tt>BYTE
</tt>statement or not. <tt>EVEN </tt>issues a &gt;00 data byte if the
current
address is uneven, it does nothing otherwise.</p>
<h4><br>
<a name="DEF"></a>DEF <i>label</i>[<i>,label]</i></h4>
<p>This instructions is used to pass one or more labels to the loader.
The values of these labels will thereby be available for other files,
or
for the loader itself (to launch you program for instance).</p>
<p><i>label </i>must be a valid label (1 to 6 characters, the first
one
being not a digit) and must be defined in the source file.</p>
<p>Example:</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre><tt>      DEF START,INIT<br>      DEF COUNT</tt></pre>
      <pre><tt>START MOV  R11,R10       Entry point of my program <br>      ...                Long program<br>      B    *R10          Return to the caller</tt></pre>
      <pre><tt>INIT  CLR  @COUNT        Procedure available to another file <br>      B    *R11  </tt></pre>
      <pre><tt>COUNT DATA 10            Data word available to another file</tt></pre>
      <pre><tt>     END</tt></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4><br>
<a name="REF"></a>REF <i>label</i>[<i>,label</i>]</h4>
<p>This is the mirror-image of <tt>DEF</tt>. It allows your source
file
to reference labels that are part of another source file. You can
thereby
access its variables, call its procedures, etc.</p>
<p>You are not allowed however to perform arithmetic on REF labels
since
these are undefined at assembly time</p>
<p>Example:</p>
<table cellspacing="2" cellpadding="2" bgcolor="#e6e6e6">
  <tbody>
    <tr>
      <td>
      <pre><tt>       REF COUNT,INIT     </tt></pre>
      <pre><tt>       BL   @INIT           Call a procedure in another file <br>       MOV  @COUNT,R0       Use a data word from another file <br>       MOV&nbsp; @COUNT+2,R1     Illegal: no math allowed with REF labels <br>       LI   R1,COUNT        Instead, do this<br>       MOV  @2(R1),R1       It's ok, since the math is done at execution time </tt></pre>
      </td>
    </tr>
  </tbody>
</table>
<h4><br>
<a name="AORG"></a>AORG <i>address</i></h4>
<p>This instruction will force the loader to load the program at a
precise
memory location. In general you won't use it, except to modify a
precise
data word. E.g. to place values in the non-maskable interrupt vectors
at
&gt;FFFC-FFFF.</p>
<h4><br>
<a name="RORG"></a>RORG [<i>offset</i>]</h4>
<p>This instruction allows the loader to determine itself where the
program
should be loaded. The TI loader starts from &gt;A000 towards &gt;FFD8,
and continues with the low-memory expansion (in which there is very
limited
space, since that's were the loader is located, and it also contains a
symbol table for the REFs and DEFs).</p>
<p><tt>RORG </tt>can be used to cancel the effect of an <tt>AORG</tt>.</p>
<p>If an offset is specified, it will be added to the current address.
The effect is similar to that of the <tt>BSS </tt>instruction, except
that
you could specify a negative offset, thereby causing the loader to
overwrite
what it just loaded. (Sounds like a silly thing to do but it may be
usefull
with paged-memory devices).</p>
<h4><br>
<a name="END"></a>END [<i>label</i>]</h4>
<p>This is the only instruction that must be part of any program. It
tells
the assembler to stop processing the source file.</p>
<p>If an optional label is specified, it will be used by the loader to
automatically start the program once this file is loaded. Otherwise,
you
must DEFine a label and enter its name when the loader asks you where
to
start.</p>
<h4><br>
<a name="COPY"></a>COPY "<i>filename</i>"</h4>
<p>This allows for writing very long programs. It instructs the
assembler
to switch to the file specified in double-quotes. Once this file is
completely
assembled, the assembler will resume with the current one. Generally,
assemblers
don't let you nest <tt>COPY </tt>statements, i.e. you cannot have a <tt>COPY
</tt>in a copied file. But you can have as many <tt>COPY </tt>as you
want
in the initial file.</p>
<h2><br>
<br>
<a name="Encoding format"></a>Encoding format</h2>
<p>Assembly language opcodes and operands are encoded into machine
language
according to nine fundamental formats. Each uses up a word of memory
per
opcode, possibly together with one or two extra words for operands.</p>
<table border="1">
  <tbody>
    <tr>
      <th>Format</th>
      <th>Operands</th>
      <th>&gt;80</th>
      <th>&gt;40</th>
      <th>&gt;20</th>
      <th>&gt;10</th>
      <th>&gt;08</th>
      <th>&gt;04</th>
      <th>&gt;02</th>
      <th>&gt;01</th>
      <th>&gt;80</th>
      <th>&gt;40</th>
      <th>&gt;20</th>
      <th>&gt;10</th>
      <th>&gt;08</th>
      <th>&gt;04</th>
      <th>&gt;02</th>
      <th>&gt;01</th>
    </tr>
    <tr>
      <td>I</td>
      <td><i>source,dest </i></td>
      <td colspan="3">Opcode</td>
      <td>B</td>
      <td colspan="2">Td</td>
      <td colspan="4">destination (reg)</td>
      <td colspan="2">Ts</td>
      <td colspan="4">source (reg)</td>
    </tr>
    <tr>
      <td>II</td>
      <td><i>PC-relative</i></td>
      <td colspan="8">Opcode</td>
      <td colspan="8">PC-relative offset in words</td>
    </tr>
    <tr>
      <td>III</td>
      <td><i>source,register </i></td>
      <td colspan="6">Opcode</td>
      <td colspan="4">register</td>
      <td colspan="2">Ts</td>
      <td colspan="4">source (reg)</td>
    </tr>
    <tr>
      <td>IV</td>
      <td><i>source,nbits</i></td>
      <td colspan="6">Opcode</td>
      <td colspan="4">nbits</td>
      <td colspan="2">Ts</td>
      <td colspan="4">source (reg)</td>
    </tr>
    <tr>
      <td>V</td>
      <td><i>register,count</i></td>
      <td colspan="8">Opcode</td>
      <td colspan="4">count</td>
      <td colspan="4">register</td>
    </tr>
    <tr>
      <td>VI</td>
      <td><i>dest</i></td>
      <td colspan="10">Opcode</td>
      <td colspan="2">Ts</td>
      <td colspan="4">source (reg)</td>
    </tr>
    <tr>
      <td>VII</td>
      <td>-</td>
      <td colspan="11">Opcode</td>
      <td colspan="5">
      <pre> 0   0   0   0   0</pre>
      </td>
    </tr>
    <tr>
      <td>VIII</td>
      <td><i>register,immed</i></td>
      <td colspan="11">Opcode</td>
      <td>
      <pre> 0</pre>
      </td>
      <td colspan="4">register</td>
    </tr>
    <tr>
      <td>IX</td>
      <td><i>source,register</i></td>
      <td colspan="6">Opcode</td>
      <td colspan="4">register</td>
      <td colspan="2">Ts</td>
      <td colspan="4">source (reg)</td>
    </tr>
  </tbody>
</table>
<p><b>Ts</b> and <b>Td</b> define the type of addressing for the
source
and destination operand respectively.</p>
<p>00: Rx<br>
01: *Rx<br>
10: @yyyy(Rx) or @yyyy if Rx = 0 This requires an additional memory
word
to store the yyyy value<br>
11: *Rx+</p>
<p><b>Source </b>and <b>dest </b>contain the workspace register,
used in
the way indicated be the addressing mode.</p>
<p><b>Immed</b> operands also require an additional word to store the
immediate
value.</p>
<h2><br>
<a name="hex notation"></a>Hexadecimal notation</h2>
<h4>Decimal notation: base 10</h4>
<p>In almost all cultures throughout the ages, the numbering system is
based on 10 digits. This is of course because we have 10 fingers
(finger
is "digitum" in latin...). The only exception I know of are that
Mayas who used 20 digits. Guess why?</p>
<p>In our culture these ten digits are represented by ten symbols
derived
from arabic: "0", "1", "2", "3",
"4", "5", "6", "7", "8",
and "9".</p>
<p>With 10 digits we can represent ten numbers: zero through nine. Now
what if we want to write down a larger number? Well, we just combine
two
digits: one for the tenth and one for the units. 23 means "two times
ten, plus three", which is twenty-three. Similarly, we can add a third
digit for the undredth, a fourth for the thousands, etc.</p>
<h4><br>
Hexadecimal notation: base 16</h4>
<p>But nothing prevents us to use more (or less) than 10 digits. Let's
say we want to use sixteen digits instead of ten. First we need to find
names and symbols for the extra six. We could come up with goofy names
(borg, spam, taku, etc) and fancy symbols, but we wouldn't be able to
type
them from a computer keyboard. Therefore let's keep it simple and
decide
that the extra digits will be "A", "B", "C",
"D", "E" and "F" (lower case may or may not
be ok). In our new system, "A" has the value ten, "B"
is eleven, etc upto "F" which is fifteen.</p>
<p>To represent numbers greater than fifteen, we must combine two
digits:
one for the "sixteenth" and one for the units. &gt;23 means "two
times sixteen, plus three", which is thirty-five. This way we can
write down 16*16=256 numbers.</p>
<p>To go further, we need a third digit whose value will be 256, a
fourth
one whose value will be 4096 (i.e. 16*16*16), etc.</p>
<p>For instance: &gt;123B means "1 times 4096, plus 2 times 256, plus
3 times 16, plus 11" which is 4667.</p>
<h4><br>
Base indication</h4>
<p>We also need a way to distinguish our new numbering system, that
we'll
call "hexadecimal", from the good old decimal one. Obviously,
any number containing digits from "A" through "F" has
to be hexadecimal. But if I write 10, do I mean ten or sixteen?</p>
<p>Texas Instruments adopted the following convention: any hexadecimal
number must be preceded by a "greater sign" sign. E.g. &gt;1234</p>
<p>Most PC people use another convention: append a h to the number:
1234h
(which also allows to append a d for decimal numbers, a b for binary,
etc).</p>
<p>High-level languages like C and C++ use yet another convention:
start
any hexadecimal number with "0x". E.g. 0x1234. The "x"
stands of course for hexadecimal and the leading 0 is only here so that
the compiler won't mistake the number for a variable name (variable
names
cannot start with a digit from 0 to 9 in C/C++).</p>
<h4><br>
Binary notation: base 2</h4>
<p>As mentionned above, we could also use less than 10 digits, if we
wanted
two. Let's say we use only two: "0" and "1". This will
allow us to write down the numbers zero and one. To go further we'll
need
an extra digits for the pairs: 10 means "one pair, plus no unit"
wich is two. And 11 means "one pair, plus one unit" which is
three.</p>
<p>The next digits will a a weithg of 4, the next one a weight of 8,
etc.</p>
<p>For instance, the number 11001101 reads as "1 times 128, plus 1
times 64, plus 0 times 32, plus 0 times 16, plus 1 times times 8, plus
one times 4, plus 0 times 2, plus 1" which is 205 in decimal.</p>
<p>Why would we want to use such a clumsy numbering system? Because
it's
easy to translate in terms of hardware: 0 means "no current"
and 1 means "current flowing" for instance. Or 0 could mean "0
volts" and 1 mean "5 volts".</p>
<p>That's how today's computers are built: they represent all numbers
in
binary and encode them as two voltage levels. In the early times of
computing,
there were also "anolog" computers, that were using 10 different
voltage levels to encode decimal numbers. But these were technically
difficult
to built and were completely superceeded by digital computers.</p>
<h4><br>
Base conversions</h4>
<p>As you have probably noted from the examples above, converting a hex
number into a decimal number is not easy, especially with very large
numbers
(You have 30 seconds to calculate the decimal value of
&gt;123456789ABCDEF0).</p>
<p>The problem is even worse with binary numbers: how much is
10010110101101001001010
in decimal?</p>
<p>Converting decimal numbers to another base is also annoying: How
much
is 3333 is hexadecimal?&nbsp;We must do the following:</p>
<p>How many times &gt;1000 (i.e. 4096) in 3333? Zero.<br>
How many time &gt;0100 (i.e. 256) in 3333? Thirteen, which is &gt;D in
hex notation. The remainder is 3333-(13*256)=5.<br>
How many times &gt;0010 (i.e. 16) in 5? Zero.<br>
How many times &gt;0001 (i.e. 1) in 5. Five.<br>
The result is thus: &gt;0D05</p>
<p>By contrast, conversions between hexadecimal and binary are very
easy.
Do you see why? Because 16 is a power of 2, whereas 10 is not. Just
compare
the "weight" of the digits in the various bases:</p>
<p>Decimal: 1, 10, 100, 1000, 10000, etc.<br>
Hexadecimal: 1, 16, 256, 4096, 65536, etc.<br>
Binary: <b>1</b>, 2, 4, 8, <b>16</b>, 32, 64, 128, <b>256</b>, 512,
1024,
2048, <b>4096</b>, 8192, 16384, 32768, <b>65536</b>, etc.</p>
<p>Now do you see the pattern? Every fourth binary digit has the same
weight
than an hexadecimal digit (this never occurs with decimal). This means
that we can split any binary number in groups of four digits and
convert
them individually into an hex digit.</p>
<p>To come back to the example above (how much is
10010110101101001001010
in hexadecimal?). Piece of cake:</p>
<pre>100 1011 0101 1010 0100 1010 is<br>&gt;4   B    5    A    4    A    i.e. &gt;4B5A4A</pre>
<p>And conversely, to translate &gt;1234 in binary:</p>
<pre> &gt;1    2    3    4<br>0001 0010 0011 0100 Done in five seconds!</pre>
<p>All you need to know are the 16 first binary values. That's easier
to
memorize than the powers of two!</p>
<table border="1">
  <tbody>
    <tr>
      <th>Hex</th>
      <th>Binary</th>
      <th>Hex</th>
      <th>Binary</th>
    </tr>
    <tr>
      <td>&gt;0</td>
      <td>0000</td>
      <td>&gt;8</td>
      <td>1000</td>
    </tr>
    <tr>
      <td>&gt;1</td>
      <td>0001</td>
      <td>&gt;9</td>
      <td>1001</td>
    </tr>
    <tr>
      <td>&gt;2</td>
      <td>0010</td>
      <td>&gt;A</td>
      <td>1010</td>
    </tr>
    <tr>
      <td>&gt;3</td>
      <td>0011</td>
      <td>&gt;B</td>
      <td>1011</td>
    </tr>
    <tr>
      <td>&gt;4</td>
      <td>0100</td>
      <td>&gt;C</td>
      <td>1100</td>
    </tr>
    <tr>
      <td>&gt;5</td>
      <td>0101</td>
      <td>&gt;D</td>
      <td>1101</td>
    </tr>
    <tr>
      <td>&gt;6</td>
      <td>0110</td>
      <td>&gt;E</td>
      <td>1110</td>
    </tr>
    <tr>
      <td>&gt;7</td>
      <td>0111</td>
      <td>&gt;F</td>
      <td>1111</td>
    </tr>
  </tbody>
</table>
<p>And this is why computer people use hexadecimal a lot. Note that we
could also have used another power of two as a base. Eight for
instance,
using only digits "0" through "7". This is known as
"octal" and is sometimes used, but much less often than hexadecimal.
It has the advantage than you do not need extra digits.</p>
<h4><br>
Hex math</h4>
<p>To perform hexadecimal operations, we'll follow the exact same rules
than for decimal operations:</p>
<pre>  &gt;1234<br>+<u> &gt;96FB<br></u>       <br></pre>
<p>Lets start from the rightmost digit: "4" plus "B"
(four plus eleven) is "F" (sixteen):</p>
<pre>  &gt;1234<br>+<u> &gt;96FB<br></u>      F  </pre>
<p><br>
Second digit: "3" plus "F" (three plus fifteen) is
eighteen (&gt;12). We thus have a carry of sixteen and put down two.</p>
<pre>    1<br>  &gt;1234<br>+<u> &gt;96FB<br></u>     2F       </pre>
<p>Now, "2" plus "6", plus the carried "1"
is "9".</p>
<pre>  &gt;1234<br>+<u> &gt;96FB<br></u>    92F       </pre>
<p>And finally "9" plus "1" is "A". Et voila!</p>
<pre>  &gt;1234<br>+<u> &gt;96FB<br></u>  &gt;A92F</pre>
<p>We can do the same thing in base 2:</p>
<pre>             1       11       1<br> 100010   100010   100010   100010   100010   100010<br>+<u>010110</u>  +<u>010110</u>  +<u>010110</u>  +<u>010110</u>  +<u>010110</u>  +<u>01011</u>0<br>      0       00      000     1000    01000   101000<br>          carry 1  carry    report<br>                   again    carry</pre>
<p><br>
I'll let you do substractions as an exercise...</p>
<h4><br>
Negative numbers</h4>
<p>It's often necessary to deal with negative numbers. Therefore
several
conventions have been established to represent a negative number in
binay
format. Generally, the leftmost bit is used a a sign bit: e.g."0"
means positive and "1" means negative.</p>
<p>The remaining bits may represent the number, and they do in some
conventions.
However, the most common convention is "two's complement". It
is the one used by Texas Instruments for the TI-99/4A.</p>
<p>In two's complement notation, negative numbers are represented as
follows:</p>
<p>&gt;FFFF is -1<br>
&gt;FFFE is -2<br>
&gt;FFFD is -3<br>
...<br>
&gt;8001 is -32767<br>
&gt;8000 is -32768</p>
<p>The big advantage of this notation is that &gt;FFFF is greater than
&gt;FFFE, which is mathematically correct (-1 is greater than -2), and
also true for unsigned numbers.</p>
<p>Problem only occur when comparing a negative number with a positive
one: &gt;FFFF is greater than &gt;0001, but -1 is smaller than 1.</p>
<p>That's why the TMS9900 status register contains two status bits for
number comparisons: "high" that deals with unsigned values, and
"Gt" that considers the values as signed.</p>
<address><br>
Revision 1. 6/9/99 Preliminary<br>
Revision 2. 6/13/99 Ok to release</address>
<center>
<p><br>
<a href="titechpages.htm">Back to the TI-99/4A Tech Pages</a></p>
</center>
<p><br>
</p>
</body>
</html>
