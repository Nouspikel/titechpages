<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
  <title></title>
  <meta name="Author" content="">
  <meta name="GENERATOR"
 content="User-Agent: Mozilla/3.04Gold (Macintosh; I; PPC)">
</head>
<body>
<h1 align="center"><a
 href="http://www.nouspikel.com/ti99/titechpages.htm"><img
 src="logo.jpg" style="border: 0px solid ; height: 33px; width: 95px;"
 title="" alt=""></a></h1>
<h1>GROMs</h1>
<p>Graphic Read-Only Memories (GROMs) are a very peculiar type of ROM
manufactured
by Texas Instruments. They have a multiplexed address and data port,
which
means you must telll the GROM which address you want to access and then
reach data in there. The GROM has an internal counter that is
automatically
incremented each time you access data, so that you don't need to
re-enter
the address each time. </p>
<p><a href="#pinout">Pinout<br>
</a><a href="#operation">Theory of operation</a></p>
<p><b>The TI-99/4A GROMs<br>
</b><a href="#GROM%20port">GROM port<br>
</a><a href="#GROM%20header">GROM headers<br>
</a><a href="#GROM%20subroutines">Console GROMs</a></p>
<h3><a name="Pinout"></a>Pinout</h3>
<pre>          +----+--+----+ <br>      AD7 |1 o  G    16| Vss              <br>      AD6 |2    R    15| GR<br>      AD5 |3    O    14| Vdd<br>      AD4 |4    M    13| GRC <br>      AD3 |5         12| M<br>      AD2 |6         11| MO<br>      AD1 |7         10| GS<br>      AD0 |8          9| Vcc <br>          +------------+</pre>
<p><u>Power supply<br>
</u><b>Vcc </b>+5V<br>
<b>Vdd</b> -5V<br>
<b>Vss </b>Ground. Actually -0.72V in the TI-99/4A console due to the
following
circuit (whose purpose is totally mysterious to me):</p>
<pre>-5V--WWW-----+---+---|Vss    |<br>     270     <u>|</u>   |   +-------+<br>      PG1992 ^   = 0.1uF<br>             |   |<br>            Gnd  Gnd</pre>
<p><br>
<u>CPU interface<br>
</u><b>AD0-AD7</b> Multiplexed address and data bus.<br>
<b>M</b> Direction: Read (high) or Write (low). Connected to DBIN in
the
console.<br>
<b>MO</b> Access mode: Address counter (high) or GROM data (low).
Connected
to A14 in the console (via a TTL buffer).<br>
<b>GS*</b> GROM select. Active low, chip select signal.</p>
<p><b>GREADY</b> Active high: signals that the GROM is ready to operate.<br>
<b>GRCLK</b> Clock signal, 3.5 MHz generated by the VDP (pin 38) or
447.4
kHz generated by the VDP (pin. 37). The actual signal is selected via a
jumper in the console. As far as I know, it's the 447.4 kHz that's used.</p>
<h3><br>
<a name="operation"></a>Theory of operation</h3>
<p>The GREADY line is necessary because GROMs are slow memory devices:
this line puts the TMS9900 microprocessor on hold until the GROM is
ready
to answer.</p>
<p>The M line determines the direction of access: read or write.
Obviously
writing data to a GROM is meaningless, but this line is required to
write
an address.</p>
<p>The MO pin determines whether the AD0-AD7 port is accessing the
address
counter or the data. When MO is low, data can be accessed on a
byte-wise
manner. The counter will be incremented after each operation, whether
it's
a read or a write. When the top of the GROM is reached, the counter
loops
back to zero.</p>
<p>If MO is high, writing operations load an address into the counter.
As an single-byte address would limit GROM sizes to 256 bytes, the
address
must be passed as two bytes. The GROM has an internal flip-flop that
keeps
track of the bytes entered and "knows" whether it is the first,
least significant byte, or the second. Any data access resets this
flip-flop
to "first byte expected".</p>
<p>Reading from the GROM with MO high returns the current value of the
counter *PLUS ONE* (don't ask me why). Here also, the lower byte is
passed
first, then the high-order byte.</p>
<p>The standard TI-GROM size is &gt;1800 bytes, wich means any address
can be expressed as a 13-bit number. The remaining 3-bits are used as
GROM
identifier: only the GROM with a matchin internal ID will respond to
such
an address.</p>
<p><u>Exemple</u> (address &gt;54A6):</p>
<pre>0101 0100 1010 0110<br>iiiA AAAA AAAA AAAA     Address = &gt;1456, ID = 2</pre>
<p>This allows to install upto 8 GROMs on the same data bus: they all
respond
to every address operation, latching the current address or returning
the
counter value (plus one). But only the GROM with an ID matching that in
the high-order address byte will accept data operations. Typically, you
would have :</p>
<pre>GROM 0: &gt;0000-17FF<br>GROM 1: &gt;2000-37FF<br>GROM 2: &gt;4000-57FF<br>GROM 3: &gt;6000-77FF<br>GROM 4: &gt;8000-97FF<br>GROM 5: &gt;A000-B7FF<br>GROM 6: &gt;C000-D7FF<br>GROM 7: &gt;E000-F7FF</pre>
<p>That's kind of a waste of space since &gt;0800 bytes in each GROM
are
lost in addressing gaps. I know there were a few cartridges around that
had full-size GROMs of &gt;2000 bytes, but I'm not sure whether these
were
real GROMs or ROMs with an emulation circuitery.</p>
<h2><br>
<a name="GROM port"></a>The TI-99/4A GROMs</h2>
<p>There are three places GROMs can be found in the TI-99/4A: in the
console,
in a cartridge or in a peripheral card. </p>
<p>The console contains three &gt;1800-byte GROMs, with ID numbers 0, 1
and 2. Which means they map at addresses &gt;0000-17FF, &gt;2000-37FF,
and &gt;4000-57FF. These GROMs contain most of the Basic Interpreter,
routines
for mathematical operations with real numbers, and DSRs for cassette
tape
operations.</p>
<p>In addition, GROMs 3 to 7 (addresses &gt;6000-FFFF) can be
implemented
in cartidges to be plugged in the front panel of the console. For more
information, see my pages (including commented listings) for the
following
cartridges: <a href="ea_mod.htm">Editor/Assembler</a>, <a
 href="mm_mod.htm">Mini-Memory</a>
and <a href="wr_mod.htm">TI-Writer</a>. </p>
<p>Apart for GRAM cards, the only peripheral card with GROMs I'm aware
of is the p-code card.</p>
<h4><br>
GROM port</h4>
<p>No matter where they are installed, GROMs are always accessed
through
a set of 4 addresses in CPU memory. The first address is known as the
"GROM
base":</p>
<p>&gt;9800: read data (GROM base)<br>
&gt;9802: read address+1<br>
&gt;9C00: write data<br>
&gt;9C02: write address</p>
<p>As you may have guessed, addess line A5 (weight &gt;0400) is
connected
to the MO pins of the GROMs. Different addresses are used to read and
write
because the TMS9900 always preceedes a write with a read operation.
This
would have the annoying result of bumping the GROM counter by two on a
data write operation! The solution is straightforward: a simple TTL
circuitery
filters out reading operations at address &gt;9Cxx. Only the write goes
through so the counter increments only once.</p>
<p>Texas Instruments probably sensed that 8 times &gt;1800 bytes
wouldn't
be enough memory, so they implemented an additional level of subtility
in the TI-99/4A. There are upto 16 sets of 4 addresses that can be used
for GROM access. The GROM base for each set is &gt;0004 apart:
&gt;9800,
&gt;9804, &gt;9808, &gt;980C ... &gt;983C. In fact, the address space
is
free upto &gt;9C00, so there could technically be 256 such sets.
However
the console ROM routines that search GROMs for subprograms only
consider
the first 16 bases. But still, this provides an address space of 16 *
64K,
which is 1 megabyte. Even with gaps, it's not bad for a 1980s computer!</p>
<p>Mind you, the console does not contain any circuitery to decode the
GROM base, which means that the console GROMs can be accessed from any
GROM base. Ditto for the classical TI cartridges like Extended Basic or
Editor/Assembler. But the possibility is here: one could design an
extension
device that would let you plug in several cartridges and have one at
base
&gt;9800, another at base &gt;9804, etc. To my knowledge, such a gadget
was never released, but several GRAM-cards make use of this trick. For
instance the german 128K <a href="gramkart.htm">GramKarte</a> uses
bases
&gt;9800 and &gt;9820.</p>
<h3><br>
<a name="GROM header"></a>GROM Header</h3>
<p>Optionally, a GROM can start with a standard header that contains
lists
of programs, subprograms, DSRs, etc. The first byte in the GROM must be
&gt;AA to indicate that this GROM contains a header. The structure of
such
a header is the following:</p>
<table border="2" cellspacing="2" cellpadding="2">
  <tbody>
    <tr>
      <th>Bytes</th>
      <th width="45%">Content</th>
      <td width="45%"><br>
      </td>
    </tr>
    <tr>
      <td>&gt;x000</td>
      <td width="45%">&gt;AA indicates a standard header</td>
      <td width="45%"><br>
      </td>
    </tr>
    <tr>
      <td>&gt;x001</td>
      <td width="45%">Version number</td>
      <td width="45%"><br>
      </td>
    </tr>
    <tr>
      <td>&gt;0xx2</td>
      <td width="45%">Number of programs (optional)</td>
      <td width="45%"><br>
      </td>
    </tr>
    <tr>
      <td>&gt;x003</td>
      <td width="45%">Not used</td>
      <td width="45%"><br>
      </td>
    </tr>
    <tr>
      <td>&gt;x004</td>
      <td colspan="2" width="90%">Pointer to power-up list (&gt;0000 if
none)</td>
    </tr>
    <tr>
      <td>&gt;x006</td>
      <td colspan="2" width="90%">Pointer to program list (&gt;0000 if
none)</td>
    </tr>
    <tr>
      <td>&gt;x008</td>
      <td colspan="2" width="90%">Pointer the DSR list (&gt;0000 if
none)</td>
    </tr>
    <tr>
      <td>&gt;x00A</td>
      <td colspan="2" width="90%">Pointer to subprogram list (&gt;0000
if none)</td>
    </tr>
  </tbody>
</table>
<p><u>Structure of a list:</u></p>
<pre>Link to next item --+<br>Address             |<br>Name length         |<br>Name                |<br>+-------------------+<br>|<br>V<br>Link to next item: &gt;0000<br>Address<br>Name length<br>Name</pre>
<pre>N.B. Name lengh and name are not necessary for power-up routines</pre>
<p>If you would like more details on standard headers and how to write
subprograms and/or DSRs, I have a whole <a href="headers.htm">page </a>on
the subject.</p>
<h4><br>
<a name="GROM subroutines"></a>Console GROMs</h4>
<p>A commented listing of the console GROMs can be found in Heiner
Martin's
book "TI-99/4A intern" (<a
 href="http://99er.hispeed.com/files/tiintern.pdf">pdf
file 560k</a>). Here I'm just providing a brief description of the
contents
of these GROMs.</p>
<p>Only GROMs 0 and 1 have a standard header, GROM 2 is the
continuation
of GROM 1 and has no header.</p>
<p>At the beginning of GROM 0 is a table of subprograms, that contains
only branching instructions (mostly BR, and a few B). The location of
these
subprograms may vary among GROM versions, but the table is always at
the
same place. The way to use these routine is described in my page on GPL
language, clicking on one of the addresses in the table below will take
you there.</p>
<p>N.B. FAC (floating point accumulator) corresponds to &gt;834A-8351,
ARG (argument) to &gt;835C-8363</p>
<table border="1">
  <tbody>
    <tr>
      <th>Mnemonic</th>
      <th>Address</th>
      <th>Use</th>
    </tr>
    <tr>
      <td>LINK</td>
      <td><a href="gpl2.htm#g@0010">&gt;0010</a></td>
      <td>Subroutine/DSR call: FETCh &gt;0A/&gt;08, name ptr in &gt;8356</td>
    </tr>
    <tr>
      <td>RETURN</td>
      <td><a href="gpl2.htm#g@0012">&gt;0012</a></td>
      <td>Return from a subroutine/DSR</td>
    </tr>
    <tr>
      <td>CNS</td>
      <td><a href="gpl2.htm#g@0014">&gt;0014</a></td>
      <td>Convert number to string (from FAC to FAC, infos in
&gt;8355-57)</td>
    </tr>
    <tr>
      <td>STCASE</td>
      <td><a href="gpl2.htm#g@0016">&gt;0016</a></td>
      <td>Load title screen character patterns at VDP address in
&gt;834A</td>
    </tr>
    <tr>
      <td>UPCASE</td>
      <td><a href="gpl2.htm#g@0018">&gt;0018</a></td>
      <td>Load upper case character patterns at VDP address in &gt;834A</td>
    </tr>
    <tr>
      <td>BWARN</td>
      <td><a href="gpl2.htm#g@001a">&gt;001A</a></td>
      <td>Issue warning message</td>
    </tr>
    <tr>
      <td>BERR</td>
      <td><a href="gpl2.htm#g@001c">&gt;001C</a></td>
      <td>Issue error message</td>
    </tr>
    <tr>
      <td>BEXEC</td>
      <td><a href="gpl2.htm#g@001e">&gt;001E</a></td>
      <td>Begins Basic excution: FETCh 4 bytes: address of first and
last lines
      </td>
    </tr>
    <tr>
      <td>PWRUP</td>
      <td><a href="gpl2.htm#g@0020">&gt;0020</a></td>
      <td>System reset</td>
    </tr>
    <tr>
      <td>INT</td>
      <td><a href="gpl2.htm#g@0022">&gt;0022</a></td>
      <td>Convert real to integer (from FAC to FAC)</td>
    </tr>
    <tr>
      <td>PWR</td>
      <td><a href="gpl2.htm#g@0024">&gt;0024</a></td>
      <td>Power-of-ten routine FAC=FAC * 10^ARG</td>
    </tr>
    <tr>
      <td>SQR</td>
      <td><a href="gpl2.htm#g@0026">&gt;0026</a></td>
      <td>Square root routine FAC=SQR(FAC)</td>
    </tr>
    <tr>
      <td>EXP</td>
      <td><a href="gpl2.htm#g@0028">&gt;0028</a></td>
      <td>Exponentiation routine FAC=e^FAC</td>
    </tr>
    <tr>
      <td>LOG</td>
      <td><a href="gpl2.htm#g@002a">&gt;002A</a></td>
      <td>Logarithm calculation FAC=ln(FAC)</td>
    </tr>
    <tr>
      <td>COS</td>
      <td><a href="gpl2.htm#g@002C">&gt;002C</a></td>
      <td>Cosine calculation FAC=cos(FAC)</td>
    </tr>
    <tr>
      <td>SIN</td>
      <td><a href="gpl2.htm#g@002e">&gt;002E</a></td>
      <td>Sine calculation FAC=sin(FAC)</td>
    </tr>
    <tr>
      <td>TAN</td>
      <td><a href="gpl2.htm#g@0030">&gt;0030</a></td>
      <td>Tangent calculation FAC=tgn(FAC)</td>
    </tr>
    <tr>
      <td>ATN</td>
      <td><a href="gpl2.htm#g@0032">&gt;0032</a></td>
      <td>Arctangent calculation FAC=atn(FAC)</td>
    </tr>
    <tr>
      <td>BEEP</td>
      <td><a href="gpl2.htm#g@0034">&gt;0034</a></td>
      <td>Issue acceptation sound</td>
    </tr>
    <tr>
      <td>HONK</td>
      <td><a href="gpl2.htm#g@0036">&gt;0036</a></td>
      <td>Issue error sound</td>
    </tr>
    <tr>
      <td>GETSPA</td>
      <td><a href="gpl2.htm#g@0038">&gt;0038</a></td>
      <td>Get VDP memory space for a string</td>
    </tr>
    <tr>
      <td>BITREV</td>
      <td><a href="gpl2.htm#g@003b">&gt;003B</a></td>
      <td>Bit reversal routine &gt;834A: VDP address, &gt;834C: number
of bytes</td>
    </tr>
    <tr>
      <td>NAMLNK</td>
      <td><a href="gpl2.htm#g@003d">&gt;003D</a></td>
      <td>Part of LINK: searches in GROM only</td>
    </tr>
    <tr>
      <td>PABSPA</td>
      <td><a href="gpl2.htm#g@003f">&gt;003F</a></td>
      <td>Check memory space for PAB</td>
    </tr>
    <tr>
      <td>TOKEN</td>
      <td><a href="gpl2.htm#g@0042">&gt;0042</a></td>
      <td>Get next token, set Basic pointers</td>
    </tr>
    <tr>
      <td>LOCASE</td>
      <td><a href="gpl2.htm#g@004A">&gt;004A</a></td>
      <td>Load lower case character patterns</td>
    </tr>
  </tbody>
</table>
<p><br>
The address of the following routines may vary, since they are not
included
in a vector (branch) table.</p>
<table border="1">
  <tbody>
    <tr>
      <th>Address</th>
      <th>Use</th>
    </tr>
    <tr>
      <td>&gt;1387</td>
      <td>OPEN cassette.</td>
    </tr>
    <tr>
      <td>&gt;13CF</td>
      <td>READ cassette.</td>
    </tr>
    <tr>
      <td>&gt;13DA</td>
      <td>WRITE cassette.</td>
    </tr>
    <tr>
      <td>&gt;13F2</td>
      <td>OLD cassette.</td>
    </tr>
    <tr>
      <td>&gt;140E</td>
      <td>CLOSE cassette.</td>
    </tr>
    <tr>
      <td>&gt;1444</td>
      <td>Verify cassette.</td>
    </tr>
    <tr>
      <td>&gt;1489</td>
      <td>SAVE cassette.</td>
    </tr>
    <tr>
      <td>&gt;216F</td>
      <td>Start of Basic interpreter (Entry point for NEW).</td>
    </tr>
    <tr>
      <td>&gt;2214</td>
      <td>Address table for RUN, NEW, CONTINUE, LIST, BYE, <br>
NUMBER, OLD, RES,SAVE and EXIT.</td>
    </tr>
    <tr>
      <td>&gt;27E3</td>
      <td>Clears screen, resets cursor and continues as below:</td>
    </tr>
    <tr>
      <td>&gt;27F1</td>
      <td>Loads char patterns, resets colors and VDP registers 2,3 and
4. </td>
    </tr>
    <tr>
      <td>&gt;2A42</td>
      <td>Start line editor with default position and length.</td>
    </tr>
    <tr>
      <td>&gt;2A49</td>
      <td>Ditto with max length in &gt;835E.</td>
    </tr>
    <tr>
      <td>&gt;2A4F</td>
      <td>Ditto with starting screen position in &gt;8361.</td>
    </tr>
    <tr>
      <td>&gt;3450</td>
      <td>Checks if a char is valid for a variable name (A-Z, a-z,
0-9..).</td>
    </tr>
    <tr>
      <td>&gt;351C</td>
      <td>CALL CLEAR.</td>
    </tr>
    <tr>
      <td>&gt;3538</td>
      <td>CALL SOUND.</td>
    </tr>
    <tr>
      <td>&gt;360E</td>
      <td>CALL HCHAR.</td>
    </tr>
    <tr>
      <td>&gt;362A</td>
      <td>CALL VCHAR.</td>
    </tr>
    <tr>
      <td>&gt;3643</td>
      <td>CALL CHAR.</td>
    </tr>
    <tr>
      <td>&gt;3708</td>
      <td>CALL KEY.</td>
    </tr>
    <tr>
      <td>&gt;3748</td>
      <td>CALL JOYST.</td>
    </tr>
    <tr>
      <td>&gt;37D6</td>
      <td>CALL SCREEN.</td>
    </tr>
    <tr>
      <td>&gt;401E</td>
      <td>OPEN a file.</td>
    </tr>
    <tr>
      <td>&gt;4160</td>
      <td>DELETE a file.</td>
    </tr>
    <tr>
      <td>&gt;4174</td>
      <td>CLOSE a file</td>
    </tr>
    <tr>
      <td>&gt;41CF</td>
      <td>Closes all files.</td>
    </tr>
    <tr>
      <td>&gt;41D7</td>
      <td>RESTORE a file.</td>
    </tr>
    <tr>
      <td>&gt;4227</td>
      <td>PRINT in a file or on screen.</td>
    </tr>
    <tr>
      <td>&gt;426C</td>
      <td>DISPLAY on screen. </td>
    </tr>
    <tr>
      <td>&gt;4344</td>
      <td>INPUT from files or keyboard.</td>
    </tr>
    <tr>
      <td>&gt;45E3</td>
      <td>READ the DATA inserted in a program.</td>
    </tr>
    <tr>
      <td>&gt;4641</td>
      <td>OLD loads a program.</td>
    </tr>
    <tr>
      <td>&gt;46FC</td>
      <td>SAVE a program.</td>
    </tr>
    <tr>
      <td>&gt;474C</td>
      <td>LIST a program.</td>
    </tr>
    <tr>
      <td>&gt;482B</td>
      <td>EOF tests for end of file.</td>
    </tr>
    <tr>
      <td>&gt;4D7C</td>
      <td>Prints "Bad Value".</td>
    </tr>
    <tr>
      <td>&gt;4D81</td>
      <td>Prints "String-number mismatch".</td>
    </tr>
    <tr>
      <td>&gt;566C</td>
      <td>Prints "Can't do that".</td>
    </tr>
    <tr>
      <td>&gt;56CD</td>
      <td>Scrolls up.</td>
    </tr>
    <tr>
      <td>&gt;56EF</td>
      <td>CALL GCHAR.</td>
    </tr>
    <tr>
      <td>&gt;5713</td>
      <td>CALL COLOR.</td>
    </tr>
  </tbody>
</table>
<p><br>
Finally, here are some usefull data in GROM. The exact addresses may
also
vary according to GROM versions:</p>
<table border="1">
  <tbody>
    <tr>
      <th>Address</th>
      <th>Contents</th>
    </tr>
    <tr>
      <td>&gt;0451</td>
      <td>Default values of the 8 VDP registers.</td>
    </tr>
    <tr>
      <td>&gt;0459</td>
      <td>Content of the color table, for title screen.</td>
    </tr>
    <tr>
      <td>&gt;04B4</td>
      <td>Characters 32 to 95 patterns, for title screen.</td>
    </tr>
    <tr>
      <td>&gt;06B4</td>
      <td>Regular upper case character patterns.</td>
    </tr>
    <tr>
      <td>&gt;0874</td>
      <td>Lower case character patterns.</td>
    </tr>
    <tr>
      <td>&gt;16E0</td>
      <td>Joysticks codes returned by SCAN.</td>
    </tr>
    <tr>
      <td>&gt;1700</td>
      <td>Key codes returned by SCAN.</td>
    </tr>
    <tr>
      <td>&gt;1730</td>
      <td>Ditto with SHIFT.</td>
    </tr>
    <tr>
      <td>&gt;1760</td>
      <td>Ditto with FCTN.</td>
    </tr>
    <tr>
      <td>&gt;1790</td>
      <td>Ditto with CTRL.</td>
    </tr>
    <tr>
      <td>&gt;17C0</td>
      <td>Key codes in keyboard modes 1 et 2 (half-keyboards).</td>
    </tr>
    <tr>
      <td>&gt;2022</td>
      <td>Error messages (with Basic bias of &gt;60, and lenght byte).</td>
    </tr>
    <tr>
      <td>&gt;285C</td>
      <td>Reserved words in Basic, and corresponding tokens.</td>
    </tr>
  </tbody>
</table>
<address><br>
Revision 1. 3/2/00 Preliminary<br>
Revision 2. 3/4/00 OK to release<br>
Revision 3. 5/25/01 Corrected clock and Vss info.<br>
</address>
<center>
<p><a href="titechpages.htm">Back to the TI-99/4A Tech Pages</a></p>
</center>
</body>
</html>
